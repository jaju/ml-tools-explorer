// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h_3 extends Python_h_4 {

    Python_h_3() {
        // Should not be called directly
    }
    private static final int ENOATTR = (int)93L;
    /**
     * {@snippet lang=c :
     * #define ENOATTR 93
     * }
     */
    public static int ENOATTR() {
        return ENOATTR;
    }
    private static final int EBADMSG = (int)94L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 94
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int EMULTIHOP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define EMULTIHOP 95
     * }
     */
    public static int EMULTIHOP() {
        return EMULTIHOP;
    }
    private static final int ENODATA = (int)96L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 96
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ENOLINK = (int)97L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 97
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int ENOSR = (int)98L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 98
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENOSTR = (int)99L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 99
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int EPROTO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 100
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int ETIME = (int)101L;
    /**
     * {@snippet lang=c :
     * #define ETIME 101
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int EOPNOTSUPP = (int)102L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 102
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int ENOPOLICY = (int)103L;
    /**
     * {@snippet lang=c :
     * #define ENOPOLICY 103
     * }
     */
    public static int ENOPOLICY() {
        return ENOPOLICY;
    }
    private static final int ENOTRECOVERABLE = (int)104L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 104
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int EOWNERDEAD = (int)105L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 105
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int EQFULL = (int)106L;
    /**
     * {@snippet lang=c :
     * #define EQFULL 106
     * }
     */
    public static int EQFULL() {
        return EQFULL;
    }
    private static final int ELAST = (int)106L;
    /**
     * {@snippet lang=c :
     * #define ELAST 106
     * }
     */
    public static int ELAST() {
        return ELAST;
    }
    private static final int __DARWIN_NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NSIG 32
     * }
     */
    public static int __DARWIN_NSIG() {
        return __DARWIN_NSIG;
    }
    private static final int _ARM_SIGNAL_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_SIGNAL_ 1
     * }
     */
    public static int _ARM_SIGNAL_() {
        return _ARM_SIGNAL_;
    }
    private static final int SIGHUP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGHUP 1
     * }
     */
    public static int SIGHUP() {
        return SIGHUP;
    }
    private static final int SIGINT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIGINT 2
     * }
     */
    public static int SIGINT() {
        return SIGINT;
    }
    private static final int SIGQUIT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGQUIT 3
     * }
     */
    public static int SIGQUIT() {
        return SIGQUIT;
    }
    private static final int SIGILL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIGILL 4
     * }
     */
    public static int SIGILL() {
        return SIGILL;
    }
    private static final int SIGTRAP = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SIGTRAP 5
     * }
     */
    public static int SIGTRAP() {
        return SIGTRAP;
    }
    private static final int SIGABRT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGABRT 6
     * }
     */
    public static int SIGABRT() {
        return SIGABRT;
    }
    private static final int SIGEMT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SIGEMT 7
     * }
     */
    public static int SIGEMT() {
        return SIGEMT;
    }
    private static final int SIGFPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIGFPE 8
     * }
     */
    public static int SIGFPE() {
        return SIGFPE;
    }
    private static final int SIGKILL = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SIGKILL 9
     * }
     */
    public static int SIGKILL() {
        return SIGKILL;
    }
    private static final int SIGBUS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SIGBUS 10
     * }
     */
    public static int SIGBUS() {
        return SIGBUS;
    }
    private static final int SIGSEGV = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SIGSEGV 11
     * }
     */
    public static int SIGSEGV() {
        return SIGSEGV;
    }
    private static final int SIGSYS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define SIGSYS 12
     * }
     */
    public static int SIGSYS() {
        return SIGSYS;
    }
    private static final int SIGPIPE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define SIGPIPE 13
     * }
     */
    public static int SIGPIPE() {
        return SIGPIPE;
    }
    private static final int SIGALRM = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SIGALRM 14
     * }
     */
    public static int SIGALRM() {
        return SIGALRM;
    }
    private static final int SIGTERM = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SIGTERM 15
     * }
     */
    public static int SIGTERM() {
        return SIGTERM;
    }
    private static final int SIGURG = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SIGURG 16
     * }
     */
    public static int SIGURG() {
        return SIGURG;
    }
    private static final int SIGSTOP = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SIGSTOP 17
     * }
     */
    public static int SIGSTOP() {
        return SIGSTOP;
    }
    private static final int SIGTSTP = (int)18L;
    /**
     * {@snippet lang=c :
     * #define SIGTSTP 18
     * }
     */
    public static int SIGTSTP() {
        return SIGTSTP;
    }
    private static final int SIGCONT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define SIGCONT 19
     * }
     */
    public static int SIGCONT() {
        return SIGCONT;
    }
    private static final int SIGCHLD = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SIGCHLD 20
     * }
     */
    public static int SIGCHLD() {
        return SIGCHLD;
    }
    private static final int SIGTTIN = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SIGTTIN 21
     * }
     */
    public static int SIGTTIN() {
        return SIGTTIN;
    }
    private static final int SIGTTOU = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SIGTTOU 22
     * }
     */
    public static int SIGTTOU() {
        return SIGTTOU;
    }
    private static final int SIGIO = (int)23L;
    /**
     * {@snippet lang=c :
     * #define SIGIO 23
     * }
     */
    public static int SIGIO() {
        return SIGIO;
    }
    private static final int SIGXCPU = (int)24L;
    /**
     * {@snippet lang=c :
     * #define SIGXCPU 24
     * }
     */
    public static int SIGXCPU() {
        return SIGXCPU;
    }
    private static final int SIGXFSZ = (int)25L;
    /**
     * {@snippet lang=c :
     * #define SIGXFSZ 25
     * }
     */
    public static int SIGXFSZ() {
        return SIGXFSZ;
    }
    private static final int SIGVTALRM = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SIGVTALRM 26
     * }
     */
    public static int SIGVTALRM() {
        return SIGVTALRM;
    }
    private static final int SIGPROF = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SIGPROF 27
     * }
     */
    public static int SIGPROF() {
        return SIGPROF;
    }
    private static final int SIGWINCH = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SIGWINCH 28
     * }
     */
    public static int SIGWINCH() {
        return SIGWINCH;
    }
    private static final int SIGINFO = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SIGINFO 29
     * }
     */
    public static int SIGINFO() {
        return SIGINFO;
    }
    private static final int SIGUSR1 = (int)30L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR1 30
     * }
     */
    public static int SIGUSR1() {
        return SIGUSR1;
    }
    private static final int SIGUSR2 = (int)31L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR2 31
     * }
     */
    public static int SIGUSR2() {
        return SIGUSR2;
    }
    private static final int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_OPAQUE_ARM_THREAD_STATE64 0
     * }
     */
    public static int __DARWIN_OPAQUE_ARM_THREAD_STATE64() {
        return __DARWIN_OPAQUE_ARM_THREAD_STATE64;
    }
    private static final int SIGEV_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_NONE 0
     * }
     */
    public static int SIGEV_NONE() {
        return SIGEV_NONE;
    }
    private static final int SIGEV_SIGNAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_SIGNAL 1
     * }
     */
    public static int SIGEV_SIGNAL() {
        return SIGEV_SIGNAL;
    }
    private static final int SIGEV_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_THREAD 3
     * }
     */
    public static int SIGEV_THREAD() {
        return SIGEV_THREAD;
    }
    private static final int ILL_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ILL_NOOP 0
     * }
     */
    public static int ILL_NOOP() {
        return ILL_NOOP;
    }
    private static final int ILL_ILLOPC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPC 1
     * }
     */
    public static int ILL_ILLOPC() {
        return ILL_ILLOPC;
    }
    private static final int ILL_ILLTRP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLTRP 2
     * }
     */
    public static int ILL_ILLTRP() {
        return ILL_ILLTRP;
    }
    private static final int ILL_PRVOPC = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVOPC 3
     * }
     */
    public static int ILL_PRVOPC() {
        return ILL_PRVOPC;
    }
    private static final int ILL_ILLOPN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPN 4
     * }
     */
    public static int ILL_ILLOPN() {
        return ILL_ILLOPN;
    }
    private static final int ILL_ILLADR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLADR 5
     * }
     */
    public static int ILL_ILLADR() {
        return ILL_ILLADR;
    }
    private static final int ILL_PRVREG = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVREG 6
     * }
     */
    public static int ILL_PRVREG() {
        return ILL_PRVREG;
    }
    private static final int ILL_COPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define ILL_COPROC 7
     * }
     */
    public static int ILL_COPROC() {
        return ILL_COPROC;
    }
    private static final int ILL_BADSTK = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ILL_BADSTK 8
     * }
     */
    public static int ILL_BADSTK() {
        return ILL_BADSTK;
    }
    private static final int FPE_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FPE_NOOP 0
     * }
     */
    public static int FPE_NOOP() {
        return FPE_NOOP;
    }
    private static final int FPE_FLTDIV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTDIV 1
     * }
     */
    public static int FPE_FLTDIV() {
        return FPE_FLTDIV;
    }
    private static final int FPE_FLTOVF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTOVF 2
     * }
     */
    public static int FPE_FLTOVF() {
        return FPE_FLTOVF;
    }
    private static final int FPE_FLTUND = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTUND 3
     * }
     */
    public static int FPE_FLTUND() {
        return FPE_FLTUND;
    }
    private static final int FPE_FLTRES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTRES 4
     * }
     */
    public static int FPE_FLTRES() {
        return FPE_FLTRES;
    }
    private static final int FPE_FLTINV = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTINV 5
     * }
     */
    public static int FPE_FLTINV() {
        return FPE_FLTINV;
    }
    private static final int FPE_FLTSUB = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTSUB 6
     * }
     */
    public static int FPE_FLTSUB() {
        return FPE_FLTSUB;
    }
    private static final int FPE_INTDIV = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTDIV 7
     * }
     */
    public static int FPE_INTDIV() {
        return FPE_INTDIV;
    }
    private static final int FPE_INTOVF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTOVF 8
     * }
     */
    public static int FPE_INTOVF() {
        return FPE_INTOVF;
    }
    private static final int SEGV_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEGV_NOOP 0
     * }
     */
    public static int SEGV_NOOP() {
        return SEGV_NOOP;
    }
    private static final int SEGV_MAPERR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEGV_MAPERR 1
     * }
     */
    public static int SEGV_MAPERR() {
        return SEGV_MAPERR;
    }
    private static final int SEGV_ACCERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEGV_ACCERR 2
     * }
     */
    public static int SEGV_ACCERR() {
        return SEGV_ACCERR;
    }
    private static final int BUS_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define BUS_NOOP 0
     * }
     */
    public static int BUS_NOOP() {
        return BUS_NOOP;
    }
    private static final int BUS_ADRALN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRALN 1
     * }
     */
    public static int BUS_ADRALN() {
        return BUS_ADRALN;
    }
    private static final int BUS_ADRERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRERR 2
     * }
     */
    public static int BUS_ADRERR() {
        return BUS_ADRERR;
    }
    private static final int BUS_OBJERR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define BUS_OBJERR 3
     * }
     */
    public static int BUS_OBJERR() {
        return BUS_OBJERR;
    }
    private static final int TRAP_BRKPT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TRAP_BRKPT 1
     * }
     */
    public static int TRAP_BRKPT() {
        return TRAP_BRKPT;
    }
    private static final int TRAP_TRACE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TRAP_TRACE 2
     * }
     */
    public static int TRAP_TRACE() {
        return TRAP_TRACE;
    }
    private static final int CLD_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLD_NOOP 0
     * }
     */
    public static int CLD_NOOP() {
        return CLD_NOOP;
    }
    private static final int CLD_EXITED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLD_EXITED 1
     * }
     */
    public static int CLD_EXITED() {
        return CLD_EXITED;
    }
    private static final int CLD_KILLED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLD_KILLED 2
     * }
     */
    public static int CLD_KILLED() {
        return CLD_KILLED;
    }
    private static final int CLD_DUMPED = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLD_DUMPED 3
     * }
     */
    public static int CLD_DUMPED() {
        return CLD_DUMPED;
    }
    private static final int CLD_TRAPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLD_TRAPPED 4
     * }
     */
    public static int CLD_TRAPPED() {
        return CLD_TRAPPED;
    }
    private static final int CLD_STOPPED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLD_STOPPED 5
     * }
     */
    public static int CLD_STOPPED() {
        return CLD_STOPPED;
    }
    private static final int CLD_CONTINUED = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLD_CONTINUED 6
     * }
     */
    public static int CLD_CONTINUED() {
        return CLD_CONTINUED;
    }
    private static final int POLL_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLL_IN 1
     * }
     */
    public static int POLL_IN() {
        return POLL_IN;
    }
    private static final int POLL_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define POLL_OUT 2
     * }
     */
    public static int POLL_OUT() {
        return POLL_OUT;
    }
    private static final int POLL_MSG = (int)3L;
    /**
     * {@snippet lang=c :
     * #define POLL_MSG 3
     * }
     */
    public static int POLL_MSG() {
        return POLL_MSG;
    }
    private static final int POLL_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define POLL_ERR 4
     * }
     */
    public static int POLL_ERR() {
        return POLL_ERR;
    }
    private static final int POLL_PRI = (int)5L;
    /**
     * {@snippet lang=c :
     * #define POLL_PRI 5
     * }
     */
    public static int POLL_PRI() {
        return POLL_PRI;
    }
    private static final int POLL_HUP = (int)6L;
    /**
     * {@snippet lang=c :
     * #define POLL_HUP 6
     * }
     */
    public static int POLL_HUP() {
        return POLL_HUP;
    }
    private static final int SA_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SA_ONSTACK 1
     * }
     */
    public static int SA_ONSTACK() {
        return SA_ONSTACK;
    }
    private static final int SA_RESTART = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SA_RESTART 2
     * }
     */
    public static int SA_RESTART() {
        return SA_RESTART;
    }
    private static final int SA_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SA_RESETHAND 4
     * }
     */
    public static int SA_RESETHAND() {
        return SA_RESETHAND;
    }
    private static final int SA_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDSTOP 8
     * }
     */
    public static int SA_NOCLDSTOP() {
        return SA_NOCLDSTOP;
    }
    private static final int SA_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SA_NODEFER 16
     * }
     */
    public static int SA_NODEFER() {
        return SA_NODEFER;
    }
    private static final int SA_NOCLDWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDWAIT 32
     * }
     */
    public static int SA_NOCLDWAIT() {
        return SA_NOCLDWAIT;
    }
    private static final int SA_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SA_SIGINFO 64
     * }
     */
    public static int SA_SIGINFO() {
        return SA_SIGINFO;
    }
    private static final int SA_USERTRAMP = (int)256L;
    /**
     * {@snippet lang=c :
     * #define SA_USERTRAMP 256
     * }
     */
    public static int SA_USERTRAMP() {
        return SA_USERTRAMP;
    }
    private static final int SA_64REGSET = (int)512L;
    /**
     * {@snippet lang=c :
     * #define SA_64REGSET 512
     * }
     */
    public static int SA_64REGSET() {
        return SA_64REGSET;
    }
    private static final int SIG_BLOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIG_BLOCK 1
     * }
     */
    public static int SIG_BLOCK() {
        return SIG_BLOCK;
    }
    private static final int SIG_UNBLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIG_UNBLOCK 2
     * }
     */
    public static int SIG_UNBLOCK() {
        return SIG_UNBLOCK;
    }
    private static final int SIG_SETMASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIG_SETMASK 3
     * }
     */
    public static int SIG_SETMASK() {
        return SIG_SETMASK;
    }
    private static final int SI_USER = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define SI_USER 65537
     * }
     */
    public static int SI_USER() {
        return SI_USER;
    }
    private static final int SI_QUEUE = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define SI_QUEUE 65538
     * }
     */
    public static int SI_QUEUE() {
        return SI_QUEUE;
    }
    private static final int SI_TIMER = (int)65539L;
    /**
     * {@snippet lang=c :
     * #define SI_TIMER 65539
     * }
     */
    public static int SI_TIMER() {
        return SI_TIMER;
    }
    private static final int SI_ASYNCIO = (int)65540L;
    /**
     * {@snippet lang=c :
     * #define SI_ASYNCIO 65540
     * }
     */
    public static int SI_ASYNCIO() {
        return SI_ASYNCIO;
    }
    private static final int SI_MESGQ = (int)65541L;
    /**
     * {@snippet lang=c :
     * #define SI_MESGQ 65541
     * }
     */
    public static int SI_MESGQ() {
        return SI_MESGQ;
    }
    private static final int SS_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SS_ONSTACK 1
     * }
     */
    public static int SS_ONSTACK() {
        return SS_ONSTACK;
    }
    private static final int SS_DISABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SS_DISABLE 4
     * }
     */
    public static int SS_DISABLE() {
        return SS_DISABLE;
    }
    private static final int MINSIGSTKSZ = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MINSIGSTKSZ 32768
     * }
     */
    public static int MINSIGSTKSZ() {
        return MINSIGSTKSZ;
    }
    private static final int SIGSTKSZ = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define SIGSTKSZ 131072
     * }
     */
    public static int SIGSTKSZ() {
        return SIGSTKSZ;
    }
    private static final int PRIO_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PROCESS 0
     * }
     */
    public static int PRIO_PROCESS() {
        return PRIO_PROCESS;
    }
    private static final int PRIO_PGRP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PGRP 1
     * }
     */
    public static int PRIO_PGRP() {
        return PRIO_PGRP;
    }
    private static final int PRIO_USER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PRIO_USER 2
     * }
     */
    public static int PRIO_USER() {
        return PRIO_USER;
    }
    private static final int PRIO_DARWIN_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_THREAD 3
     * }
     */
    public static int PRIO_DARWIN_THREAD() {
        return PRIO_DARWIN_THREAD;
    }
    private static final int PRIO_DARWIN_PROCESS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_PROCESS 4
     * }
     */
    public static int PRIO_DARWIN_PROCESS() {
        return PRIO_DARWIN_PROCESS;
    }
    private static final int PRIO_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MAX 20
     * }
     */
    public static int PRIO_MAX() {
        return PRIO_MAX;
    }
    private static final int PRIO_DARWIN_BG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_BG 4096
     * }
     */
    public static int PRIO_DARWIN_BG() {
        return PRIO_DARWIN_BG;
    }
    private static final int PRIO_DARWIN_NONUI = (int)4097L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_NONUI 4097
     * }
     */
    public static int PRIO_DARWIN_NONUI() {
        return PRIO_DARWIN_NONUI;
    }
    private static final int RUSAGE_SELF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_SELF 0
     * }
     */
    public static int RUSAGE_SELF() {
        return RUSAGE_SELF;
    }
    private static final int RUSAGE_INFO_V0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V0 0
     * }
     */
    public static int RUSAGE_INFO_V0() {
        return RUSAGE_INFO_V0;
    }
    private static final int RUSAGE_INFO_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V1 1
     * }
     */
    public static int RUSAGE_INFO_V1() {
        return RUSAGE_INFO_V1;
    }
    private static final int RUSAGE_INFO_V2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V2 2
     * }
     */
    public static int RUSAGE_INFO_V2() {
        return RUSAGE_INFO_V2;
    }
    private static final int RUSAGE_INFO_V3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V3 3
     * }
     */
    public static int RUSAGE_INFO_V3() {
        return RUSAGE_INFO_V3;
    }
    private static final int RUSAGE_INFO_V4 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V4 4
     * }
     */
    public static int RUSAGE_INFO_V4() {
        return RUSAGE_INFO_V4;
    }
    private static final int RUSAGE_INFO_V5 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V5 5
     * }
     */
    public static int RUSAGE_INFO_V5() {
        return RUSAGE_INFO_V5;
    }
    private static final int RUSAGE_INFO_V6 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V6 6
     * }
     */
    public static int RUSAGE_INFO_V6() {
        return RUSAGE_INFO_V6;
    }
    private static final int RU_PROC_RUNS_RESLIDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RU_PROC_RUNS_RESLIDE 1
     * }
     */
    public static int RU_PROC_RUNS_RESLIDE() {
        return RU_PROC_RUNS_RESLIDE;
    }
    private static final int RLIMIT_CPU = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU 0
     * }
     */
    public static int RLIMIT_CPU() {
        return RLIMIT_CPU;
    }
    private static final int RLIMIT_FSIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FSIZE 1
     * }
     */
    public static int RLIMIT_FSIZE() {
        return RLIMIT_FSIZE;
    }
    private static final int RLIMIT_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_DATA 2
     * }
     */
    public static int RLIMIT_DATA() {
        return RLIMIT_DATA;
    }
    private static final int RLIMIT_STACK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_STACK 3
     * }
     */
    public static int RLIMIT_STACK() {
        return RLIMIT_STACK;
    }
    private static final int RLIMIT_CORE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CORE 4
     * }
     */
    public static int RLIMIT_CORE() {
        return RLIMIT_CORE;
    }
    private static final int RLIMIT_AS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_AS 5
     * }
     */
    public static int RLIMIT_AS() {
        return RLIMIT_AS;
    }
    private static final int RLIMIT_MEMLOCK = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_MEMLOCK 6
     * }
     */
    public static int RLIMIT_MEMLOCK() {
        return RLIMIT_MEMLOCK;
    }
    private static final int RLIMIT_NPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NPROC 7
     * }
     */
    public static int RLIMIT_NPROC() {
        return RLIMIT_NPROC;
    }
    private static final int RLIMIT_NOFILE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NOFILE 8
     * }
     */
    public static int RLIMIT_NOFILE() {
        return RLIMIT_NOFILE;
    }
    private static final int RLIM_NLIMITS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define RLIM_NLIMITS 9
     * }
     */
    public static int RLIM_NLIMITS() {
        return RLIM_NLIMITS;
    }
    private static final int _RLIMIT_POSIX_FLAG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _RLIMIT_POSIX_FLAG 4096
     * }
     */
    public static int _RLIMIT_POSIX_FLAG() {
        return _RLIMIT_POSIX_FLAG;
    }
    private static final int RLIMIT_WAKEUPS_MONITOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_WAKEUPS_MONITOR 1
     * }
     */
    public static int RLIMIT_WAKEUPS_MONITOR() {
        return RLIMIT_WAKEUPS_MONITOR;
    }
    private static final int RLIMIT_CPU_USAGE_MONITOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU_USAGE_MONITOR 2
     * }
     */
    public static int RLIMIT_CPU_USAGE_MONITOR() {
        return RLIMIT_CPU_USAGE_MONITOR;
    }
    private static final int RLIMIT_THREAD_CPULIMITS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_THREAD_CPULIMITS 3
     * }
     */
    public static int RLIMIT_THREAD_CPULIMITS() {
        return RLIMIT_THREAD_CPULIMITS;
    }
    private static final int RLIMIT_FOOTPRINT_INTERVAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FOOTPRINT_INTERVAL 4
     * }
     */
    public static int RLIMIT_FOOTPRINT_INTERVAL() {
        return RLIMIT_FOOTPRINT_INTERVAL;
    }
    private static final int WAKEMON_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_ENABLE 1
     * }
     */
    public static int WAKEMON_ENABLE() {
        return WAKEMON_ENABLE;
    }
    private static final int WAKEMON_DISABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_DISABLE 2
     * }
     */
    public static int WAKEMON_DISABLE() {
        return WAKEMON_DISABLE;
    }
    private static final int WAKEMON_GET_PARAMS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_GET_PARAMS 4
     * }
     */
    public static int WAKEMON_GET_PARAMS() {
        return WAKEMON_GET_PARAMS;
    }
    private static final int WAKEMON_SET_DEFAULTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_SET_DEFAULTS 8
     * }
     */
    public static int WAKEMON_SET_DEFAULTS() {
        return WAKEMON_SET_DEFAULTS;
    }
    private static final int WAKEMON_MAKE_FATAL = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_MAKE_FATAL 16
     * }
     */
    public static int WAKEMON_MAKE_FATAL() {
        return WAKEMON_MAKE_FATAL;
    }
    private static final int CPUMON_MAKE_FATAL = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define CPUMON_MAKE_FATAL 4096
     * }
     */
    public static int CPUMON_MAKE_FATAL() {
        return CPUMON_MAKE_FATAL;
    }
    private static final int FOOTPRINT_INTERVAL_RESET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FOOTPRINT_INTERVAL_RESET 1
     * }
     */
    public static int FOOTPRINT_INTERVAL_RESET() {
        return FOOTPRINT_INTERVAL_RESET;
    }
    private static final int IOPOL_TYPE_DISK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_DISK 0
     * }
     */
    public static int IOPOL_TYPE_DISK() {
        return IOPOL_TYPE_DISK;
    }
    private static final int IOPOL_TYPE_VFS_ATIME_UPDATES = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ATIME_UPDATES 2
     * }
     */
    public static int IOPOL_TYPE_VFS_ATIME_UPDATES() {
        return IOPOL_TYPE_VFS_ATIME_UPDATES;
    }
    private static final int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES 3
     * }
     */
    public static int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES() {
        return IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES;
    }
    private static final int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME 4
     * }
     */
    public static int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME() {
        return IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME;
    }
    private static final int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_TRIGGER_RESOLVE 5
     * }
     */
    public static int IOPOL_TYPE_VFS_TRIGGER_RESOLVE() {
        return IOPOL_TYPE_VFS_TRIGGER_RESOLVE;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION 6
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION() {
        return IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_PERMISSIONS 7
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS() {
        return IOPOL_TYPE_VFS_IGNORE_PERMISSIONS;
    }
    private static final int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE 8
     * }
     */
    public static int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE() {
        return IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE;
    }
    private static final int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = (int)9L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES 9
     * }
     */
    public static int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES() {
        return IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES;
    }
    private static final int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY 10
     * }
     */
    public static int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY() {
        return IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY;
    }
    private static final int IOPOL_SCOPE_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_PROCESS 0
     * }
     */
    public static int IOPOL_SCOPE_PROCESS() {
        return IOPOL_SCOPE_PROCESS;
    }
    private static final int IOPOL_SCOPE_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_THREAD 1
     * }
     */
    public static int IOPOL_SCOPE_THREAD() {
        return IOPOL_SCOPE_THREAD;
    }
    private static final int IOPOL_SCOPE_DARWIN_BG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_DARWIN_BG 2
     * }
     */
    public static int IOPOL_SCOPE_DARWIN_BG() {
        return IOPOL_SCOPE_DARWIN_BG;
    }
    private static final int IOPOL_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_DEFAULT 0
     * }
     */
    public static int IOPOL_DEFAULT() {
        return IOPOL_DEFAULT;
    }
    private static final int IOPOL_IMPORTANT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_IMPORTANT 1
     * }
     */
    public static int IOPOL_IMPORTANT() {
        return IOPOL_IMPORTANT;
    }
    private static final int IOPOL_PASSIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_PASSIVE 2
     * }
     */
    public static int IOPOL_PASSIVE() {
        return IOPOL_PASSIVE;
    }
    private static final int IOPOL_THROTTLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_THROTTLE 3
     * }
     */
    public static int IOPOL_THROTTLE() {
        return IOPOL_THROTTLE;
    }
    private static final int IOPOL_UTILITY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_UTILITY 4
     * }
     */
    public static int IOPOL_UTILITY() {
        return IOPOL_UTILITY;
    }
    private static final int IOPOL_STANDARD = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_STANDARD 5
     * }
     */
    public static int IOPOL_STANDARD() {
        return IOPOL_STANDARD;
    }
    private static final int IOPOL_ATIME_UPDATES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_DEFAULT 0
     * }
     */
    public static int IOPOL_ATIME_UPDATES_DEFAULT() {
        return IOPOL_ATIME_UPDATES_DEFAULT;
    }
    private static final int IOPOL_ATIME_UPDATES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_OFF 1
     * }
     */
    public static int IOPOL_ATIME_UPDATES_OFF() {
        return IOPOL_ATIME_UPDATES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT 0
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_OFF 1
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_OFF() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_ON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_ON 2
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_ON() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_ON;
    }
    private static final int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT() {
        return IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT;
    }
    private static final int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME 1
     * }
     */
    public static int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME() {
        return IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT() {
        return IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_OFF 1
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_OFF() {
        return IOPOL_VFS_TRIGGER_RESOLVE_OFF;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT() {
        return IOPOL_VFS_CONTENT_PROTECTION_DEFAULT;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_IGNORE 1
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_IGNORE() {
        return IOPOL_VFS_CONTENT_PROTECTION_IGNORE;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_OFF 0
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_OFF() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_OFF;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_ON 1
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_ON() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_ON;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_OFF 0
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_OFF;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_ON 1
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_ON() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_ON;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF 0
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON 1
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON 1
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON 1
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define WCOREFLAG 128
     * }
     */
    public static int WCOREFLAG() {
        return WCOREFLAG;
    }
    private static final int _WSTOPPED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define _WSTOPPED 127
     * }
     */
    public static int _WSTOPPED() {
        return _WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WSTOPPED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 8
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WCONTINUED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 16
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 32
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int WAIT_MYPGRP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WAIT_MYPGRP 0
     * }
     */
    public static int WAIT_MYPGRP() {
        return WAIT_MYPGRP;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int __HAS_FIXED_CHK_PROTOTYPES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAS_FIXED_CHK_PROTOTYPES 1
     * }
     */
    public static int __HAS_FIXED_CHK_PROTOTYPES() {
        return __HAS_FIXED_CHK_PROTOTYPES;
    }
    private static final int F_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define F_OK 0
     * }
     */
    public static int F_OK() {
        return F_OK;
    }
    private static final int ACCESSX_MAX_DESCRIPTORS = (int)100L;
    /**
     * {@snippet lang=c :
     * #define ACCESSX_MAX_DESCRIPTORS 100
     * }
     */
    public static int ACCESSX_MAX_DESCRIPTORS() {
        return ACCESSX_MAX_DESCRIPTORS;
    }
    private static final int _PC_LINK_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _PC_LINK_MAX 1
     * }
     */
    public static int _PC_LINK_MAX() {
        return _PC_LINK_MAX;
    }
    private static final int _PC_MAX_CANON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _PC_MAX_CANON 2
     * }
     */
    public static int _PC_MAX_CANON() {
        return _PC_MAX_CANON;
    }
    private static final int _PC_MAX_INPUT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _PC_MAX_INPUT 3
     * }
     */
    public static int _PC_MAX_INPUT() {
        return _PC_MAX_INPUT;
    }
    private static final int _PC_NAME_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _PC_NAME_MAX 4
     * }
     */
    public static int _PC_NAME_MAX() {
        return _PC_NAME_MAX;
    }
    private static final int _PC_PATH_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _PC_PATH_MAX 5
     * }
     */
    public static int _PC_PATH_MAX() {
        return _PC_PATH_MAX;
    }
    private static final int _PC_PIPE_BUF = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _PC_PIPE_BUF 6
     * }
     */
    public static int _PC_PIPE_BUF() {
        return _PC_PIPE_BUF;
    }
    private static final int _PC_CHOWN_RESTRICTED = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _PC_CHOWN_RESTRICTED 7
     * }
     */
    public static int _PC_CHOWN_RESTRICTED() {
        return _PC_CHOWN_RESTRICTED;
    }
    private static final int _PC_NO_TRUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _PC_NO_TRUNC 8
     * }
     */
    public static int _PC_NO_TRUNC() {
        return _PC_NO_TRUNC;
    }
    private static final int _PC_VDISABLE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _PC_VDISABLE 9
     * }
     */
    public static int _PC_VDISABLE() {
        return _PC_VDISABLE;
    }
    private static final int _PC_NAME_CHARS_MAX = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _PC_NAME_CHARS_MAX 10
     * }
     */
    public static int _PC_NAME_CHARS_MAX() {
        return _PC_NAME_CHARS_MAX;
    }
    private static final int _PC_CASE_SENSITIVE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _PC_CASE_SENSITIVE 11
     * }
     */
    public static int _PC_CASE_SENSITIVE() {
        return _PC_CASE_SENSITIVE;
    }
    private static final int _PC_CASE_PRESERVING = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _PC_CASE_PRESERVING 12
     * }
     */
    public static int _PC_CASE_PRESERVING() {
        return _PC_CASE_PRESERVING;
    }
    private static final int _PC_EXTENDED_SECURITY_NP = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _PC_EXTENDED_SECURITY_NP 13
     * }
     */
    public static int _PC_EXTENDED_SECURITY_NP() {
        return _PC_EXTENDED_SECURITY_NP;
    }
    private static final int _PC_AUTH_OPAQUE_NP = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _PC_AUTH_OPAQUE_NP 14
     * }
     */
    public static int _PC_AUTH_OPAQUE_NP() {
        return _PC_AUTH_OPAQUE_NP;
    }
    private static final int _PC_2_SYMLINKS = (int)15L;
    /**
     * {@snippet lang=c :
     * #define _PC_2_SYMLINKS 15
     * }
     */
    public static int _PC_2_SYMLINKS() {
        return _PC_2_SYMLINKS;
    }
    private static final int _PC_ALLOC_SIZE_MIN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _PC_ALLOC_SIZE_MIN 16
     * }
     */
    public static int _PC_ALLOC_SIZE_MIN() {
        return _PC_ALLOC_SIZE_MIN;
    }
    private static final int _PC_ASYNC_IO = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _PC_ASYNC_IO 17
     * }
     */
    public static int _PC_ASYNC_IO() {
        return _PC_ASYNC_IO;
    }
    private static final int _PC_FILESIZEBITS = (int)18L;
    /**
     * {@snippet lang=c :
     * #define _PC_FILESIZEBITS 18
     * }
     */
    public static int _PC_FILESIZEBITS() {
        return _PC_FILESIZEBITS;
    }
    private static final int _PC_PRIO_IO = (int)19L;
    /**
     * {@snippet lang=c :
     * #define _PC_PRIO_IO 19
     * }
     */
    public static int _PC_PRIO_IO() {
        return _PC_PRIO_IO;
    }
    private static final int _PC_REC_INCR_XFER_SIZE = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_INCR_XFER_SIZE 20
     * }
     */
    public static int _PC_REC_INCR_XFER_SIZE() {
        return _PC_REC_INCR_XFER_SIZE;
    }
    private static final int _PC_REC_MAX_XFER_SIZE = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_MAX_XFER_SIZE 21
     * }
     */
    public static int _PC_REC_MAX_XFER_SIZE() {
        return _PC_REC_MAX_XFER_SIZE;
    }
    private static final int _PC_REC_MIN_XFER_SIZE = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_MIN_XFER_SIZE 22
     * }
     */
    public static int _PC_REC_MIN_XFER_SIZE() {
        return _PC_REC_MIN_XFER_SIZE;
    }
    private static final int _PC_REC_XFER_ALIGN = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_XFER_ALIGN 23
     * }
     */
    public static int _PC_REC_XFER_ALIGN() {
        return _PC_REC_XFER_ALIGN;
    }
    private static final int _PC_SYMLINK_MAX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _PC_SYMLINK_MAX 24
     * }
     */
    public static int _PC_SYMLINK_MAX() {
        return _PC_SYMLINK_MAX;
    }
    private static final int _PC_SYNC_IO = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _PC_SYNC_IO 25
     * }
     */
    public static int _PC_SYNC_IO() {
        return _PC_SYNC_IO;
    }
    private static final int _PC_XATTR_SIZE_BITS = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _PC_XATTR_SIZE_BITS 26
     * }
     */
    public static int _PC_XATTR_SIZE_BITS() {
        return _PC_XATTR_SIZE_BITS;
    }
    private static final int _PC_MIN_HOLE_SIZE = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _PC_MIN_HOLE_SIZE 27
     * }
     */
    public static int _PC_MIN_HOLE_SIZE() {
        return _PC_MIN_HOLE_SIZE;
    }
    private static final int _CS_PATH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CS_PATH 1
     * }
     */
    public static int _CS_PATH() {
        return _CS_PATH;
    }
    private static final int STDIN_FILENO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define STDIN_FILENO 0
     * }
     */
    public static int STDIN_FILENO() {
        return STDIN_FILENO;
    }
    private static final int STDOUT_FILENO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define STDOUT_FILENO 1
     * }
     */
    public static int STDOUT_FILENO() {
        return STDOUT_FILENO;
    }
    private static final int STDERR_FILENO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define STDERR_FILENO 2
     * }
     */
    public static int STDERR_FILENO() {
        return STDERR_FILENO;
    }
    private static final int _XOPEN_VERSION = (int)600L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_VERSION 600
     * }
     */
    public static int _XOPEN_VERSION() {
        return _XOPEN_VERSION;
    }
    private static final int _XOPEN_XCU_VERSION = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_XCU_VERSION 4
     * }
     */
    public static int _XOPEN_XCU_VERSION() {
        return _XOPEN_XCU_VERSION;
    }
    private static final int _SC_ARG_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SC_ARG_MAX 1
     * }
     */
    public static int _SC_ARG_MAX() {
        return _SC_ARG_MAX;
    }
    private static final int _SC_CHILD_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _SC_CHILD_MAX 2
     * }
     */
    public static int _SC_CHILD_MAX() {
        return _SC_CHILD_MAX;
    }
    private static final int _SC_CLK_TCK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _SC_CLK_TCK 3
     * }
     */
    public static int _SC_CLK_TCK() {
        return _SC_CLK_TCK;
    }
    private static final int _SC_NGROUPS_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _SC_NGROUPS_MAX 4
     * }
     */
    public static int _SC_NGROUPS_MAX() {
        return _SC_NGROUPS_MAX;
    }
    private static final int _SC_OPEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _SC_OPEN_MAX 5
     * }
     */
    public static int _SC_OPEN_MAX() {
        return _SC_OPEN_MAX;
    }
    private static final int _SC_JOB_CONTROL = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _SC_JOB_CONTROL 6
     * }
     */
    public static int _SC_JOB_CONTROL() {
        return _SC_JOB_CONTROL;
    }
    private static final int _SC_SAVED_IDS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _SC_SAVED_IDS 7
     * }
     */
    public static int _SC_SAVED_IDS() {
        return _SC_SAVED_IDS;
    }
    private static final int _SC_VERSION = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _SC_VERSION 8
     * }
     */
    public static int _SC_VERSION() {
        return _SC_VERSION;
    }
    private static final int _SC_BC_BASE_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_BASE_MAX 9
     * }
     */
    public static int _SC_BC_BASE_MAX() {
        return _SC_BC_BASE_MAX;
    }
    private static final int _SC_BC_DIM_MAX = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_DIM_MAX 10
     * }
     */
    public static int _SC_BC_DIM_MAX() {
        return _SC_BC_DIM_MAX;
    }
    private static final int _SC_BC_SCALE_MAX = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_SCALE_MAX 11
     * }
     */
    public static int _SC_BC_SCALE_MAX() {
        return _SC_BC_SCALE_MAX;
    }
    private static final int _SC_BC_STRING_MAX = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_STRING_MAX 12
     * }
     */
    public static int _SC_BC_STRING_MAX() {
        return _SC_BC_STRING_MAX;
    }
    private static final int _SC_COLL_WEIGHTS_MAX = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _SC_COLL_WEIGHTS_MAX 13
     * }
     */
    public static int _SC_COLL_WEIGHTS_MAX() {
        return _SC_COLL_WEIGHTS_MAX;
    }
    private static final int _SC_EXPR_NEST_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _SC_EXPR_NEST_MAX 14
     * }
     */
    public static int _SC_EXPR_NEST_MAX() {
        return _SC_EXPR_NEST_MAX;
    }
    private static final int _SC_LINE_MAX = (int)15L;
    /**
     * {@snippet lang=c :
     * #define _SC_LINE_MAX 15
     * }
     */
    public static int _SC_LINE_MAX() {
        return _SC_LINE_MAX;
    }
    private static final int _SC_RE_DUP_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _SC_RE_DUP_MAX 16
     * }
     */
    public static int _SC_RE_DUP_MAX() {
        return _SC_RE_DUP_MAX;
    }
    private static final int _SC_2_VERSION = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_VERSION 17
     * }
     */
    public static int _SC_2_VERSION() {
        return _SC_2_VERSION;
    }
    private static final int _SC_2_C_BIND = (int)18L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_C_BIND 18
     * }
     */
    public static int _SC_2_C_BIND() {
        return _SC_2_C_BIND;
    }
    private static final int _SC_2_C_DEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_C_DEV 19
     * }
     */
    public static int _SC_2_C_DEV() {
        return _SC_2_C_DEV;
    }
    private static final int _SC_2_CHAR_TERM = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_CHAR_TERM 20
     * }
     */
    public static int _SC_2_CHAR_TERM() {
        return _SC_2_CHAR_TERM;
    }
    private static final int _SC_2_FORT_DEV = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_FORT_DEV 21
     * }
     */
    public static int _SC_2_FORT_DEV() {
        return _SC_2_FORT_DEV;
    }
    private static final int _SC_2_FORT_RUN = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_FORT_RUN 22
     * }
     */
    public static int _SC_2_FORT_RUN() {
        return _SC_2_FORT_RUN;
    }
    private static final int _SC_2_LOCALEDEF = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_LOCALEDEF 23
     * }
     */
    public static int _SC_2_LOCALEDEF() {
        return _SC_2_LOCALEDEF;
    }
    private static final int _SC_2_SW_DEV = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_SW_DEV 24
     * }
     */
    public static int _SC_2_SW_DEV() {
        return _SC_2_SW_DEV;
    }
    private static final int _SC_2_UPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_UPE 25
     * }
     */
    public static int _SC_2_UPE() {
        return _SC_2_UPE;
    }
    private static final int _SC_STREAM_MAX = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _SC_STREAM_MAX 26
     * }
     */
    public static int _SC_STREAM_MAX() {
        return _SC_STREAM_MAX;
    }
    private static final int _SC_TZNAME_MAX = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _SC_TZNAME_MAX 27
     * }
     */
    public static int _SC_TZNAME_MAX() {
        return _SC_TZNAME_MAX;
    }
    private static final int _SC_ASYNCHRONOUS_IO = (int)28L;
    /**
     * {@snippet lang=c :
     * #define _SC_ASYNCHRONOUS_IO 28
     * }
     */
    public static int _SC_ASYNCHRONOUS_IO() {
        return _SC_ASYNCHRONOUS_IO;
    }
    private static final int _SC_PAGESIZE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define _SC_PAGESIZE 29
     * }
     */
    public static int _SC_PAGESIZE() {
        return _SC_PAGESIZE;
    }
    private static final int _SC_MEMLOCK = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMLOCK 30
     * }
     */
    public static int _SC_MEMLOCK() {
        return _SC_MEMLOCK;
    }
    private static final int _SC_MEMLOCK_RANGE = (int)31L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMLOCK_RANGE 31
     * }
     */
    public static int _SC_MEMLOCK_RANGE() {
        return _SC_MEMLOCK_RANGE;
    }
    private static final int _SC_MEMORY_PROTECTION = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMORY_PROTECTION 32
     * }
     */
    public static int _SC_MEMORY_PROTECTION() {
        return _SC_MEMORY_PROTECTION;
    }
    private static final int _SC_MESSAGE_PASSING = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _SC_MESSAGE_PASSING 33
     * }
     */
    public static int _SC_MESSAGE_PASSING() {
        return _SC_MESSAGE_PASSING;
    }
    private static final int _SC_PRIORITIZED_IO = (int)34L;
    /**
     * {@snippet lang=c :
     * #define _SC_PRIORITIZED_IO 34
     * }
     */
    public static int _SC_PRIORITIZED_IO() {
        return _SC_PRIORITIZED_IO;
    }
    private static final int _SC_PRIORITY_SCHEDULING = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _SC_PRIORITY_SCHEDULING 35
     * }
     */
    public static int _SC_PRIORITY_SCHEDULING() {
        return _SC_PRIORITY_SCHEDULING;
    }
    private static final int _SC_REALTIME_SIGNALS = (int)36L;
    /**
     * {@snippet lang=c :
     * #define _SC_REALTIME_SIGNALS 36
     * }
     */
    public static int _SC_REALTIME_SIGNALS() {
        return _SC_REALTIME_SIGNALS;
    }
    private static final int _SC_SEMAPHORES = (int)37L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEMAPHORES 37
     * }
     */
    public static int _SC_SEMAPHORES() {
        return _SC_SEMAPHORES;
    }
    private static final int _SC_FSYNC = (int)38L;
    /**
     * {@snippet lang=c :
     * #define _SC_FSYNC 38
     * }
     */
    public static int _SC_FSYNC() {
        return _SC_FSYNC;
    }
    private static final int _SC_SHARED_MEMORY_OBJECTS = (int)39L;
    /**
     * {@snippet lang=c :
     * #define _SC_SHARED_MEMORY_OBJECTS 39
     * }
     */
    public static int _SC_SHARED_MEMORY_OBJECTS() {
        return _SC_SHARED_MEMORY_OBJECTS;
    }
    private static final int _SC_SYNCHRONIZED_IO = (int)40L;
    /**
     * {@snippet lang=c :
     * #define _SC_SYNCHRONIZED_IO 40
     * }
     */
    public static int _SC_SYNCHRONIZED_IO() {
        return _SC_SYNCHRONIZED_IO;
    }
    private static final int _SC_TIMERS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMERS 41
     * }
     */
    public static int _SC_TIMERS() {
        return _SC_TIMERS;
    }
    private static final int _SC_AIO_LISTIO_MAX = (int)42L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_LISTIO_MAX 42
     * }
     */
    public static int _SC_AIO_LISTIO_MAX() {
        return _SC_AIO_LISTIO_MAX;
    }
    private static final int _SC_AIO_MAX = (int)43L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_MAX 43
     * }
     */
    public static int _SC_AIO_MAX() {
        return _SC_AIO_MAX;
    }
    private static final int _SC_AIO_PRIO_DELTA_MAX = (int)44L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_PRIO_DELTA_MAX 44
     * }
     */
    public static int _SC_AIO_PRIO_DELTA_MAX() {
        return _SC_AIO_PRIO_DELTA_MAX;
    }
    private static final int _SC_DELAYTIMER_MAX = (int)45L;
    /**
     * {@snippet lang=c :
     * #define _SC_DELAYTIMER_MAX 45
     * }
     */
    public static int _SC_DELAYTIMER_MAX() {
        return _SC_DELAYTIMER_MAX;
    }
    private static final int _SC_MQ_OPEN_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define _SC_MQ_OPEN_MAX 46
     * }
     */
    public static int _SC_MQ_OPEN_MAX() {
        return _SC_MQ_OPEN_MAX;
    }
    private static final int _SC_MAPPED_FILES = (int)47L;
    /**
     * {@snippet lang=c :
     * #define _SC_MAPPED_FILES 47
     * }
     */
    public static int _SC_MAPPED_FILES() {
        return _SC_MAPPED_FILES;
    }
    private static final int _SC_RTSIG_MAX = (int)48L;
    /**
     * {@snippet lang=c :
     * #define _SC_RTSIG_MAX 48
     * }
     */
    public static int _SC_RTSIG_MAX() {
        return _SC_RTSIG_MAX;
    }
    private static final int _SC_SEM_NSEMS_MAX = (int)49L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEM_NSEMS_MAX 49
     * }
     */
    public static int _SC_SEM_NSEMS_MAX() {
        return _SC_SEM_NSEMS_MAX;
    }
    private static final int _SC_SEM_VALUE_MAX = (int)50L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEM_VALUE_MAX 50
     * }
     */
    public static int _SC_SEM_VALUE_MAX() {
        return _SC_SEM_VALUE_MAX;
    }
    private static final int _SC_SIGQUEUE_MAX = (int)51L;
    /**
     * {@snippet lang=c :
     * #define _SC_SIGQUEUE_MAX 51
     * }
     */
    public static int _SC_SIGQUEUE_MAX() {
        return _SC_SIGQUEUE_MAX;
    }
    private static final int _SC_TIMER_MAX = (int)52L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMER_MAX 52
     * }
     */
    public static int _SC_TIMER_MAX() {
        return _SC_TIMER_MAX;
    }
    private static final int _SC_NPROCESSORS_CONF = (int)57L;
    /**
     * {@snippet lang=c :
     * #define _SC_NPROCESSORS_CONF 57
     * }
     */
    public static int _SC_NPROCESSORS_CONF() {
        return _SC_NPROCESSORS_CONF;
    }
    private static final int _SC_NPROCESSORS_ONLN = (int)58L;
    /**
     * {@snippet lang=c :
     * #define _SC_NPROCESSORS_ONLN 58
     * }
     */
    public static int _SC_NPROCESSORS_ONLN() {
        return _SC_NPROCESSORS_ONLN;
    }
    private static final int _SC_2_PBS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS 59
     * }
     */
    public static int _SC_2_PBS() {
        return _SC_2_PBS;
    }
    private static final int _SC_2_PBS_ACCOUNTING = (int)60L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_ACCOUNTING 60
     * }
     */
    public static int _SC_2_PBS_ACCOUNTING() {
        return _SC_2_PBS_ACCOUNTING;
    }
    private static final int _SC_2_PBS_CHECKPOINT = (int)61L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_CHECKPOINT 61
     * }
     */
    public static int _SC_2_PBS_CHECKPOINT() {
        return _SC_2_PBS_CHECKPOINT;
    }
    private static final int _SC_2_PBS_LOCATE = (int)62L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_LOCATE 62
     * }
     */
    public static int _SC_2_PBS_LOCATE() {
        return _SC_2_PBS_LOCATE;
    }
    private static final int _SC_2_PBS_MESSAGE = (int)63L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_MESSAGE 63
     * }
     */
    public static int _SC_2_PBS_MESSAGE() {
        return _SC_2_PBS_MESSAGE;
    }
    private static final int _SC_2_PBS_TRACK = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_TRACK 64
     * }
     */
    public static int _SC_2_PBS_TRACK() {
        return _SC_2_PBS_TRACK;
    }
    private static final int _SC_ADVISORY_INFO = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _SC_ADVISORY_INFO 65
     * }
     */
    public static int _SC_ADVISORY_INFO() {
        return _SC_ADVISORY_INFO;
    }
    private static final int _SC_BARRIERS = (int)66L;
    /**
     * {@snippet lang=c :
     * #define _SC_BARRIERS 66
     * }
     */
    public static int _SC_BARRIERS() {
        return _SC_BARRIERS;
    }
    private static final int _SC_CLOCK_SELECTION = (int)67L;
    /**
     * {@snippet lang=c :
     * #define _SC_CLOCK_SELECTION 67
     * }
     */
    public static int _SC_CLOCK_SELECTION() {
        return _SC_CLOCK_SELECTION;
    }
    private static final int _SC_CPUTIME = (int)68L;
    /**
     * {@snippet lang=c :
     * #define _SC_CPUTIME 68
     * }
     */
    public static int _SC_CPUTIME() {
        return _SC_CPUTIME;
    }
    private static final int _SC_FILE_LOCKING = (int)69L;
    /**
     * {@snippet lang=c :
     * #define _SC_FILE_LOCKING 69
     * }
     */
    public static int _SC_FILE_LOCKING() {
        return _SC_FILE_LOCKING;
    }
    private static final int _SC_GETGR_R_SIZE_MAX = (int)70L;
    /**
     * {@snippet lang=c :
     * #define _SC_GETGR_R_SIZE_MAX 70
     * }
     */
    public static int _SC_GETGR_R_SIZE_MAX() {
        return _SC_GETGR_R_SIZE_MAX;
    }
    private static final int _SC_GETPW_R_SIZE_MAX = (int)71L;
    /**
     * {@snippet lang=c :
     * #define _SC_GETPW_R_SIZE_MAX 71
     * }
     */
    public static int _SC_GETPW_R_SIZE_MAX() {
        return _SC_GETPW_R_SIZE_MAX;
    }
    private static final int _SC_HOST_NAME_MAX = (int)72L;
    /**
     * {@snippet lang=c :
     * #define _SC_HOST_NAME_MAX 72
     * }
     */
    public static int _SC_HOST_NAME_MAX() {
        return _SC_HOST_NAME_MAX;
    }
    private static final int _SC_LOGIN_NAME_MAX = (int)73L;
    /**
     * {@snippet lang=c :
     * #define _SC_LOGIN_NAME_MAX 73
     * }
     */
    public static int _SC_LOGIN_NAME_MAX() {
        return _SC_LOGIN_NAME_MAX;
    }
    private static final int _SC_MONOTONIC_CLOCK = (int)74L;
    /**
     * {@snippet lang=c :
     * #define _SC_MONOTONIC_CLOCK 74
     * }
     */
    public static int _SC_MONOTONIC_CLOCK() {
        return _SC_MONOTONIC_CLOCK;
    }
    private static final int _SC_MQ_PRIO_MAX = (int)75L;
    /**
     * {@snippet lang=c :
     * #define _SC_MQ_PRIO_MAX 75
     * }
     */
    public static int _SC_MQ_PRIO_MAX() {
        return _SC_MQ_PRIO_MAX;
    }
    private static final int _SC_READER_WRITER_LOCKS = (int)76L;
    /**
     * {@snippet lang=c :
     * #define _SC_READER_WRITER_LOCKS 76
     * }
     */
    public static int _SC_READER_WRITER_LOCKS() {
        return _SC_READER_WRITER_LOCKS;
    }
    private static final int _SC_REGEXP = (int)77L;
    /**
     * {@snippet lang=c :
     * #define _SC_REGEXP 77
     * }
     */
    public static int _SC_REGEXP() {
        return _SC_REGEXP;
    }
    private static final int _SC_SHELL = (int)78L;
    /**
     * {@snippet lang=c :
     * #define _SC_SHELL 78
     * }
     */
    public static int _SC_SHELL() {
        return _SC_SHELL;
    }
    private static final int _SC_SPAWN = (int)79L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPAWN 79
     * }
     */
    public static int _SC_SPAWN() {
        return _SC_SPAWN;
    }
    private static final int _SC_SPIN_LOCKS = (int)80L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPIN_LOCKS 80
     * }
     */
    public static int _SC_SPIN_LOCKS() {
        return _SC_SPIN_LOCKS;
    }
    private static final int _SC_SPORADIC_SERVER = (int)81L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPORADIC_SERVER 81
     * }
     */
    public static int _SC_SPORADIC_SERVER() {
        return _SC_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_ATTR_STACKADDR = (int)82L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_ATTR_STACKADDR 82
     * }
     */
    public static int _SC_THREAD_ATTR_STACKADDR() {
        return _SC_THREAD_ATTR_STACKADDR;
    }
    private static final int _SC_THREAD_ATTR_STACKSIZE = (int)83L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_ATTR_STACKSIZE 83
     * }
     */
    public static int _SC_THREAD_ATTR_STACKSIZE() {
        return _SC_THREAD_ATTR_STACKSIZE;
    }
    private static final int _SC_THREAD_CPUTIME = (int)84L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_CPUTIME 84
     * }
     */
    public static int _SC_THREAD_CPUTIME() {
        return _SC_THREAD_CPUTIME;
    }
    private static final int _SC_THREAD_DESTRUCTOR_ITERATIONS = (int)85L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_DESTRUCTOR_ITERATIONS 85
     * }
     */
    public static int _SC_THREAD_DESTRUCTOR_ITERATIONS() {
        return _SC_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _SC_THREAD_KEYS_MAX = (int)86L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_KEYS_MAX 86
     * }
     */
    public static int _SC_THREAD_KEYS_MAX() {
        return _SC_THREAD_KEYS_MAX;
    }
    private static final int _SC_THREAD_PRIO_INHERIT = (int)87L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIO_INHERIT 87
     * }
     */
    public static int _SC_THREAD_PRIO_INHERIT() {
        return _SC_THREAD_PRIO_INHERIT;
    }
    private static final int _SC_THREAD_PRIO_PROTECT = (int)88L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIO_PROTECT 88
     * }
     */
    public static int _SC_THREAD_PRIO_PROTECT() {
        return _SC_THREAD_PRIO_PROTECT;
    }
    private static final int _SC_THREAD_PRIORITY_SCHEDULING = (int)89L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIORITY_SCHEDULING 89
     * }
     */
    public static int _SC_THREAD_PRIORITY_SCHEDULING() {
        return _SC_THREAD_PRIORITY_SCHEDULING;
    }
    private static final int _SC_THREAD_PROCESS_SHARED = (int)90L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PROCESS_SHARED 90
     * }
     */
    public static int _SC_THREAD_PROCESS_SHARED() {
        return _SC_THREAD_PROCESS_SHARED;
    }
    private static final int _SC_THREAD_SAFE_FUNCTIONS = (int)91L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_SAFE_FUNCTIONS 91
     * }
     */
    public static int _SC_THREAD_SAFE_FUNCTIONS() {
        return _SC_THREAD_SAFE_FUNCTIONS;
    }
    private static final int _SC_THREAD_SPORADIC_SERVER = (int)92L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_SPORADIC_SERVER 92
     * }
     */
    public static int _SC_THREAD_SPORADIC_SERVER() {
        return _SC_THREAD_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_STACK_MIN = (int)93L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_STACK_MIN 93
     * }
     */
    public static int _SC_THREAD_STACK_MIN() {
        return _SC_THREAD_STACK_MIN;
    }
    private static final int _SC_THREAD_THREADS_MAX = (int)94L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_THREADS_MAX 94
     * }
     */
    public static int _SC_THREAD_THREADS_MAX() {
        return _SC_THREAD_THREADS_MAX;
    }
    private static final int _SC_TIMEOUTS = (int)95L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMEOUTS 95
     * }
     */
    public static int _SC_TIMEOUTS() {
        return _SC_TIMEOUTS;
    }
    private static final int _SC_THREADS = (int)96L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREADS 96
     * }
     */
    public static int _SC_THREADS() {
        return _SC_THREADS;
    }
    private static final int _SC_TRACE = (int)97L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE 97
     * }
     */
    public static int _SC_TRACE() {
        return _SC_TRACE;
    }
    private static final int _SC_TRACE_EVENT_FILTER = (int)98L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_EVENT_FILTER 98
     * }
     */
    public static int _SC_TRACE_EVENT_FILTER() {
        return _SC_TRACE_EVENT_FILTER;
    }
    private static final int _SC_TRACE_INHERIT = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_INHERIT 99
     * }
     */
    public static int _SC_TRACE_INHERIT() {
        return _SC_TRACE_INHERIT;
    }
    private static final int _SC_TRACE_LOG = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_LOG 100
     * }
     */
    public static int _SC_TRACE_LOG() {
        return _SC_TRACE_LOG;
    }
    private static final int _SC_TTY_NAME_MAX = (int)101L;
    /**
     * {@snippet lang=c :
     * #define _SC_TTY_NAME_MAX 101
     * }
     */
    public static int _SC_TTY_NAME_MAX() {
        return _SC_TTY_NAME_MAX;
    }
    private static final int _SC_TYPED_MEMORY_OBJECTS = (int)102L;
    /**
     * {@snippet lang=c :
     * #define _SC_TYPED_MEMORY_OBJECTS 102
     * }
     */
    public static int _SC_TYPED_MEMORY_OBJECTS() {
        return _SC_TYPED_MEMORY_OBJECTS;
    }
    private static final int _SC_V6_ILP32_OFF32 = (int)103L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_ILP32_OFF32 103
     * }
     */
    public static int _SC_V6_ILP32_OFF32() {
        return _SC_V6_ILP32_OFF32;
    }
    private static final int _SC_V6_ILP32_OFFBIG = (int)104L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_ILP32_OFFBIG 104
     * }
     */
    public static int _SC_V6_ILP32_OFFBIG() {
        return _SC_V6_ILP32_OFFBIG;
    }
    private static final int _SC_V6_LP64_OFF64 = (int)105L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_LP64_OFF64 105
     * }
     */
    public static int _SC_V6_LP64_OFF64() {
        return _SC_V6_LP64_OFF64;
    }
    private static final int _SC_V6_LPBIG_OFFBIG = (int)106L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_LPBIG_OFFBIG 106
     * }
     */
    public static int _SC_V6_LPBIG_OFFBIG() {
        return _SC_V6_LPBIG_OFFBIG;
    }
    private static final int _SC_IPV6 = (int)118L;
    /**
     * {@snippet lang=c :
     * #define _SC_IPV6 118
     * }
     */
    public static int _SC_IPV6() {
        return _SC_IPV6;
    }
    private static final int _SC_RAW_SOCKETS = (int)119L;
    /**
     * {@snippet lang=c :
     * #define _SC_RAW_SOCKETS 119
     * }
     */
    public static int _SC_RAW_SOCKETS() {
        return _SC_RAW_SOCKETS;
    }
    private static final int _SC_SYMLOOP_MAX = (int)120L;
    /**
     * {@snippet lang=c :
     * #define _SC_SYMLOOP_MAX 120
     * }
     */
    public static int _SC_SYMLOOP_MAX() {
        return _SC_SYMLOOP_MAX;
    }
    private static final int _SC_ATEXIT_MAX = (int)107L;
    /**
     * {@snippet lang=c :
     * #define _SC_ATEXIT_MAX 107
     * }
     */
    public static int _SC_ATEXIT_MAX() {
        return _SC_ATEXIT_MAX;
    }
    private static final int _SC_IOV_MAX = (int)56L;
    /**
     * {@snippet lang=c :
     * #define _SC_IOV_MAX 56
     * }
     */
    public static int _SC_IOV_MAX() {
        return _SC_IOV_MAX;
    }
    private static final int _SC_XOPEN_CRYPT = (int)108L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_CRYPT 108
     * }
     */
    public static int _SC_XOPEN_CRYPT() {
        return _SC_XOPEN_CRYPT;
    }
    private static final int _SC_XOPEN_ENH_I18N = (int)109L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_ENH_I18N 109
     * }
     */
    public static int _SC_XOPEN_ENH_I18N() {
        return _SC_XOPEN_ENH_I18N;
    }
    private static final int _SC_XOPEN_LEGACY = (int)110L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_LEGACY 110
     * }
     */
    public static int _SC_XOPEN_LEGACY() {
        return _SC_XOPEN_LEGACY;
    }
    private static final int _SC_XOPEN_REALTIME = (int)111L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_REALTIME 111
     * }
     */
    public static int _SC_XOPEN_REALTIME() {
        return _SC_XOPEN_REALTIME;
    }
    private static final int _SC_XOPEN_REALTIME_THREADS = (int)112L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_REALTIME_THREADS 112
     * }
     */
    public static int _SC_XOPEN_REALTIME_THREADS() {
        return _SC_XOPEN_REALTIME_THREADS;
    }
    private static final int _SC_XOPEN_SHM = (int)113L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_SHM 113
     * }
     */
    public static int _SC_XOPEN_SHM() {
        return _SC_XOPEN_SHM;
    }
    private static final int _SC_XOPEN_STREAMS = (int)114L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_STREAMS 114
     * }
     */
    public static int _SC_XOPEN_STREAMS() {
        return _SC_XOPEN_STREAMS;
    }
    private static final int _SC_XOPEN_UNIX = (int)115L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_UNIX 115
     * }
     */
    public static int _SC_XOPEN_UNIX() {
        return _SC_XOPEN_UNIX;
    }
    private static final int _SC_XOPEN_VERSION = (int)116L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_VERSION 116
     * }
     */
    public static int _SC_XOPEN_VERSION() {
        return _SC_XOPEN_VERSION;
    }
    private static final int _SC_XOPEN_XCU_VERSION = (int)121L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_XCU_VERSION 121
     * }
     */
    public static int _SC_XOPEN_XCU_VERSION() {
        return _SC_XOPEN_XCU_VERSION;
    }
    private static final int _SC_XBS5_ILP32_OFF32 = (int)122L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_ILP32_OFF32 122
     * }
     */
    public static int _SC_XBS5_ILP32_OFF32() {
        return _SC_XBS5_ILP32_OFF32;
    }
    private static final int _SC_XBS5_ILP32_OFFBIG = (int)123L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_ILP32_OFFBIG 123
     * }
     */
    public static int _SC_XBS5_ILP32_OFFBIG() {
        return _SC_XBS5_ILP32_OFFBIG;
    }
    private static final int _SC_XBS5_LP64_OFF64 = (int)124L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_LP64_OFF64 124
     * }
     */
    public static int _SC_XBS5_LP64_OFF64() {
        return _SC_XBS5_LP64_OFF64;
    }
    private static final int _SC_XBS5_LPBIG_OFFBIG = (int)125L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_LPBIG_OFFBIG 125
     * }
     */
    public static int _SC_XBS5_LPBIG_OFFBIG() {
        return _SC_XBS5_LPBIG_OFFBIG;
    }
    private static final int _SC_SS_REPL_MAX = (int)126L;
    /**
     * {@snippet lang=c :
     * #define _SC_SS_REPL_MAX 126
     * }
     */
    public static int _SC_SS_REPL_MAX() {
        return _SC_SS_REPL_MAX;
    }
    private static final int _SC_TRACE_EVENT_NAME_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_EVENT_NAME_MAX 127
     * }
     */
    public static int _SC_TRACE_EVENT_NAME_MAX() {
        return _SC_TRACE_EVENT_NAME_MAX;
    }
    private static final int _SC_TRACE_NAME_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_NAME_MAX 128
     * }
     */
    public static int _SC_TRACE_NAME_MAX() {
        return _SC_TRACE_NAME_MAX;
    }
    private static final int _SC_TRACE_SYS_MAX = (int)129L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_SYS_MAX 129
     * }
     */
    public static int _SC_TRACE_SYS_MAX() {
        return _SC_TRACE_SYS_MAX;
    }
    private static final int _SC_TRACE_USER_EVENT_MAX = (int)130L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_USER_EVENT_MAX 130
     * }
     */
    public static int _SC_TRACE_USER_EVENT_MAX() {
        return _SC_TRACE_USER_EVENT_MAX;
    }
    private static final int _SC_PASS_MAX = (int)131L;
    /**
     * {@snippet lang=c :
     * #define _SC_PASS_MAX 131
     * }
     */
    public static int _SC_PASS_MAX() {
        return _SC_PASS_MAX;
    }
    private static final int _SC_PHYS_PAGES = (int)200L;
    /**
     * {@snippet lang=c :
     * #define _SC_PHYS_PAGES 200
     * }
     */
    public static int _SC_PHYS_PAGES() {
        return _SC_PHYS_PAGES;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_CFLAGS 2
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS 3
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LIBS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_LIBS 4
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LIBS() {
        return _CS_POSIX_V6_ILP32_OFF32_LIBS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS 5
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS 6
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_LIBS 7
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LIBS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_CFLAGS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_CFLAGS 8
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_CFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_LDFLAGS 9
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LDFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LIBS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_LIBS 10
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LIBS() {
        return _CS_POSIX_V6_LP64_OFF64_LIBS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS 11
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS 12
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS 13
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS 14
     * }
     */
    public static int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_CFLAGS = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_CFLAGS 20
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_CFLAGS() {
        return _CS_XBS5_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LDFLAGS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LDFLAGS 21
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LDFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LIBS = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LIBS 22
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LIBS() {
        return _CS_XBS5_ILP32_OFF32_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LINTFLAGS = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LINTFLAGS 23
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_CFLAGS = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_CFLAGS 24
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_CFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LDFLAGS 25
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LDFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LIBS = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LIBS 26
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LIBS() {
        return _CS_XBS5_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS 27
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_CFLAGS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_CFLAGS 28
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_CFLAGS() {
        return _CS_XBS5_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LDFLAGS = (int)29L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LDFLAGS 29
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LDFLAGS() {
        return _CS_XBS5_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LIBS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LIBS 30
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LIBS() {
        return _CS_XBS5_LP64_OFF64_LIBS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LINTFLAGS = (int)31L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LINTFLAGS 31
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LINTFLAGS() {
        return _CS_XBS5_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_CFLAGS 32
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_CFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS 33
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LIBS = (int)34L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LIBS 34
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LIBS() {
        return _CS_XBS5_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS 35
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_DARWIN_USER_DIR = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_DIR 65536
     * }
     */
    public static int _CS_DARWIN_USER_DIR() {
        return _CS_DARWIN_USER_DIR;
    }
    private static final int _CS_DARWIN_USER_TEMP_DIR = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_TEMP_DIR 65537
     * }
     */
    public static int _CS_DARWIN_USER_TEMP_DIR() {
        return _CS_DARWIN_USER_TEMP_DIR;
    }
    private static final int _CS_DARWIN_USER_CACHE_DIR = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_CACHE_DIR 65538
     * }
     */
    public static int _CS_DARWIN_USER_CACHE_DIR() {
        return _CS_DARWIN_USER_CACHE_DIR;
    }
    private static final int F_ULOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define F_ULOCK 0
     * }
     */
    public static int F_ULOCK() {
        return F_ULOCK;
    }
    private static final int F_LOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define F_LOCK 1
     * }
     */
    public static int F_LOCK() {
        return F_LOCK;
    }
    private static final int F_TLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define F_TLOCK 2
     * }
     */
    public static int F_TLOCK() {
        return F_TLOCK;
    }
    private static final int F_TEST = (int)3L;
    /**
     * {@snippet lang=c :
     * #define F_TEST 3
     * }
     */
    public static int F_TEST() {
        return F_TEST;
    }
    private static final int SYNC_VOLUME_FULLSYNC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SYNC_VOLUME_FULLSYNC 1
     * }
     */
    public static int SYNC_VOLUME_FULLSYNC() {
        return SYNC_VOLUME_FULLSYNC;
    }
    private static final int SYNC_VOLUME_WAIT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SYNC_VOLUME_WAIT 2
     * }
     */
    public static int SYNC_VOLUME_WAIT() {
        return SYNC_VOLUME_WAIT;
    }
    private static final int HAVE_LONG_LONG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_LONG_LONG 1
     * }
     */
    public static int HAVE_LONG_LONG() {
        return HAVE_LONG_LONG;
    }
    private static final int PYLONG_BITS_IN_DIGIT = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PYLONG_BITS_IN_DIGIT 30
     * }
     */
    public static int PYLONG_BITS_IN_DIGIT() {
        return PYLONG_BITS_IN_DIGIT;
    }
    private static final int PY_BIG_ENDIAN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PY_BIG_ENDIAN 0
     * }
     */
    public static int PY_BIG_ENDIAN() {
        return PY_BIG_ENDIAN;
    }
    private static final int PY_LITTLE_ENDIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PY_LITTLE_ENDIAN 1
     * }
     */
    public static int PY_LITTLE_ENDIAN() {
        return PY_LITTLE_ENDIAN;
    }
    private static final int Py_CAN_START_THREADS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_CAN_START_THREADS 1
     * }
     */
    public static int Py_CAN_START_THREADS() {
        return Py_CAN_START_THREADS;
    }
    private static final int PyBUF_MAX_NDIM = (int)64L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_MAX_NDIM 64
     * }
     */
    public static int PyBUF_MAX_NDIM() {
        return PyBUF_MAX_NDIM;
    }
    private static final int PyBUF_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_SIMPLE 0
     * }
     */
    public static int PyBUF_SIMPLE() {
        return PyBUF_SIMPLE;
    }
    private static final int PyBUF_WRITABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_WRITABLE 1
     * }
     */
    public static int PyBUF_WRITABLE() {
        return PyBUF_WRITABLE;
    }
    private static final int PyBUF_FORMAT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_FORMAT 4
     * }
     */
    public static int PyBUF_FORMAT() {
        return PyBUF_FORMAT;
    }
    private static final int PyBUF_ND = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_ND 8
     * }
     */
    public static int PyBUF_ND() {
        return PyBUF_ND;
    }
    private static final int PyBUF_READ = (int)256L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_READ 256
     * }
     */
    public static int PyBUF_READ() {
        return PyBUF_READ;
    }
    private static final int PyBUF_WRITE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_WRITE 512
     * }
     */
    public static int PyBUF_WRITE() {
        return PyBUF_WRITE;
    }
    private static final int _Py_USE_GCC_BUILTIN_ATOMICS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _Py_USE_GCC_BUILTIN_ATOMICS 1
     * }
     */
    public static int _Py_USE_GCC_BUILTIN_ATOMICS() {
        return _Py_USE_GCC_BUILTIN_ATOMICS;
    }
    private static final int _Py_UNLOCKED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _Py_UNLOCKED 0
     * }
     */
    public static int _Py_UNLOCKED() {
        return _Py_UNLOCKED;
    }
    private static final int _Py_LOCKED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _Py_LOCKED 1
     * }
     */
    public static int _Py_LOCKED() {
        return _Py_LOCKED;
    }
    private static final int Py_PRINT_RAW = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_PRINT_RAW 1
     * }
     */
    public static int Py_PRINT_RAW() {
        return Py_PRINT_RAW;
    }
    private static final int Py_TPFLAGS_HAVE_STACKLESS_EXTENSION = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
     * }
     */
    public static int Py_TPFLAGS_HAVE_STACKLESS_EXTENSION() {
        return Py_TPFLAGS_HAVE_STACKLESS_EXTENSION;
    }
    private static final int Py_CONSTANT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_NONE 0
     * }
     */
    public static int Py_CONSTANT_NONE() {
        return Py_CONSTANT_NONE;
    }
    private static final int Py_CONSTANT_FALSE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_FALSE 1
     * }
     */
    public static int Py_CONSTANT_FALSE() {
        return Py_CONSTANT_FALSE;
    }
    private static final int Py_CONSTANT_TRUE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_TRUE 2
     * }
     */
    public static int Py_CONSTANT_TRUE() {
        return Py_CONSTANT_TRUE;
    }
    private static final int Py_CONSTANT_ELLIPSIS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_ELLIPSIS 3
     * }
     */
    public static int Py_CONSTANT_ELLIPSIS() {
        return Py_CONSTANT_ELLIPSIS;
    }
    private static final int Py_CONSTANT_NOT_IMPLEMENTED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_NOT_IMPLEMENTED 4
     * }
     */
    public static int Py_CONSTANT_NOT_IMPLEMENTED() {
        return Py_CONSTANT_NOT_IMPLEMENTED;
    }
    private static final int Py_CONSTANT_ZERO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_ZERO 5
     * }
     */
    public static int Py_CONSTANT_ZERO() {
        return Py_CONSTANT_ZERO;
    }
    private static final int Py_CONSTANT_ONE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_ONE 6
     * }
     */
    public static int Py_CONSTANT_ONE() {
        return Py_CONSTANT_ONE;
    }
    private static final int Py_CONSTANT_EMPTY_STR = (int)7L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_EMPTY_STR 7
     * }
     */
    public static int Py_CONSTANT_EMPTY_STR() {
        return Py_CONSTANT_EMPTY_STR;
    }
    private static final int Py_CONSTANT_EMPTY_BYTES = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_EMPTY_BYTES 8
     * }
     */
    public static int Py_CONSTANT_EMPTY_BYTES() {
        return Py_CONSTANT_EMPTY_BYTES;
    }
    private static final int Py_CONSTANT_EMPTY_TUPLE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define Py_CONSTANT_EMPTY_TUPLE 9
     * }
     */
    public static int Py_CONSTANT_EMPTY_TUPLE() {
        return Py_CONSTANT_EMPTY_TUPLE;
    }
    private static final int Py_LT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_LT 0
     * }
     */
    public static int Py_LT() {
        return Py_LT;
    }
    private static final int Py_LE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_LE 1
     * }
     */
    public static int Py_LE() {
        return Py_LE;
    }
    private static final int Py_EQ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_EQ 2
     * }
     */
    public static int Py_EQ() {
        return Py_EQ;
    }
    private static final int Py_NE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_NE 3
     * }
     */
    public static int Py_NE() {
        return Py_NE;
    }
    private static final int Py_GT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_GT 4
     * }
     */
    public static int Py_GT() {
        return Py_GT;
    }
    private static final int Py_GE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define Py_GE 5
     * }
     */
    public static int Py_GE() {
        return Py_GE;
    }
    private static final int Py_TRASHCAN_HEADROOM = (int)50L;
    /**
     * {@snippet lang=c :
     * #define Py_TRASHCAN_HEADROOM 50
     * }
     */
    public static int Py_TRASHCAN_HEADROOM() {
        return Py_TRASHCAN_HEADROOM;
    }
    private static final int TYPE_MAX_WATCHERS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TYPE_MAX_WATCHERS 8
     * }
     */
    public static int TYPE_MAX_WATCHERS() {
        return TYPE_MAX_WATCHERS;
    }
    private static final int Py_bf_getbuffer = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_bf_getbuffer 1
     * }
     */
    public static int Py_bf_getbuffer() {
        return Py_bf_getbuffer;
    }
    private static final int Py_bf_releasebuffer = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_bf_releasebuffer 2
     * }
     */
    public static int Py_bf_releasebuffer() {
        return Py_bf_releasebuffer;
    }
    private static final int Py_mp_ass_subscript = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_mp_ass_subscript 3
     * }
     */
    public static int Py_mp_ass_subscript() {
        return Py_mp_ass_subscript;
    }
    private static final int Py_mp_length = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_mp_length 4
     * }
     */
    public static int Py_mp_length() {
        return Py_mp_length;
    }
    private static final int Py_mp_subscript = (int)5L;
    /**
     * {@snippet lang=c :
     * #define Py_mp_subscript 5
     * }
     */
    public static int Py_mp_subscript() {
        return Py_mp_subscript;
    }
    private static final int Py_nb_absolute = (int)6L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_absolute 6
     * }
     */
    public static int Py_nb_absolute() {
        return Py_nb_absolute;
    }
    private static final int Py_nb_add = (int)7L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_add 7
     * }
     */
    public static int Py_nb_add() {
        return Py_nb_add;
    }
    private static final int Py_nb_and = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_and 8
     * }
     */
    public static int Py_nb_and() {
        return Py_nb_and;
    }
    private static final int Py_nb_bool = (int)9L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_bool 9
     * }
     */
    public static int Py_nb_bool() {
        return Py_nb_bool;
    }
    private static final int Py_nb_divmod = (int)10L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_divmod 10
     * }
     */
    public static int Py_nb_divmod() {
        return Py_nb_divmod;
    }
    private static final int Py_nb_float = (int)11L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_float 11
     * }
     */
    public static int Py_nb_float() {
        return Py_nb_float;
    }
    private static final int Py_nb_floor_divide = (int)12L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_floor_divide 12
     * }
     */
    public static int Py_nb_floor_divide() {
        return Py_nb_floor_divide;
    }
    private static final int Py_nb_index = (int)13L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_index 13
     * }
     */
    public static int Py_nb_index() {
        return Py_nb_index;
    }
    private static final int Py_nb_inplace_add = (int)14L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_add 14
     * }
     */
    public static int Py_nb_inplace_add() {
        return Py_nb_inplace_add;
    }
    private static final int Py_nb_inplace_and = (int)15L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_and 15
     * }
     */
    public static int Py_nb_inplace_and() {
        return Py_nb_inplace_and;
    }
    private static final int Py_nb_inplace_floor_divide = (int)16L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_floor_divide 16
     * }
     */
    public static int Py_nb_inplace_floor_divide() {
        return Py_nb_inplace_floor_divide;
    }
    private static final int Py_nb_inplace_lshift = (int)17L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_lshift 17
     * }
     */
    public static int Py_nb_inplace_lshift() {
        return Py_nb_inplace_lshift;
    }
    private static final int Py_nb_inplace_multiply = (int)18L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_multiply 18
     * }
     */
    public static int Py_nb_inplace_multiply() {
        return Py_nb_inplace_multiply;
    }
    private static final int Py_nb_inplace_or = (int)19L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_or 19
     * }
     */
    public static int Py_nb_inplace_or() {
        return Py_nb_inplace_or;
    }
    private static final int Py_nb_inplace_power = (int)20L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_power 20
     * }
     */
    public static int Py_nb_inplace_power() {
        return Py_nb_inplace_power;
    }
    private static final int Py_nb_inplace_remainder = (int)21L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_remainder 21
     * }
     */
    public static int Py_nb_inplace_remainder() {
        return Py_nb_inplace_remainder;
    }
    private static final int Py_nb_inplace_rshift = (int)22L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_rshift 22
     * }
     */
    public static int Py_nb_inplace_rshift() {
        return Py_nb_inplace_rshift;
    }
    private static final int Py_nb_inplace_subtract = (int)23L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_subtract 23
     * }
     */
    public static int Py_nb_inplace_subtract() {
        return Py_nb_inplace_subtract;
    }
    private static final int Py_nb_inplace_true_divide = (int)24L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_true_divide 24
     * }
     */
    public static int Py_nb_inplace_true_divide() {
        return Py_nb_inplace_true_divide;
    }
    private static final int Py_nb_inplace_xor = (int)25L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_xor 25
     * }
     */
    public static int Py_nb_inplace_xor() {
        return Py_nb_inplace_xor;
    }
    private static final int Py_nb_int = (int)26L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_int 26
     * }
     */
    public static int Py_nb_int() {
        return Py_nb_int;
    }
    private static final int Py_nb_invert = (int)27L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_invert 27
     * }
     */
    public static int Py_nb_invert() {
        return Py_nb_invert;
    }
    private static final int Py_nb_lshift = (int)28L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_lshift 28
     * }
     */
    public static int Py_nb_lshift() {
        return Py_nb_lshift;
    }
    private static final int Py_nb_multiply = (int)29L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_multiply 29
     * }
     */
    public static int Py_nb_multiply() {
        return Py_nb_multiply;
    }
    private static final int Py_nb_negative = (int)30L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_negative 30
     * }
     */
    public static int Py_nb_negative() {
        return Py_nb_negative;
    }
    private static final int Py_nb_or = (int)31L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_or 31
     * }
     */
    public static int Py_nb_or() {
        return Py_nb_or;
    }
    private static final int Py_nb_positive = (int)32L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_positive 32
     * }
     */
    public static int Py_nb_positive() {
        return Py_nb_positive;
    }
    private static final int Py_nb_power = (int)33L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_power 33
     * }
     */
    public static int Py_nb_power() {
        return Py_nb_power;
    }
    private static final int Py_nb_remainder = (int)34L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_remainder 34
     * }
     */
    public static int Py_nb_remainder() {
        return Py_nb_remainder;
    }
    private static final int Py_nb_rshift = (int)35L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_rshift 35
     * }
     */
    public static int Py_nb_rshift() {
        return Py_nb_rshift;
    }
    private static final int Py_nb_subtract = (int)36L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_subtract 36
     * }
     */
    public static int Py_nb_subtract() {
        return Py_nb_subtract;
    }
    private static final int Py_nb_true_divide = (int)37L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_true_divide 37
     * }
     */
    public static int Py_nb_true_divide() {
        return Py_nb_true_divide;
    }
    private static final int Py_nb_xor = (int)38L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_xor 38
     * }
     */
    public static int Py_nb_xor() {
        return Py_nb_xor;
    }
    private static final int Py_sq_ass_item = (int)39L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_ass_item 39
     * }
     */
    public static int Py_sq_ass_item() {
        return Py_sq_ass_item;
    }
    private static final int Py_sq_concat = (int)40L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_concat 40
     * }
     */
    public static int Py_sq_concat() {
        return Py_sq_concat;
    }
    private static final int Py_sq_contains = (int)41L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_contains 41
     * }
     */
    public static int Py_sq_contains() {
        return Py_sq_contains;
    }
    private static final int Py_sq_inplace_concat = (int)42L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_inplace_concat 42
     * }
     */
    public static int Py_sq_inplace_concat() {
        return Py_sq_inplace_concat;
    }
    private static final int Py_sq_inplace_repeat = (int)43L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_inplace_repeat 43
     * }
     */
    public static int Py_sq_inplace_repeat() {
        return Py_sq_inplace_repeat;
    }
    private static final int Py_sq_item = (int)44L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_item 44
     * }
     */
    public static int Py_sq_item() {
        return Py_sq_item;
    }
    private static final int Py_sq_length = (int)45L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_length 45
     * }
     */
    public static int Py_sq_length() {
        return Py_sq_length;
    }
    private static final int Py_sq_repeat = (int)46L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_repeat 46
     * }
     */
    public static int Py_sq_repeat() {
        return Py_sq_repeat;
    }
    private static final int Py_tp_alloc = (int)47L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_alloc 47
     * }
     */
    public static int Py_tp_alloc() {
        return Py_tp_alloc;
    }
    private static final int Py_tp_base = (int)48L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_base 48
     * }
     */
    public static int Py_tp_base() {
        return Py_tp_base;
    }
    private static final int Py_tp_bases = (int)49L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_bases 49
     * }
     */
    public static int Py_tp_bases() {
        return Py_tp_bases;
    }
    private static final int Py_tp_call = (int)50L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_call 50
     * }
     */
    public static int Py_tp_call() {
        return Py_tp_call;
    }
    private static final int Py_tp_clear = (int)51L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_clear 51
     * }
     */
    public static int Py_tp_clear() {
        return Py_tp_clear;
    }
    private static final int Py_tp_dealloc = (int)52L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_dealloc 52
     * }
     */
    public static int Py_tp_dealloc() {
        return Py_tp_dealloc;
    }
    private static final int Py_tp_del = (int)53L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_del 53
     * }
     */
    public static int Py_tp_del() {
        return Py_tp_del;
    }
    private static final int Py_tp_descr_get = (int)54L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_descr_get 54
     * }
     */
    public static int Py_tp_descr_get() {
        return Py_tp_descr_get;
    }
    private static final int Py_tp_descr_set = (int)55L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_descr_set 55
     * }
     */
    public static int Py_tp_descr_set() {
        return Py_tp_descr_set;
    }
    private static final int Py_tp_doc = (int)56L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_doc 56
     * }
     */
    public static int Py_tp_doc() {
        return Py_tp_doc;
    }
    private static final int Py_tp_getattr = (int)57L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_getattr 57
     * }
     */
    public static int Py_tp_getattr() {
        return Py_tp_getattr;
    }
    private static final int Py_tp_getattro = (int)58L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_getattro 58
     * }
     */
    public static int Py_tp_getattro() {
        return Py_tp_getattro;
    }
    private static final int Py_tp_hash = (int)59L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_hash 59
     * }
     */
    public static int Py_tp_hash() {
        return Py_tp_hash;
    }
    private static final int Py_tp_init = (int)60L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_init 60
     * }
     */
    public static int Py_tp_init() {
        return Py_tp_init;
    }
    private static final int Py_tp_is_gc = (int)61L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_is_gc 61
     * }
     */
    public static int Py_tp_is_gc() {
        return Py_tp_is_gc;
    }
    private static final int Py_tp_iter = (int)62L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_iter 62
     * }
     */
    public static int Py_tp_iter() {
        return Py_tp_iter;
    }
    private static final int Py_tp_iternext = (int)63L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_iternext 63
     * }
     */
    public static int Py_tp_iternext() {
        return Py_tp_iternext;
    }
    private static final int Py_tp_methods = (int)64L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_methods 64
     * }
     */
    public static int Py_tp_methods() {
        return Py_tp_methods;
    }
    private static final int Py_tp_new = (int)65L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_new 65
     * }
     */
    public static int Py_tp_new() {
        return Py_tp_new;
    }
    private static final int Py_tp_repr = (int)66L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_repr 66
     * }
     */
    public static int Py_tp_repr() {
        return Py_tp_repr;
    }
    private static final int Py_tp_richcompare = (int)67L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_richcompare 67
     * }
     */
    public static int Py_tp_richcompare() {
        return Py_tp_richcompare;
    }
    private static final int Py_tp_setattr = (int)68L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_setattr 68
     * }
     */
    public static int Py_tp_setattr() {
        return Py_tp_setattr;
    }
    private static final int Py_tp_setattro = (int)69L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_setattro 69
     * }
     */
    public static int Py_tp_setattro() {
        return Py_tp_setattro;
    }
    private static final int Py_tp_str = (int)70L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_str 70
     * }
     */
    public static int Py_tp_str() {
        return Py_tp_str;
    }
    private static final int Py_tp_traverse = (int)71L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_traverse 71
     * }
     */
    public static int Py_tp_traverse() {
        return Py_tp_traverse;
    }
    private static final int Py_tp_members = (int)72L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_members 72
     * }
     */
    public static int Py_tp_members() {
        return Py_tp_members;
    }
    private static final int Py_tp_getset = (int)73L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_getset 73
     * }
     */
    public static int Py_tp_getset() {
        return Py_tp_getset;
    }
    private static final int Py_tp_free = (int)74L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_free 74
     * }
     */
    public static int Py_tp_free() {
        return Py_tp_free;
    }
    private static final int Py_nb_matrix_multiply = (int)75L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_matrix_multiply 75
     * }
     */
    public static int Py_nb_matrix_multiply() {
        return Py_nb_matrix_multiply;
    }
    private static final int Py_nb_inplace_matrix_multiply = (int)76L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_matrix_multiply 76
     * }
     */
    public static int Py_nb_inplace_matrix_multiply() {
        return Py_nb_inplace_matrix_multiply;
    }
    private static final int Py_am_await = (int)77L;
    /**
     * {@snippet lang=c :
     * #define Py_am_await 77
     * }
     */
    public static int Py_am_await() {
        return Py_am_await;
    }
    private static final int Py_am_aiter = (int)78L;
    /**
     * {@snippet lang=c :
     * #define Py_am_aiter 78
     * }
     */
    public static int Py_am_aiter() {
        return Py_am_aiter;
    }
    private static final int Py_am_anext = (int)79L;
    /**
     * {@snippet lang=c :
     * #define Py_am_anext 79
     * }
     */
    public static int Py_am_anext() {
        return Py_am_anext;
    }
    private static final int Py_tp_finalize = (int)80L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_finalize 80
     * }
     */
    public static int Py_tp_finalize() {
        return Py_tp_finalize;
    }
    private static final int Py_am_send = (int)81L;
    /**
     * {@snippet lang=c :
     * #define Py_am_send 81
     * }
     */
    public static int Py_am_send() {
        return Py_am_send;
    }
    private static final int Py_HASH_CUTOFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_CUTOFF 0
     * }
     */
    public static int Py_HASH_CUTOFF() {
        return Py_HASH_CUTOFF;
    }
    private static final int Py_HASH_EXTERNAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_EXTERNAL 0
     * }
     */
    public static int Py_HASH_EXTERNAL() {
        return Py_HASH_EXTERNAL;
    }
    private static final int Py_HASH_SIPHASH24 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_SIPHASH24 1
     * }
     */
    public static int Py_HASH_SIPHASH24() {
        return Py_HASH_SIPHASH24;
    }
    private static final int Py_HASH_FNV = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_FNV 2
     * }
     */
    public static int Py_HASH_FNV() {
        return Py_HASH_FNV;
    }
    private static final int Py_HASH_SIPHASH13 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_SIPHASH13 3
     * }
     */
    public static int Py_HASH_SIPHASH13() {
        return Py_HASH_SIPHASH13;
    }
    private static final int PyHASH_BITS = (int)61L;
    /**
     * {@snippet lang=c :
     * #define PyHASH_BITS 61
     * }
     */
    public static int PyHASH_BITS() {
        return PyHASH_BITS;
    }
    private static final int PyHASH_INF = (int)314159L;
    /**
     * {@snippet lang=c :
     * #define PyHASH_INF 314159
     * }
     */
    public static int PyHASH_INF() {
        return PyHASH_INF;
    }
    private static final int SSTATE_NOT_INTERNED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SSTATE_NOT_INTERNED 0
     * }
     */
    public static int SSTATE_NOT_INTERNED() {
        return SSTATE_NOT_INTERNED;
    }
    private static final int SSTATE_INTERNED_MORTAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SSTATE_INTERNED_MORTAL 1
     * }
     */
    public static int SSTATE_INTERNED_MORTAL() {
        return SSTATE_INTERNED_MORTAL;
    }
    private static final int SSTATE_INTERNED_IMMORTAL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SSTATE_INTERNED_IMMORTAL 2
     * }
     */
    public static int SSTATE_INTERNED_IMMORTAL() {
        return SSTATE_INTERNED_IMMORTAL;
    }
    private static final int SSTATE_INTERNED_IMMORTAL_STATIC = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SSTATE_INTERNED_IMMORTAL_STATIC 3
     * }
     */
    public static int SSTATE_INTERNED_IMMORTAL_STATIC() {
        return SSTATE_INTERNED_IMMORTAL_STATIC;
    }
    private static final int Py_ASNATIVEBYTES_BIG_ENDIAN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_ASNATIVEBYTES_BIG_ENDIAN 0
     * }
     */
    public static int Py_ASNATIVEBYTES_BIG_ENDIAN() {
        return Py_ASNATIVEBYTES_BIG_ENDIAN;
    }
    private static final int Py_ASNATIVEBYTES_LITTLE_ENDIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_ASNATIVEBYTES_LITTLE_ENDIAN 1
     * }
     */
    public static int Py_ASNATIVEBYTES_LITTLE_ENDIAN() {
        return Py_ASNATIVEBYTES_LITTLE_ENDIAN;
    }
    private static final int Py_ASNATIVEBYTES_NATIVE_ENDIAN = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_ASNATIVEBYTES_NATIVE_ENDIAN 3
     * }
     */
    public static int Py_ASNATIVEBYTES_NATIVE_ENDIAN() {
        return Py_ASNATIVEBYTES_NATIVE_ENDIAN;
    }
    private static final int Py_ASNATIVEBYTES_UNSIGNED_BUFFER = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_ASNATIVEBYTES_UNSIGNED_BUFFER 4
     * }
     */
    public static int Py_ASNATIVEBYTES_UNSIGNED_BUFFER() {
        return Py_ASNATIVEBYTES_UNSIGNED_BUFFER;
    }
    private static final int Py_ASNATIVEBYTES_REJECT_NEGATIVE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_ASNATIVEBYTES_REJECT_NEGATIVE 8
     * }
     */
    public static int Py_ASNATIVEBYTES_REJECT_NEGATIVE() {
        return Py_ASNATIVEBYTES_REJECT_NEGATIVE;
    }
    private static final int Py_ASNATIVEBYTES_ALLOW_INDEX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define Py_ASNATIVEBYTES_ALLOW_INDEX 16
     * }
     */
    public static int Py_ASNATIVEBYTES_ALLOW_INDEX() {
        return Py_ASNATIVEBYTES_ALLOW_INDEX;
    }
    private static final int PyLong_SHIFT = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PyLong_SHIFT 30
     * }
     */
    public static int PyLong_SHIFT() {
        return PyLong_SHIFT;
    }
    private static final int _PyLong_DECIMAL_SHIFT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _PyLong_DECIMAL_SHIFT 9
     * }
     */
    public static int _PyLong_DECIMAL_SHIFT() {
        return _PyLong_DECIMAL_SHIFT;
    }
    private static final int _PyLong_SIGN_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _PyLong_SIGN_MASK 3
     * }
     */
    public static int _PyLong_SIGN_MASK() {
        return _PyLong_SIGN_MASK;
    }
    private static final int _PyLong_NON_SIZE_BITS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _PyLong_NON_SIZE_BITS 3
     * }
     */
    public static int _PyLong_NON_SIZE_BITS() {
        return _PyLong_NON_SIZE_BITS;
    }
    private static final int _Py_MANAGED_BUFFER_RELEASED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _Py_MANAGED_BUFFER_RELEASED 1
     * }
     */
    public static int _Py_MANAGED_BUFFER_RELEASED() {
        return _Py_MANAGED_BUFFER_RELEASED;
    }
    private static final int _Py_MANAGED_BUFFER_FREE_FORMAT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _Py_MANAGED_BUFFER_FREE_FORMAT 2
     * }
     */
    public static int _Py_MANAGED_BUFFER_FREE_FORMAT() {
        return _Py_MANAGED_BUFFER_FREE_FORMAT;
    }
    private static final int _Py_MEMORYVIEW_RELEASED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_RELEASED 1
     * }
     */
    public static int _Py_MEMORYVIEW_RELEASED() {
        return _Py_MEMORYVIEW_RELEASED;
    }
    private static final int _Py_MEMORYVIEW_C = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_C 2
     * }
     */
    public static int _Py_MEMORYVIEW_C() {
        return _Py_MEMORYVIEW_C;
    }
    private static final int _Py_MEMORYVIEW_FORTRAN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_FORTRAN 4
     * }
     */
    public static int _Py_MEMORYVIEW_FORTRAN() {
        return _Py_MEMORYVIEW_FORTRAN;
    }
    private static final int _Py_MEMORYVIEW_SCALAR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_SCALAR 8
     * }
     */
    public static int _Py_MEMORYVIEW_SCALAR() {
        return _Py_MEMORYVIEW_SCALAR;
    }
    private static final int _Py_MEMORYVIEW_PIL = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_PIL 16
     * }
     */
    public static int _Py_MEMORYVIEW_PIL() {
        return _Py_MEMORYVIEW_PIL;
    }
    private static final int _Py_MEMORYVIEW_RESTRICTED = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_RESTRICTED 32
     * }
     */
    public static int _Py_MEMORYVIEW_RESTRICTED() {
        return _Py_MEMORYVIEW_RESTRICTED;
    }
    private static final int PySet_MINSIZE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PySet_MINSIZE 8
     * }
     */
    public static int PySet_MINSIZE() {
        return PySet_MINSIZE;
    }
    private static final int METH_VARARGS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define METH_VARARGS 1
     * }
     */
    public static int METH_VARARGS() {
        return METH_VARARGS;
    }
    private static final int METH_KEYWORDS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define METH_KEYWORDS 2
     * }
     */
    public static int METH_KEYWORDS() {
        return METH_KEYWORDS;
    }
    private static final int METH_NOARGS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define METH_NOARGS 4
     * }
     */
    public static int METH_NOARGS() {
        return METH_NOARGS;
    }
    private static final int METH_O = (int)8L;
    /**
     * {@snippet lang=c :
     * #define METH_O 8
     * }
     */
    public static int METH_O() {
        return METH_O;
    }
    private static final int METH_CLASS = (int)16L;
    /**
     * {@snippet lang=c :
     * #define METH_CLASS 16
     * }
     */
    public static int METH_CLASS() {
        return METH_CLASS;
    }
    private static final int METH_STATIC = (int)32L;
    /**
     * {@snippet lang=c :
     * #define METH_STATIC 32
     * }
     */
    public static int METH_STATIC() {
        return METH_STATIC;
    }
    private static final int METH_COEXIST = (int)64L;
    /**
     * {@snippet lang=c :
     * #define METH_COEXIST 64
     * }
     */
    public static int METH_COEXIST() {
        return METH_COEXIST;
    }
    private static final int METH_FASTCALL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define METH_FASTCALL 128
     * }
     */
    public static int METH_FASTCALL() {
        return METH_FASTCALL;
    }
    private static final int METH_STACKLESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define METH_STACKLESS 0
     * }
     */
    public static int METH_STACKLESS() {
        return METH_STACKLESS;
    }
    private static final int METH_METHOD = (int)512L;
    /**
     * {@snippet lang=c :
     * #define METH_METHOD 512
     * }
     */
    public static int METH_METHOD() {
        return METH_METHOD;
    }
    private static final int Py_mod_create = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_mod_create 1
     * }
     */
    public static int Py_mod_create() {
        return Py_mod_create;
    }
    private static final int Py_mod_exec = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_mod_exec 2
     * }
     */
    public static int Py_mod_exec() {
        return Py_mod_exec;
    }
    private static final int Py_mod_multiple_interpreters = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_mod_multiple_interpreters 3
     * }
     */
    public static int Py_mod_multiple_interpreters() {
        return Py_mod_multiple_interpreters;
    }
    private static final int Py_mod_gil = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_mod_gil 4
     * }
     */
    public static int Py_mod_gil() {
        return Py_mod_gil;
    }
    private static final int _Py_mod_LAST_SLOT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _Py_mod_LAST_SLOT 4
     * }
     */
    public static int _Py_mod_LAST_SLOT() {
        return _Py_mod_LAST_SLOT;
    }
    private static final int PY_MONITORING_EVENT_PY_START = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_PY_START 0
     * }
     */
    public static int PY_MONITORING_EVENT_PY_START() {
        return PY_MONITORING_EVENT_PY_START;
    }
    private static final int PY_MONITORING_EVENT_PY_RESUME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_PY_RESUME 1
     * }
     */
    public static int PY_MONITORING_EVENT_PY_RESUME() {
        return PY_MONITORING_EVENT_PY_RESUME;
    }
    private static final int PY_MONITORING_EVENT_PY_RETURN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_PY_RETURN 2
     * }
     */
    public static int PY_MONITORING_EVENT_PY_RETURN() {
        return PY_MONITORING_EVENT_PY_RETURN;
    }
    private static final int PY_MONITORING_EVENT_PY_YIELD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_PY_YIELD 3
     * }
     */
    public static int PY_MONITORING_EVENT_PY_YIELD() {
        return PY_MONITORING_EVENT_PY_YIELD;
    }
    private static final int PY_MONITORING_EVENT_CALL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_CALL 4
     * }
     */
    public static int PY_MONITORING_EVENT_CALL() {
        return PY_MONITORING_EVENT_CALL;
    }
    private static final int PY_MONITORING_EVENT_LINE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_LINE 5
     * }
     */
    public static int PY_MONITORING_EVENT_LINE() {
        return PY_MONITORING_EVENT_LINE;
    }
    private static final int PY_MONITORING_EVENT_INSTRUCTION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_INSTRUCTION 6
     * }
     */
    public static int PY_MONITORING_EVENT_INSTRUCTION() {
        return PY_MONITORING_EVENT_INSTRUCTION;
    }
    private static final int PY_MONITORING_EVENT_JUMP = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_JUMP 7
     * }
     */
    public static int PY_MONITORING_EVENT_JUMP() {
        return PY_MONITORING_EVENT_JUMP;
    }
    private static final int PY_MONITORING_EVENT_BRANCH = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_BRANCH 8
     * }
     */
    public static int PY_MONITORING_EVENT_BRANCH() {
        return PY_MONITORING_EVENT_BRANCH;
    }
    private static final int PY_MONITORING_EVENT_STOP_ITERATION = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_STOP_ITERATION 9
     * }
     */
    public static int PY_MONITORING_EVENT_STOP_ITERATION() {
        return PY_MONITORING_EVENT_STOP_ITERATION;
    }
    private static final int PY_MONITORING_EVENT_RAISE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_RAISE 10
     * }
     */
    public static int PY_MONITORING_EVENT_RAISE() {
        return PY_MONITORING_EVENT_RAISE;
    }
    private static final int PY_MONITORING_EVENT_EXCEPTION_HANDLED = (int)11L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_EXCEPTION_HANDLED 11
     * }
     */
    public static int PY_MONITORING_EVENT_EXCEPTION_HANDLED() {
        return PY_MONITORING_EVENT_EXCEPTION_HANDLED;
    }
    private static final int PY_MONITORING_EVENT_PY_UNWIND = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_PY_UNWIND 12
     * }
     */
    public static int PY_MONITORING_EVENT_PY_UNWIND() {
        return PY_MONITORING_EVENT_PY_UNWIND;
    }
    private static final int PY_MONITORING_EVENT_PY_THROW = (int)13L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_PY_THROW 13
     * }
     */
    public static int PY_MONITORING_EVENT_PY_THROW() {
        return PY_MONITORING_EVENT_PY_THROW;
    }
    private static final int PY_MONITORING_EVENT_RERAISE = (int)14L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_RERAISE 14
     * }
     */
    public static int PY_MONITORING_EVENT_RERAISE() {
        return PY_MONITORING_EVENT_RERAISE;
    }
    private static final int PY_MONITORING_EVENT_C_RETURN = (int)15L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_C_RETURN 15
     * }
     */
    public static int PY_MONITORING_EVENT_C_RETURN() {
        return PY_MONITORING_EVENT_C_RETURN;
    }
    private static final int PY_MONITORING_EVENT_C_RAISE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PY_MONITORING_EVENT_C_RAISE 16
     * }
     */
    public static int PY_MONITORING_EVENT_C_RAISE() {
        return PY_MONITORING_EVENT_C_RAISE;
    }
    private static final int _PY_MONITORING_LOCAL_EVENTS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _PY_MONITORING_LOCAL_EVENTS 10
     * }
     */
    public static int _PY_MONITORING_LOCAL_EVENTS() {
        return _PY_MONITORING_LOCAL_EVENTS;
    }
    private static final int _PY_MONITORING_UNGROUPED_EVENTS = (int)15L;
    /**
     * {@snippet lang=c :
     * #define _PY_MONITORING_UNGROUPED_EVENTS 15
     * }
     */
    public static int _PY_MONITORING_UNGROUPED_EVENTS() {
        return _PY_MONITORING_UNGROUPED_EVENTS;
    }
    private static final int _PY_MONITORING_EVENTS = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _PY_MONITORING_EVENTS 17
     * }
     */
    public static int _PY_MONITORING_EVENTS() {
        return _PY_MONITORING_EVENTS;
    }
    private static final int CO_OPTIMIZED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CO_OPTIMIZED 1
     * }
     */
    public static int CO_OPTIMIZED() {
        return CO_OPTIMIZED;
    }
    private static final int CO_NEWLOCALS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CO_NEWLOCALS 2
     * }
     */
    public static int CO_NEWLOCALS() {
        return CO_NEWLOCALS;
    }
    private static final int CO_VARARGS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CO_VARARGS 4
     * }
     */
    public static int CO_VARARGS() {
        return CO_VARARGS;
    }
    private static final int CO_VARKEYWORDS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CO_VARKEYWORDS 8
     * }
     */
    public static int CO_VARKEYWORDS() {
        return CO_VARKEYWORDS;
    }
    private static final int CO_NESTED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CO_NESTED 16
     * }
     */
    public static int CO_NESTED() {
        return CO_NESTED;
    }
    private static final int CO_GENERATOR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CO_GENERATOR 32
     * }
     */
    public static int CO_GENERATOR() {
        return CO_GENERATOR;
    }
    private static final int CO_COROUTINE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define CO_COROUTINE 128
     * }
     */
    public static int CO_COROUTINE() {
        return CO_COROUTINE;
    }
    private static final int CO_ITERABLE_COROUTINE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define CO_ITERABLE_COROUTINE 256
     * }
     */
    public static int CO_ITERABLE_COROUTINE() {
        return CO_ITERABLE_COROUTINE;
    }
    private static final int CO_ASYNC_GENERATOR = (int)512L;
    /**
     * {@snippet lang=c :
     * #define CO_ASYNC_GENERATOR 512
     * }
     */
    public static int CO_ASYNC_GENERATOR() {
        return CO_ASYNC_GENERATOR;
    }
    private static final int CO_FUTURE_DIVISION = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_DIVISION 131072
     * }
     */
    public static int CO_FUTURE_DIVISION() {
        return CO_FUTURE_DIVISION;
    }
    private static final int CO_FUTURE_ABSOLUTE_IMPORT = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_ABSOLUTE_IMPORT 262144
     * }
     */
    public static int CO_FUTURE_ABSOLUTE_IMPORT() {
        return CO_FUTURE_ABSOLUTE_IMPORT;
    }
    private static final int CO_FUTURE_WITH_STATEMENT = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_WITH_STATEMENT 524288
     * }
     */
    public static int CO_FUTURE_WITH_STATEMENT() {
        return CO_FUTURE_WITH_STATEMENT;
    }
    private static final int CO_FUTURE_PRINT_FUNCTION = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_PRINT_FUNCTION 1048576
     * }
     */
    public static int CO_FUTURE_PRINT_FUNCTION() {
        return CO_FUTURE_PRINT_FUNCTION;
    }
    private static final int CO_FUTURE_UNICODE_LITERALS = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_UNICODE_LITERALS 2097152
     * }
     */
    public static int CO_FUTURE_UNICODE_LITERALS() {
        return CO_FUTURE_UNICODE_LITERALS;
    }
    private static final int CO_FUTURE_BARRY_AS_BDFL = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_BARRY_AS_BDFL 4194304
     * }
     */
    public static int CO_FUTURE_BARRY_AS_BDFL() {
        return CO_FUTURE_BARRY_AS_BDFL;
    }
    private static final int CO_FUTURE_GENERATOR_STOP = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_GENERATOR_STOP 8388608
     * }
     */
    public static int CO_FUTURE_GENERATOR_STOP() {
        return CO_FUTURE_GENERATOR_STOP;
    }
    private static final int CO_FUTURE_ANNOTATIONS = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_ANNOTATIONS 16777216
     * }
     */
    public static int CO_FUTURE_ANNOTATIONS() {
        return CO_FUTURE_ANNOTATIONS;
    }
    private static final int CO_NO_MONITORING_EVENTS = (int)33554432L;
    /**
     * {@snippet lang=c :
     * #define CO_NO_MONITORING_EVENTS 33554432
     * }
     */
    public static int CO_NO_MONITORING_EVENTS() {
        return CO_NO_MONITORING_EVENTS;
    }
    private static final int CO_MAXBLOCKS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define CO_MAXBLOCKS 21
     * }
     */
    public static int CO_MAXBLOCKS() {
        return CO_MAXBLOCKS;
    }
    private static final int PyUnstable_EXECUTABLE_KIND_SKIP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PyUnstable_EXECUTABLE_KIND_SKIP 0
     * }
     */
    public static int PyUnstable_EXECUTABLE_KIND_SKIP() {
        return PyUnstable_EXECUTABLE_KIND_SKIP;
    }
    private static final int PyUnstable_EXECUTABLE_KIND_PY_FUNCTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyUnstable_EXECUTABLE_KIND_PY_FUNCTION 1
     * }
     */
    public static int PyUnstable_EXECUTABLE_KIND_PY_FUNCTION() {
        return PyUnstable_EXECUTABLE_KIND_PY_FUNCTION;
    }
    private static final int PyUnstable_EXECUTABLE_KIND_BUILTIN_FUNCTION = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PyUnstable_EXECUTABLE_KIND_BUILTIN_FUNCTION 3
     * }
     */
    public static int PyUnstable_EXECUTABLE_KIND_BUILTIN_FUNCTION() {
        return PyUnstable_EXECUTABLE_KIND_BUILTIN_FUNCTION;
    }
    private static final int PyUnstable_EXECUTABLE_KIND_METHOD_DESCRIPTOR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PyUnstable_EXECUTABLE_KIND_METHOD_DESCRIPTOR 4
     * }
     */
    public static int PyUnstable_EXECUTABLE_KIND_METHOD_DESCRIPTOR() {
        return PyUnstable_EXECUTABLE_KIND_METHOD_DESCRIPTOR;
    }
    private static final int PyUnstable_EXECUTABLE_KINDS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PyUnstable_EXECUTABLE_KINDS 5
     * }
     */
    public static int PyUnstable_EXECUTABLE_KINDS() {
        return PyUnstable_EXECUTABLE_KINDS;
    }
    private static final int MAX_CO_EXTRA_USERS = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_CO_EXTRA_USERS 255
     * }
     */
    public static int MAX_CO_EXTRA_USERS() {
        return MAX_CO_EXTRA_USERS;
    }
    private static final int PyTrace_CALL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_CALL 0
     * }
     */
    public static int PyTrace_CALL() {
        return PyTrace_CALL;
    }
    private static final int PyTrace_EXCEPTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_EXCEPTION 1
     * }
     */
    public static int PyTrace_EXCEPTION() {
        return PyTrace_EXCEPTION;
    }
    private static final int PyTrace_LINE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_LINE 2
     * }
     */
    public static int PyTrace_LINE() {
        return PyTrace_LINE;
    }
    private static final int PyTrace_RETURN = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_RETURN 3
     * }
     */
    public static int PyTrace_RETURN() {
        return PyTrace_RETURN;
    }
    private static final int PyTrace_C_CALL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_C_CALL 4
     * }
     */
    public static int PyTrace_C_CALL() {
        return PyTrace_C_CALL;
    }
    private static final int PyTrace_C_EXCEPTION = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_C_EXCEPTION 5
     * }
     */
    public static int PyTrace_C_EXCEPTION() {
        return PyTrace_C_EXCEPTION;
    }
    private static final int PyTrace_C_RETURN = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_C_RETURN 6
     * }
     */
    public static int PyTrace_C_RETURN() {
        return PyTrace_C_RETURN;
    }
    private static final int PyTrace_OPCODE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_OPCODE 7
     * }
     */
    public static int PyTrace_OPCODE() {
        return PyTrace_OPCODE;
    }
    private static final int Py_C_RECURSION_LIMIT = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define Py_C_RECURSION_LIMIT 10000
     * }
     */
    public static int Py_C_RECURSION_LIMIT() {
        return Py_C_RECURSION_LIMIT;
    }
    private static final int Py_T_SHORT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_T_SHORT 0
     * }
     */
    public static int Py_T_SHORT() {
        return Py_T_SHORT;
    }
    private static final int Py_T_INT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_T_INT 1
     * }
     */
    public static int Py_T_INT() {
        return Py_T_INT;
    }
    private static final int Py_T_LONG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_T_LONG 2
     * }
     */
    public static int Py_T_LONG() {
        return Py_T_LONG;
    }
    private static final int Py_T_FLOAT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_T_FLOAT 3
     * }
     */
    public static int Py_T_FLOAT() {
        return Py_T_FLOAT;
    }
    private static final int Py_T_DOUBLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_T_DOUBLE 4
     * }
     */
    public static int Py_T_DOUBLE() {
        return Py_T_DOUBLE;
    }
    private static final int Py_T_STRING = (int)5L;
    /**
     * {@snippet lang=c :
     * #define Py_T_STRING 5
     * }
     */
    public static int Py_T_STRING() {
        return Py_T_STRING;
    }
    private static final int _Py_T_OBJECT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _Py_T_OBJECT 6
     * }
     */
    public static int _Py_T_OBJECT() {
        return _Py_T_OBJECT;
    }
    private static final int Py_T_CHAR = (int)7L;
    /**
     * {@snippet lang=c :
     * #define Py_T_CHAR 7
     * }
     */
    public static int Py_T_CHAR() {
        return Py_T_CHAR;
    }
    private static final int Py_T_BYTE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_T_BYTE 8
     * }
     */
    public static int Py_T_BYTE() {
        return Py_T_BYTE;
    }
    private static final int Py_T_UBYTE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define Py_T_UBYTE 9
     * }
     */
    public static int Py_T_UBYTE() {
        return Py_T_UBYTE;
    }
    private static final int Py_T_USHORT = (int)10L;
    /**
     * {@snippet lang=c :
     * #define Py_T_USHORT 10
     * }
     */
    public static int Py_T_USHORT() {
        return Py_T_USHORT;
    }
    private static final int Py_T_UINT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define Py_T_UINT 11
     * }
     */
    public static int Py_T_UINT() {
        return Py_T_UINT;
    }
    private static final int Py_T_ULONG = (int)12L;
    /**
     * {@snippet lang=c :
     * #define Py_T_ULONG 12
     * }
     */
    public static int Py_T_ULONG() {
        return Py_T_ULONG;
    }
    private static final int Py_T_STRING_INPLACE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define Py_T_STRING_INPLACE 13
     * }
     */
    public static int Py_T_STRING_INPLACE() {
        return Py_T_STRING_INPLACE;
    }
    private static final int Py_T_BOOL = (int)14L;
    /**
     * {@snippet lang=c :
     * #define Py_T_BOOL 14
     * }
     */
    public static int Py_T_BOOL() {
        return Py_T_BOOL;
    }
    private static final int Py_T_OBJECT_EX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define Py_T_OBJECT_EX 16
     * }
     */
    public static int Py_T_OBJECT_EX() {
        return Py_T_OBJECT_EX;
    }
    private static final int Py_T_LONGLONG = (int)17L;
    /**
     * {@snippet lang=c :
     * #define Py_T_LONGLONG 17
     * }
     */
    public static int Py_T_LONGLONG() {
        return Py_T_LONGLONG;
    }
    private static final int Py_T_ULONGLONG = (int)18L;
    /**
     * {@snippet lang=c :
     * #define Py_T_ULONGLONG 18
     * }
     */
    public static int Py_T_ULONGLONG() {
        return Py_T_ULONGLONG;
    }
    private static final int Py_T_PYSSIZET = (int)19L;
    /**
     * {@snippet lang=c :
     * #define Py_T_PYSSIZET 19
     * }
     */
    public static int Py_T_PYSSIZET() {
        return Py_T_PYSSIZET;
    }
    private static final int _Py_T_NONE = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _Py_T_NONE 20
     * }
     */
    public static int _Py_T_NONE() {
        return _Py_T_NONE;
    }
    private static final int Py_READONLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_READONLY 1
     * }
     */
    public static int Py_READONLY() {
        return Py_READONLY;
    }
    private static final int Py_AUDIT_READ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_AUDIT_READ 2
     * }
     */
    public static int Py_AUDIT_READ() {
        return Py_AUDIT_READ;
    }
    private static final int _Py_WRITE_RESTRICTED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _Py_WRITE_RESTRICTED 4
     * }
     */
    public static int _Py_WRITE_RESTRICTED() {
        return _Py_WRITE_RESTRICTED;
    }
    private static final int Py_RELATIVE_OFFSET = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_RELATIVE_OFFSET 8
     * }
     */
    public static int Py_RELATIVE_OFFSET() {
        return Py_RELATIVE_OFFSET;
    }
    private static final int PyWrapperFlag_KEYWORDS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyWrapperFlag_KEYWORDS 1
     * }
     */
    public static int PyWrapperFlag_KEYWORDS() {
        return PyWrapperFlag_KEYWORDS;
    }
    private static final int WAIT_LOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WAIT_LOCK 1
     * }
     */
    public static int WAIT_LOCK() {
        return WAIT_LOCK;
    }
    private static final int NOWAIT_LOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NOWAIT_LOCK 0
     * }
     */
    public static int NOWAIT_LOCK() {
        return NOWAIT_LOCK;
    }
    private static final int _PTHREAD_MUTEX_SIG_init = (int)850045863L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_MUTEX_SIG_init 850045863
     * }
     */
    public static int _PTHREAD_MUTEX_SIG_init() {
        return _PTHREAD_MUTEX_SIG_init;
    }
    private static final int _PTHREAD_ERRORCHECK_MUTEX_SIG_init = (int)850045857L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_ERRORCHECK_MUTEX_SIG_init 850045857
     * }
     */
    public static int _PTHREAD_ERRORCHECK_MUTEX_SIG_init() {
        return _PTHREAD_ERRORCHECK_MUTEX_SIG_init;
    }
    private static final int _PTHREAD_RECURSIVE_MUTEX_SIG_init = (int)850045858L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_RECURSIVE_MUTEX_SIG_init 850045858
     * }
     */
    public static int _PTHREAD_RECURSIVE_MUTEX_SIG_init() {
        return _PTHREAD_RECURSIVE_MUTEX_SIG_init;
    }
    private static final int _PTHREAD_FIRSTFIT_MUTEX_SIG_init = (int)850045859L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_FIRSTFIT_MUTEX_SIG_init 850045859
     * }
     */
    public static int _PTHREAD_FIRSTFIT_MUTEX_SIG_init() {
        return _PTHREAD_FIRSTFIT_MUTEX_SIG_init;
    }
    private static final int _PTHREAD_COND_SIG_init = (int)1018212795L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_COND_SIG_init 1018212795
     * }
     */
    public static int _PTHREAD_COND_SIG_init() {
        return _PTHREAD_COND_SIG_init;
    }
    private static final int _PTHREAD_ONCE_SIG_init = (int)816954554L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_ONCE_SIG_init 816954554
     * }
     */
    public static int _PTHREAD_ONCE_SIG_init() {
        return _PTHREAD_ONCE_SIG_init;
    }
    private static final int _PTHREAD_RWLOCK_SIG_init = (int)766030772L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_RWLOCK_SIG_init 766030772
     * }
     */
    public static int _PTHREAD_RWLOCK_SIG_init() {
        return _PTHREAD_RWLOCK_SIG_init;
    }
    private static final int SCHED_OTHER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCHED_OTHER 1
     * }
     */
    public static int SCHED_OTHER() {
        return SCHED_OTHER;
    }
    private static final int SCHED_FIFO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SCHED_FIFO 4
     * }
     */
    public static int SCHED_FIFO() {
        return SCHED_FIFO;
    }
    private static final int SCHED_RR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SCHED_RR 2
     * }
     */
    public static int SCHED_RR() {
        return SCHED_RR;
    }
    private static final int __SCHED_PARAM_SIZE__ = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SCHED_PARAM_SIZE__ 4
     * }
     */
    public static int __SCHED_PARAM_SIZE__() {
        return __SCHED_PARAM_SIZE__;
    }
    private static final int PTHREAD_CREATE_JOINABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CREATE_JOINABLE 1
     * }
     */
    public static int PTHREAD_CREATE_JOINABLE() {
        return PTHREAD_CREATE_JOINABLE;
    }
    private static final int PTHREAD_CREATE_DETACHED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CREATE_DETACHED 2
     * }
     */
    public static int PTHREAD_CREATE_DETACHED() {
        return PTHREAD_CREATE_DETACHED;
    }
    private static final int PTHREAD_INHERIT_SCHED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_INHERIT_SCHED 1
     * }
     */
    public static int PTHREAD_INHERIT_SCHED() {
        return PTHREAD_INHERIT_SCHED;
    }
    private static final int PTHREAD_EXPLICIT_SCHED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_EXPLICIT_SCHED 2
     * }
     */
    public static int PTHREAD_EXPLICIT_SCHED() {
        return PTHREAD_EXPLICIT_SCHED;
    }
    private static final int PTHREAD_CANCEL_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CANCEL_ENABLE 1
     * }
     */
    public static int PTHREAD_CANCEL_ENABLE() {
        return PTHREAD_CANCEL_ENABLE;
    }
    private static final int PTHREAD_CANCEL_DISABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CANCEL_DISABLE 0
     * }
     */
    public static int PTHREAD_CANCEL_DISABLE() {
        return PTHREAD_CANCEL_DISABLE;
    }
    private static final int PTHREAD_CANCEL_DEFERRED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CANCEL_DEFERRED 2
     * }
     */
    public static int PTHREAD_CANCEL_DEFERRED() {
        return PTHREAD_CANCEL_DEFERRED;
    }
    private static final int PTHREAD_CANCEL_ASYNCHRONOUS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CANCEL_ASYNCHRONOUS 0
     * }
     */
    public static int PTHREAD_CANCEL_ASYNCHRONOUS() {
        return PTHREAD_CANCEL_ASYNCHRONOUS;
    }
    private static final int PTHREAD_SCOPE_SYSTEM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_SCOPE_SYSTEM 1
     * }
     */
    public static int PTHREAD_SCOPE_SYSTEM() {
        return PTHREAD_SCOPE_SYSTEM;
    }
    private static final int PTHREAD_SCOPE_PROCESS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_SCOPE_PROCESS 2
     * }
     */
    public static int PTHREAD_SCOPE_PROCESS() {
        return PTHREAD_SCOPE_PROCESS;
    }
    private static final int PTHREAD_PROCESS_SHARED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PROCESS_SHARED 1
     * }
     */
    public static int PTHREAD_PROCESS_SHARED() {
        return PTHREAD_PROCESS_SHARED;
    }
    private static final int PTHREAD_PROCESS_PRIVATE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PROCESS_PRIVATE 2
     * }
     */
    public static int PTHREAD_PROCESS_PRIVATE() {
        return PTHREAD_PROCESS_PRIVATE;
    }
    private static final int PTHREAD_PRIO_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PRIO_NONE 0
     * }
     */
    public static int PTHREAD_PRIO_NONE() {
        return PTHREAD_PRIO_NONE;
    }
    private static final int PTHREAD_PRIO_INHERIT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PRIO_INHERIT 1
     * }
     */
    public static int PTHREAD_PRIO_INHERIT() {
        return PTHREAD_PRIO_INHERIT;
    }
    private static final int PTHREAD_PRIO_PROTECT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PRIO_PROTECT 2
     * }
     */
    public static int PTHREAD_PRIO_PROTECT() {
        return PTHREAD_PRIO_PROTECT;
    }
    private static final int PTHREAD_MUTEX_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_NORMAL 0
     * }
     */
    public static int PTHREAD_MUTEX_NORMAL() {
        return PTHREAD_MUTEX_NORMAL;
    }
    private static final int PTHREAD_MUTEX_ERRORCHECK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_ERRORCHECK 1
     * }
     */
    public static int PTHREAD_MUTEX_ERRORCHECK() {
        return PTHREAD_MUTEX_ERRORCHECK;
    }
    private static final int PTHREAD_MUTEX_RECURSIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_RECURSIVE 2
     * }
     */
    public static int PTHREAD_MUTEX_RECURSIVE() {
        return PTHREAD_MUTEX_RECURSIVE;
    }
    private static final int PTHREAD_MUTEX_POLICY_FAIRSHARE_NP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_POLICY_FAIRSHARE_NP 1
     * }
     */
    public static int PTHREAD_MUTEX_POLICY_FAIRSHARE_NP() {
        return PTHREAD_MUTEX_POLICY_FAIRSHARE_NP;
    }
    private static final int PTHREAD_MUTEX_POLICY_FIRSTFIT_NP = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_POLICY_FIRSTFIT_NP 3
     * }
     */
    public static int PTHREAD_MUTEX_POLICY_FIRSTFIT_NP() {
        return PTHREAD_MUTEX_POLICY_FIRSTFIT_NP;
    }
    private static final int Py_CLEANUP_SUPPORTED = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define Py_CLEANUP_SUPPORTED 131072
     * }
     */
    public static int Py_CLEANUP_SUPPORTED() {
        return Py_CLEANUP_SUPPORTED;
    }
    private static final int PYTHON_API_VERSION = (int)1013L;
    /**
     * {@snippet lang=c :
     * #define PYTHON_API_VERSION 1013
     * }
     */
    public static int PYTHON_API_VERSION() {
        return PYTHON_API_VERSION;
    }
    private static final int PYTHON_ABI_VERSION = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PYTHON_ABI_VERSION 3
     * }
     */
    public static int PYTHON_ABI_VERSION() {
        return PYTHON_ABI_VERSION;
    }
    private static final int Py_single_input = (int)256L;
    /**
     * {@snippet lang=c :
     * #define Py_single_input 256
     * }
     */
    public static int Py_single_input() {
        return Py_single_input;
    }
    private static final int Py_file_input = (int)257L;
    /**
     * {@snippet lang=c :
     * #define Py_file_input 257
     * }
     */
    public static int Py_file_input() {
        return Py_file_input;
    }
    private static final int Py_eval_input = (int)258L;
    /**
     * {@snippet lang=c :
     * #define Py_eval_input 258
     * }
     */
    public static int Py_eval_input() {
        return Py_eval_input;
    }
    private static final int Py_func_type_input = (int)345L;
    /**
     * {@snippet lang=c :
     * #define Py_func_type_input 345
     * }
     */
    public static int Py_func_type_input() {
        return Py_func_type_input;
    }
    private static final int PyCF_SOURCE_IS_UTF8 = (int)256L;
    /**
     * {@snippet lang=c :
     * #define PyCF_SOURCE_IS_UTF8 256
     * }
     */
    public static int PyCF_SOURCE_IS_UTF8() {
        return PyCF_SOURCE_IS_UTF8;
    }
    private static final int PyCF_DONT_IMPLY_DEDENT = (int)512L;
    /**
     * {@snippet lang=c :
     * #define PyCF_DONT_IMPLY_DEDENT 512
     * }
     */
    public static int PyCF_DONT_IMPLY_DEDENT() {
        return PyCF_DONT_IMPLY_DEDENT;
    }
    private static final int PyCF_ONLY_AST = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PyCF_ONLY_AST 1024
     * }
     */
    public static int PyCF_ONLY_AST() {
        return PyCF_ONLY_AST;
    }
    private static final int PyCF_IGNORE_COOKIE = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define PyCF_IGNORE_COOKIE 2048
     * }
     */
    public static int PyCF_IGNORE_COOKIE() {
        return PyCF_IGNORE_COOKIE;
    }
    private static final int PyCF_TYPE_COMMENTS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PyCF_TYPE_COMMENTS 4096
     * }
     */
    public static int PyCF_TYPE_COMMENTS() {
        return PyCF_TYPE_COMMENTS;
    }
    private static final int PyCF_ALLOW_TOP_LEVEL_AWAIT = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define PyCF_ALLOW_TOP_LEVEL_AWAIT 8192
     * }
     */
    public static int PyCF_ALLOW_TOP_LEVEL_AWAIT() {
        return PyCF_ALLOW_TOP_LEVEL_AWAIT;
    }
    private static final int PyCF_ALLOW_INCOMPLETE_INPUT = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PyCF_ALLOW_INCOMPLETE_INPUT 16384
     * }
     */
    public static int PyCF_ALLOW_INCOMPLETE_INPUT() {
        return PyCF_ALLOW_INCOMPLETE_INPUT;
    }
    private static final int PYOS_STACK_MARGIN = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define PYOS_STACK_MARGIN 2048
     * }
     */
    public static int PYOS_STACK_MARGIN() {
        return PYOS_STACK_MARGIN;
    }
    private static final int _PyInterpreterConfig_LEGACY_CHECK_MULTI_INTERP_EXTENSIONS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _PyInterpreterConfig_LEGACY_CHECK_MULTI_INTERP_EXTENSIONS 0
     * }
     */
    public static int _PyInterpreterConfig_LEGACY_CHECK_MULTI_INTERP_EXTENSIONS() {
        return _PyInterpreterConfig_LEGACY_CHECK_MULTI_INTERP_EXTENSIONS;
    }
    private static final int FVC_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FVC_MASK 3
     * }
     */
    public static int FVC_MASK() {
        return FVC_MASK;
    }
    private static final int FVC_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FVC_NONE 0
     * }
     */
    public static int FVC_NONE() {
        return FVC_NONE;
    }
    private static final int FVC_STR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FVC_STR 1
     * }
     */
    public static int FVC_STR() {
        return FVC_STR;
    }
    private static final int FVC_REPR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FVC_REPR 2
     * }
     */
    public static int FVC_REPR() {
        return FVC_REPR;
    }
    private static final int FVC_ASCII = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FVC_ASCII 3
     * }
     */
    public static int FVC_ASCII() {
        return FVC_ASCII;
    }
    private static final int FVS_MASK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FVS_MASK 4
     * }
     */
    public static int FVS_MASK() {
        return FVS_MASK;
    }
    private static final int FVS_HAVE_SPEC = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FVS_HAVE_SPEC 4
     * }
     */
    public static int FVS_HAVE_SPEC() {
        return FVS_HAVE_SPEC;
    }
    private static final int PY_CTF_LOWER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_LOWER 1
     * }
     */
    public static int PY_CTF_LOWER() {
        return PY_CTF_LOWER;
    }
    private static final int PY_CTF_UPPER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_UPPER 2
     * }
     */
    public static int PY_CTF_UPPER() {
        return PY_CTF_UPPER;
    }
    private static final int PY_CTF_DIGIT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_DIGIT 4
     * }
     */
    public static int PY_CTF_DIGIT() {
        return PY_CTF_DIGIT;
    }
    private static final int PY_CTF_SPACE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_SPACE 8
     * }
     */
    public static int PY_CTF_SPACE() {
        return PY_CTF_SPACE;
    }
    private static final int PY_CTF_XDIGIT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_XDIGIT 16
     * }
     */
    public static int PY_CTF_XDIGIT() {
        return PY_CTF_XDIGIT;
    }
    private static final int Py_DTSF_SIGN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_SIGN 1
     * }
     */
    public static int Py_DTSF_SIGN() {
        return Py_DTSF_SIGN;
    }
    private static final int Py_DTSF_ADD_DOT_0 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_ADD_DOT_0 2
     * }
     */
    public static int Py_DTSF_ADD_DOT_0() {
        return Py_DTSF_ADD_DOT_0;
    }
    private static final int Py_DTSF_ALT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_ALT 4
     * }
     */
    public static int Py_DTSF_ALT() {
        return Py_DTSF_ALT;
    }
    private static final int Py_DTSF_NO_NEG_0 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_NO_NEG_0 8
     * }
     */
    public static int Py_DTSF_NO_NEG_0() {
        return Py_DTSF_NO_NEG_0;
    }
    private static final int Py_DTST_FINITE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_DTST_FINITE 0
     * }
     */
    public static int Py_DTST_FINITE() {
        return Py_DTST_FINITE;
    }
    private static final int Py_DTST_INFINITE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_DTST_INFINITE 1
     * }
     */
    public static int Py_DTST_INFINITE() {
        return Py_DTST_INFINITE;
    }
    private static final int Py_DTST_NAN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_DTST_NAN 2
     * }
     */
    public static int Py_DTST_NAN() {
        return Py_DTST_NAN;
    }
    private static final int S_IFMT = (int)61440L;
    /**
     * {@snippet lang=c :
     * #define S_IFMT 61440
     * }
     */
    public static int S_IFMT() {
        return S_IFMT;
    }
    private static final int S_IFIFO = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define S_IFIFO 4096
     * }
     */
    public static int S_IFIFO() {
        return S_IFIFO;
    }
    private static final int S_IFCHR = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define S_IFCHR 8192
     * }
     */
    public static int S_IFCHR() {
        return S_IFCHR;
    }
    private static final int S_IFDIR = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define S_IFDIR 16384
     * }
     */
    public static int S_IFDIR() {
        return S_IFDIR;
    }
    private static final int S_IFBLK = (int)24576L;
    /**
     * {@snippet lang=c :
     * #define S_IFBLK 24576
     * }
     */
    public static int S_IFBLK() {
        return S_IFBLK;
    }
    private static final int S_IFREG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define S_IFREG 32768
     * }
     */
    public static int S_IFREG() {
        return S_IFREG;
    }
    private static final int S_IFLNK = (int)40960L;
    /**
     * {@snippet lang=c :
     * #define S_IFLNK 40960
     * }
     */
    public static int S_IFLNK() {
        return S_IFLNK;
    }
    private static final int S_IFSOCK = (int)49152L;
    /**
     * {@snippet lang=c :
     * #define S_IFSOCK 49152
     * }
     */
    public static int S_IFSOCK() {
        return S_IFSOCK;
    }
    private static final int S_IFWHT = (int)57344L;
    /**
     * {@snippet lang=c :
     * #define S_IFWHT 57344
     * }
     */
    public static int S_IFWHT() {
        return S_IFWHT;
    }
    private static final int S_IRWXU = (int)448L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXU 448
     * }
     */
    public static int S_IRWXU() {
        return S_IRWXU;
    }
    private static final int S_IRUSR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define S_IRUSR 256
     * }
     */
    public static int S_IRUSR() {
        return S_IRUSR;
    }
    private static final int S_IWUSR = (int)128L;
    /**
     * {@snippet lang=c :
     * #define S_IWUSR 128
     * }
     */
    public static int S_IWUSR() {
        return S_IWUSR;
    }
    private static final int S_IXUSR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define S_IXUSR 64
     * }
     */
    public static int S_IXUSR() {
        return S_IXUSR;
    }
    private static final int S_IRWXG = (int)56L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXG 56
     * }
     */
    public static int S_IRWXG() {
        return S_IRWXG;
    }
    private static final int S_IRGRP = (int)32L;
    /**
     * {@snippet lang=c :
     * #define S_IRGRP 32
     * }
     */
    public static int S_IRGRP() {
        return S_IRGRP;
    }
    private static final int S_IWGRP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define S_IWGRP 16
     * }
     */
    public static int S_IWGRP() {
        return S_IWGRP;
    }
    private static final int S_IXGRP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define S_IXGRP 8
     * }
     */
    public static int S_IXGRP() {
        return S_IXGRP;
    }
    private static final int S_IRWXO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXO 7
     * }
     */
    public static int S_IRWXO() {
        return S_IRWXO;
    }
    private static final int S_IROTH = (int)4L;
    /**
     * {@snippet lang=c :
     * #define S_IROTH 4
     * }
     */
    public static int S_IROTH() {
        return S_IROTH;
    }
    private static final int S_IWOTH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define S_IWOTH 2
     * }
     */
    public static int S_IWOTH() {
        return S_IWOTH;
    }
    private static final int S_IXOTH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define S_IXOTH 1
     * }
     */
    public static int S_IXOTH() {
        return S_IXOTH;
    }
    private static final int S_ISUID = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define S_ISUID 2048
     * }
     */
    public static int S_ISUID() {
        return S_ISUID;
    }
    private static final int S_ISGID = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define S_ISGID 1024
     * }
     */
    public static int S_ISGID() {
        return S_ISGID;
    }
    private static final int S_ISVTX = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_ISVTX 512
     * }
     */
    public static int S_ISVTX() {
        return S_ISVTX;
    }
    private static final int S_BLKSIZE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_BLKSIZE 512
     * }
     */
    public static int S_BLKSIZE() {
        return S_BLKSIZE;
    }
    private static final int UF_SETTABLE = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UF_SETTABLE 65535
     * }
     */
    public static int UF_SETTABLE() {
        return UF_SETTABLE;
    }
    private static final int UF_NODUMP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define UF_NODUMP 1
     * }
     */
    public static int UF_NODUMP() {
        return UF_NODUMP;
    }
    private static final int UF_IMMUTABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define UF_IMMUTABLE 2
     * }
     */
    public static int UF_IMMUTABLE() {
        return UF_IMMUTABLE;
    }
    private static final int UF_APPEND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define UF_APPEND 4
     * }
     */
    public static int UF_APPEND() {
        return UF_APPEND;
    }
    private static final int UF_OPAQUE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define UF_OPAQUE 8
     * }
     */
    public static int UF_OPAQUE() {
        return UF_OPAQUE;
    }
    private static final int UF_COMPRESSED = (int)32L;
    /**
     * {@snippet lang=c :
     * #define UF_COMPRESSED 32
     * }
     */
    public static int UF_COMPRESSED() {
        return UF_COMPRESSED;
    }
    private static final int UF_TRACKED = (int)64L;
    /**
     * {@snippet lang=c :
     * #define UF_TRACKED 64
     * }
     */
    public static int UF_TRACKED() {
        return UF_TRACKED;
    }
    private static final int UF_DATAVAULT = (int)128L;
    /**
     * {@snippet lang=c :
     * #define UF_DATAVAULT 128
     * }
     */
    public static int UF_DATAVAULT() {
        return UF_DATAVAULT;
    }
    private static final int UF_HIDDEN = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define UF_HIDDEN 32768
     * }
     */
    public static int UF_HIDDEN() {
        return UF_HIDDEN;
    }
    private static final int SF_SUPPORTED = (int)10420224L;
    /**
     * {@snippet lang=c :
     * #define SF_SUPPORTED 10420224
     * }
     */
    public static int SF_SUPPORTED() {
        return SF_SUPPORTED;
    }
    private static final int SF_SETTABLE = (int)1073676288L;
    /**
     * {@snippet lang=c :
     * #define SF_SETTABLE 1073676288
     * }
     */
    public static int SF_SETTABLE() {
        return SF_SETTABLE;
    }
    private static final int SF_ARCHIVED = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define SF_ARCHIVED 65536
     * }
     */
    public static int SF_ARCHIVED() {
        return SF_ARCHIVED;
    }
    private static final int SF_IMMUTABLE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define SF_IMMUTABLE 131072
     * }
     */
    public static int SF_IMMUTABLE() {
        return SF_IMMUTABLE;
    }
    private static final int SF_APPEND = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define SF_APPEND 262144
     * }
     */
    public static int SF_APPEND() {
        return SF_APPEND;
    }
    private static final int SF_RESTRICTED = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define SF_RESTRICTED 524288
     * }
     */
    public static int SF_RESTRICTED() {
        return SF_RESTRICTED;
    }
    private static final int SF_NOUNLINK = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define SF_NOUNLINK 1048576
     * }
     */
    public static int SF_NOUNLINK() {
        return SF_NOUNLINK;
    }
    private static final int SF_FIRMLINK = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define SF_FIRMLINK 8388608
     * }
     */
    public static int SF_FIRMLINK() {
        return SF_FIRMLINK;
    }
    private static final int SF_DATALESS = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define SF_DATALESS 1073741824
     * }
     */
    public static int SF_DATALESS() {
        return SF_DATALESS;
    }
    private static final int EF_MAY_SHARE_BLOCKS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EF_MAY_SHARE_BLOCKS 1
     * }
     */
    public static int EF_MAY_SHARE_BLOCKS() {
        return EF_MAY_SHARE_BLOCKS;
    }
    private static final int EF_NO_XATTRS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EF_NO_XATTRS 2
     * }
     */
    public static int EF_NO_XATTRS() {
        return EF_NO_XATTRS;
    }
    private static final int EF_IS_SYNC_ROOT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_SYNC_ROOT 4
     * }
     */
    public static int EF_IS_SYNC_ROOT() {
        return EF_IS_SYNC_ROOT;
    }
    private static final int EF_IS_PURGEABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_PURGEABLE 8
     * }
     */
    public static int EF_IS_PURGEABLE() {
        return EF_IS_PURGEABLE;
    }
    private static final int EF_IS_SPARSE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_SPARSE 16
     * }
     */
    public static int EF_IS_SPARSE() {
        return EF_IS_SPARSE;
    }
    private static final int EF_IS_SYNTHETIC = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_SYNTHETIC 32
     * }
     */
    public static int EF_IS_SYNTHETIC() {
        return EF_IS_SYNTHETIC;
    }
    private static final int EF_SHARES_ALL_BLOCKS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EF_SHARES_ALL_BLOCKS 64
     * }
     */
    public static int EF_SHARES_ALL_BLOCKS() {
        return EF_SHARES_ALL_BLOCKS;
    }

    private static class __assert_rtn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__assert_rtn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor __assert_rtn$descriptor() {
        return __assert_rtn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static MethodHandle __assert_rtn$handle() {
        return __assert_rtn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static MemorySegment __assert_rtn$address() {
        return __assert_rtn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static void __assert_rtn(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = __assert_rtn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert_rtn", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t wchar_t
     * }
     */
    public static final OfInt wchar_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = Python_h.C_LONG;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static long imaxabs(long j) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", j);
            }
            return (long)mh$.invokeExact(j);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = Python_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = Python_h.C_DOUBLE;

    private static class __math_errhandling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__math_errhandling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static FunctionDescriptor __math_errhandling$descriptor() {
        return __math_errhandling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MethodHandle __math_errhandling$handle() {
        return __math_errhandling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MemorySegment __math_errhandling$address() {
        return __math_errhandling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static int __math_errhandling() {
        var mh$ = __math_errhandling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__math_errhandling");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__fpclassifyf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static FunctionDescriptor __fpclassifyf$descriptor() {
        return __fpclassifyf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MethodHandle __fpclassifyf$handle() {
        return __fpclassifyf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MemorySegment __fpclassifyf$address() {
        return __fpclassifyf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static int __fpclassifyf(float x0) {
        var mh$ = __fpclassifyf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__fpclassifyd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static FunctionDescriptor __fpclassifyd$descriptor() {
        return __fpclassifyd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MethodHandle __fpclassifyd$handle() {
        return __fpclassifyd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MemorySegment __fpclassifyd$address() {
        return __fpclassifyd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static int __fpclassifyd(double x0) {
        var mh$ = __fpclassifyd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyd", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static float acosf(float x0) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static double acos(double x0) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static float asinf(float x0) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static double asin(double x0) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static float atanf(float x0) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static double atan(double x0) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static float atan2f(float x0, float x1) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static double atan2(double x0, double x1) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static float cosf(float x0) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static double cos(double x0) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static float sinf(float x0) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static double sin(double x0) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static float tanf(float x0) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static double tan(double x0) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static float acoshf(float x0) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static double acosh(double x0) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static float asinhf(float x0) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static double asinh(double x0) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static float atanhf(float x0) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static double atanh(double x0) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static float coshf(float x0) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static double cosh(double x0) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static float sinhf(float x0) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static double sinh(double x0) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static float tanhf(float x0) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static double tanh(double x0) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static float expf(float x0) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static double exp(double x0) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static float exp2f(float x0) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static double exp2(double x0) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static float expm1f(float x0) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static double expm1(double x0) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static float logf(float x0) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static double log(double x0) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static float log10f(float x0) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static double log10(double x0) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static float log2f(float x0) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static double log2(double x0) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static float log1pf(float x0) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static double log1p(double x0) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static float logbf(float x0) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static double logb(double x0) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static float modff(float x0, MemorySegment x1) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static double modf(double x0, MemorySegment x1) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ldexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static FunctionDescriptor ldexpf$descriptor() {
        return ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MethodHandle ldexpf$handle() {
        return ldexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MemorySegment ldexpf$address() {
        return ldexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static float ldexpf(float x0, int x1) {
        var mh$ = ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static double ldexp(double x0, int x1) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("frexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static FunctionDescriptor frexpf$descriptor() {
        return frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MethodHandle frexpf$handle() {
        return frexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MemorySegment frexpf$address() {
        return frexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static float frexpf(float x0, MemorySegment x1) {
        var mh$ = frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static double frexp(double x0, MemorySegment x1) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static int ilogbf(float x0) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static int ilogb(double x0) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static float scalbnf(float x0, int x1) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static double scalbn(double x0, int x1) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static float scalblnf(float x0, long x1) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static double scalbln(double x0, long x1) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static FunctionDescriptor fabsf$descriptor() {
        return fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MethodHandle fabsf$handle() {
        return fabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MemorySegment fabsf$address() {
        return fabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static float fabsf(float x0) {
        var mh$ = fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabsf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static double fabs(double x0) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static float cbrtf(float x0) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static double cbrt(double x0) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static FunctionDescriptor hypotf$descriptor() {
        return hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MethodHandle hypotf$handle() {
        return hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MemorySegment hypotf$address() {
        return hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static float hypotf(float x0, float x1) {
        var mh$ = hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypotf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static double hypot(double x0, double x1) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static float powf(float x0, float x1) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static double pow(double x0, double x1) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static float sqrtf(float x0) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static double sqrt(double x0) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static float erff(float x0) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static double erf(double x0) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static float erfcf(float x0) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static double erfc(double x0) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static float lgammaf(float x0) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static double lgamma(double x0) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static float tgammaf(float x0) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static double tgamma(double x0) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static float ceilf(float x0) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static double ceil(double x0) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static float floorf(float x0) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static double floor(double x0) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static float nearbyintf(float x0) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static double nearbyint(double x0) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static float rintf(float x0) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static double rint(double x0) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static long lrintf(float x0) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static long lrint(double x0) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static float roundf(float x0) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static double round(double x0) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static long lroundf(float x0) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static long lround(double x0) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static long llrintf(float x0) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static long llrint(double x0) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static long llroundf(float x0) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static long llround(double x0) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static float truncf(float x0) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static double trunc(double x0) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static float fmodf(float x0, float x1) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static double fmod(double x0, double x1) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static float remainderf(float x0, float x1) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static double remainder(double x0, double x1) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static float remquof(float x0, float x1, MemorySegment x2) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static double remquo(double x0, double x1, MemorySegment x2) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static float copysignf(float x0, float x1) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static double copysign(double x0, double x1) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static float nanf(MemorySegment x0) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static double nan(MemorySegment x0) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static float nextafterf(float x0, float x1) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static double nextafter(double x0, double x1) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static float fdimf(float x0, float x1) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static double fdim(double x0, double x1) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static float fmaxf(float x0, float x1) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static double fmax(double x0, double x1) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static float fminf(float x0, float x1) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static double fmin(double x0, double x1) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static float fmaf(float x0, float x1, float x2) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static double fma(double x0, double x1, double x2) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgammaf_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *)
     * }
     */
    public static FunctionDescriptor lgammaf_r$descriptor() {
        return lgammaf_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *)
     * }
     */
    public static MethodHandle lgammaf_r$handle() {
        return lgammaf_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *)
     * }
     */
    public static MemorySegment lgammaf_r$address() {
        return lgammaf_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *)
     * }
     */
    public static float lgammaf_r(float x0, MemorySegment x1) {
        var mh$ = lgammaf_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf_r", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgamma_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *)
     * }
     */
    public static FunctionDescriptor lgamma_r$descriptor() {
        return lgamma_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *)
     * }
     */
    public static MethodHandle lgamma_r$handle() {
        return lgamma_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *)
     * }
     */
    public static MemorySegment lgamma_r$address() {
        return lgamma_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *)
     * }
     */
    public static double lgamma_r(double x0, MemorySegment x1) {
        var mh$ = lgamma_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma_r", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__exp10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static FunctionDescriptor __exp10f$descriptor() {
        return __exp10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MethodHandle __exp10f$handle() {
        return __exp10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MemorySegment __exp10f$address() {
        return __exp10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static float __exp10f(float x0) {
        var mh$ = __exp10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__exp10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static FunctionDescriptor __exp10$descriptor() {
        return __exp10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MethodHandle __exp10$handle() {
        return __exp10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MemorySegment __exp10$address() {
        return __exp10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static double __exp10(double x0) {
        var mh$ = __exp10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__cospif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static FunctionDescriptor __cospif$descriptor() {
        return __cospif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MethodHandle __cospif$handle() {
        return __cospif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MemorySegment __cospif$address() {
        return __cospif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static float __cospif(float x0) {
        var mh$ = __cospif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__cospi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static FunctionDescriptor __cospi$descriptor() {
        return __cospi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MethodHandle __cospi$handle() {
        return __cospi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MemorySegment __cospi$address() {
        return __cospi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static double __cospi(double x0) {
        var mh$ = __cospi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__sinpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static FunctionDescriptor __sinpif$descriptor() {
        return __sinpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MethodHandle __sinpif$handle() {
        return __sinpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MemorySegment __sinpif$address() {
        return __sinpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static float __sinpif(float x0) {
        var mh$ = __sinpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__sinpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static FunctionDescriptor __sinpi$descriptor() {
        return __sinpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MethodHandle __sinpi$handle() {
        return __sinpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MemorySegment __sinpi$address() {
        return __sinpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static double __sinpi(double x0) {
        var mh$ = __sinpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__tanpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static FunctionDescriptor __tanpif$descriptor() {
        return __tanpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MethodHandle __tanpif$handle() {
        return __tanpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MemorySegment __tanpif$address() {
        return __tanpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static float __tanpif(float x0) {
        var mh$ = __tanpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__tanpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static FunctionDescriptor __tanpi$descriptor() {
        return __tanpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MethodHandle __tanpi$handle() {
        return __tanpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MemorySegment __tanpi$address() {
        return __tanpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static double __tanpi(double x0) {
        var mh$ = __tanpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static double j0(double x0) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static double j1(double x0) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static double jn(int x0, double x1) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static double y0(double x0) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static double y1(double x0) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static double yn(int x0, double x1) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static FunctionDescriptor scalb$descriptor() {
        return scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MethodHandle scalb$handle() {
        return scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MemorySegment scalb$address() {
        return scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static double scalb(double x0, double x1) {
        var mh$ = scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalb", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signgam$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("signgam").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static OfInt signgam$layout() {
        return signgam$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static MemorySegment signgam$segment() {
        return signgam$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static int signgam() {
        return signgam$constants.SEGMENT.get(signgam$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static void signgam(int varValue) {
        signgam$constants.SEGMENT.set(signgam$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ct_rune_t ct_rune_t
     * }
     */
    public static final OfInt ct_rune_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_rune_t rune_t
     * }
     */
    public static final OfInt rune_t = Python_h.C_INT;

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static int renameat(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renamex_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("renamex_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renamex_np$descriptor() {
        return renamex_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle renamex_np$handle() {
        return renamex_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment renamex_np$address() {
        return renamex_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static int renamex_np(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = renamex_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renamex_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("renameatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renameatx_np$descriptor() {
        return renameatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MethodHandle renameatx_np$handle() {
        return renameatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MemorySegment renameatx_np$address() {
        return renameatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static int renameatx_np(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = renameatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameatx_np", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

