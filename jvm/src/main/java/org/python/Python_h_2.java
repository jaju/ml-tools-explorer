// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h_2 extends Python_h_3 {

    Python_h_2() {
        // Should not be called directly
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int printf(const char *restrict, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int printf(const char *restrict, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t fpos_t
     * }
     */
    public static final OfLong fpos_t = Python_h.C_LONG_LONG;

    private static class __stdinp$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("__stdinp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static AddressLayout __stdinp$layout() {
        return __stdinp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp$segment() {
        return __stdinp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp() {
        return __stdinp$constants.SEGMENT.get(__stdinp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static void __stdinp(MemorySegment varValue) {
        __stdinp$constants.SEGMENT.set(__stdinp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stdoutp$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("__stdoutp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static AddressLayout __stdoutp$layout() {
        return __stdoutp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp$segment() {
        return __stdoutp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp() {
        return __stdoutp$constants.SEGMENT.get(__stdoutp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static void __stdoutp(MemorySegment varValue) {
        __stdoutp$constants.SEGMENT.set(__stdoutp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stderrp$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("__stderrp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static AddressLayout __stderrp$layout() {
        return __stderrp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp$segment() {
        return __stderrp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp() {
        return __stderrp$constants.SEGMENT.get(__stderrp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static void __stderrp(MemorySegment varValue) {
        __stderrp$constants.SEGMENT.set(__stderrp$constants.LAYOUT, 0L, varValue);
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static void clearerr(MemorySegment x0) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static int fclose(MemorySegment x0) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static int feof(MemorySegment x0) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static int ferror(MemorySegment x0) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static int fflush(MemorySegment x0) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static int fgetc(MemorySegment x0) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static int fgetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MemorySegment fgets(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fopen$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fprintf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fprintf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static int fputc(int x0, MemorySegment x1) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static int fputs(MemorySegment x0, MemorySegment x1) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fscanf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fscanf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static int fseek(MemorySegment x0, long x1, int x2) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static int fsetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static long ftell(MemorySegment x0) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static int getc(MemorySegment x0) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static FunctionDescriptor gets$descriptor() {
        return gets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MethodHandle gets$handle() {
        return gets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets$address() {
        return gets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets(MemorySegment x0) {
        var mh$ = gets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static void perror(MemorySegment x0) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static int putc(int x0, MemorySegment x1) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static int putchar(int x0) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static int puts(MemorySegment x0) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static int remove(MemorySegment x0) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static void rewind(MemorySegment x0) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int scanf(const char *restrict, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int scanf(const char *restrict, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static void setbuf(MemorySegment x0, MemorySegment x1) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static int setvbuf(MemorySegment x0, MemorySegment x1, int x2, long x3) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sprintf(char *restrict, const char *restrict, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sprintf(char *restrict, const char *restrict, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sscanf(const char *restrict, const char *restrict, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sscanf(const char *restrict, const char *restrict, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static int ungetc(int x0, MemorySegment x1) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static int vfprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static int vprintf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static int vsprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid(MemorySegment x0) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdopen$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen(int x0, MemorySegment x1) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static int fileno(MemorySegment x0) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static int pclose(MemorySegment x0) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("popen$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen(MemorySegment x0, MemorySegment x1) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __srget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__srget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static FunctionDescriptor __srget$descriptor() {
        return __srget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MethodHandle __srget$handle() {
        return __srget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MemorySegment __srget$address() {
        return __srget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static int __srget(MemorySegment x0) {
        var mh$ = __srget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__srget", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __svfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__svfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static FunctionDescriptor __svfscanf$descriptor() {
        return __svfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MethodHandle __svfscanf$handle() {
        return __svfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MemorySegment __svfscanf$address() {
        return __svfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static int __svfscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __svfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__svfscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __swbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__swbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static FunctionDescriptor __swbuf$descriptor() {
        return __swbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MethodHandle __swbuf$handle() {
        return __swbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MemorySegment __swbuf$address() {
        return __swbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static int __swbuf(int x0, MemorySegment x1) {
        var mh$ = __swbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__swbuf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static void flockfile(MemorySegment x0) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static int ftrylockfile(MemorySegment x0) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static void funlockfile(MemorySegment x0) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static int getc_unlocked(MemorySegment x0) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static int putc_unlocked(int x0, MemorySegment x1) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static int putchar_unlocked(int x0) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static int getw(MemorySegment x0) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static int putw(int x0, MemorySegment x1) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __prefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __prefix);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = Python_h.C_LONG_LONG;

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __offset, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __offset, __whence);
            }
            return (int)mh$.invokeExact(__stream, __offset, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __str, long __size, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __str, __size, __format, x3);
                }
                return (int) spreader.invokeExact(__str, __size, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static int vfscanf(MemorySegment __stream, MemorySegment __format, MemorySegment x2) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __stream, __format, x2);
            }
            return (int)mh$.invokeExact(__stream, __format, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment x1) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, x1);
            }
            return (int)mh$.invokeExact(__format, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static int vsnprintf(MemorySegment __str, long __size, MemorySegment __format, MemorySegment x3) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __str, __size, __format, x3);
            }
            return (int)mh$.invokeExact(__str, __size, __format, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static int vsscanf(MemorySegment __str, MemorySegment __format, MemorySegment x2) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __str, __format, x2);
            }
            return (int)mh$.invokeExact(__str, __format, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = Python_h.C_LONG;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int dprintf(int, const char *restrict, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int dprintf(int, const char *restrict, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static int vdprintf(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __linep, MemorySegment __linecapp, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __linep, __linecapp, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __linep, MemorySegment __linecapp, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __linep, __linecapp, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __buf, long __size, MemorySegment __mode) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __buf, __size, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__buf, __size, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufp, MemorySegment __sizep) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufp, __sizep);
            }
            return (MemorySegment)mh$.invokeExact(__bufp, __sizep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sys_nerr$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("sys_nerr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static OfInt sys_nerr$layout() {
        return sys_nerr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static MemorySegment sys_nerr$segment() {
        return sys_nerr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static int sys_nerr() {
        return sys_nerr$constants.SEGMENT.get(sys_nerr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static void sys_nerr(int varValue) {
        sys_nerr$constants.SEGMENT.set(sys_nerr$constants.LAYOUT, 0L, varValue);
    }

    private static class sys_errlist$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_POINTER);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("sys_errlist").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static SequenceLayout sys_errlist$layout() {
        return sys_errlist$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static long[] sys_errlist$dimensions() {
        return sys_errlist$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static MemorySegment sys_errlist() {
        return sys_errlist$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static void sys_errlist(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, sys_errlist$constants.SEGMENT, 0L, sys_errlist$constants.LAYOUT.byteSize());
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int asprintf(char **restrict, const char *restrict, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int asprintf(char **restrict, const char *restrict, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ctermid_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ctermid_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static FunctionDescriptor ctermid_r$descriptor() {
        return ctermid_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MethodHandle ctermid_r$handle() {
        return ctermid_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r$address() {
        return ctermid_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r(MemorySegment x0) {
        var mh$ = ctermid_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid_r", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static FunctionDescriptor fgetln$descriptor() {
        return fgetln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MethodHandle fgetln$handle() {
        return fgetln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MemorySegment fgetln$address() {
        return fgetln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MemorySegment fgetln(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetln", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmtcheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmtcheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static FunctionDescriptor fmtcheck$descriptor() {
        return fmtcheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MethodHandle fmtcheck$handle() {
        return fmtcheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck$address() {
        return fmtcheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck(MemorySegment x0, MemorySegment x1) {
        var mh$ = fmtcheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmtcheck", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpurge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fpurge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static FunctionDescriptor fpurge$descriptor() {
        return fpurge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MethodHandle fpurge$handle() {
        return fpurge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MemorySegment fpurge$address() {
        return fpurge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static int fpurge(MemorySegment x0) {
        var mh$ = fpurge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpurge", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static void setbuffer(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static int setlinebuf(MemorySegment x0) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static int vasprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("funopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static FunctionDescriptor funopen$descriptor() {
        return funopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MethodHandle funopen$handle() {
        return funopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen$address() {
        return funopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = funopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funopen", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __sprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_INT,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("__sprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __sprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
         * }
         */
        public static __sprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __sprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, int x1, long x2, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__sprintf_chk", x0, x1, x2, x3, x4);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __snprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __snprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_INT,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("__snprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __snprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __snprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, ...)
         * }
         */
        public static __snprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __snprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long x1, int x2, long x3, MemorySegment x4, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__snprintf_chk", x0, x1, x2, x3, x4, x5);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3, x4, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __vsprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__vsprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsprintf_chk$descriptor() {
        return __vsprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsprintf_chk$handle() {
        return __vsprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsprintf_chk$address() {
        return __vsprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsprintf_chk(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = __vsprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsprintf_chk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __vsnprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__vsnprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsnprintf_chk$descriptor() {
        return __vsnprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsnprintf_chk$handle() {
        return __vsnprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsnprintf_chk$address() {
        return __vsnprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsnprintf_chk(MemorySegment x0, long x1, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = __vsnprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsnprintf_chk", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_clock_t clock_t
     * }
     */
    public static final OfLong clock_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = Python_h.C_LONG;

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_POINTER);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    private static class getdate_err$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("getdate_err").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static OfInt getdate_err$layout() {
        return getdate_err$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static MemorySegment getdate_err$segment() {
        return getdate_err$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static int getdate_err() {
        return getdate_err$constants.SEGMENT.get(getdate_err$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static void getdate_err(int varValue) {
        getdate_err$constants.SEGMENT.set(getdate_err$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = Python_h.C_LONG;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime(MemorySegment x0) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime(MemorySegment x0) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static double difftime(long x0, long x1) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static FunctionDescriptor getdate$descriptor() {
        return getdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MethodHandle getdate$handle() {
        return getdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate$address() {
        return getdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate(MemorySegment x0) {
        var mh$ = getdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime(MemorySegment x0) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime(MemorySegment x0) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static long mktime(MemorySegment x0) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static long strftime(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strptime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strptime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strptime$descriptor() {
        return strptime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle strptime$handle() {
        return strptime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime$address() {
        return strptime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strptime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strptime", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static long time(MemorySegment x0) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix2time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("posix2time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static FunctionDescriptor posix2time$descriptor() {
        return posix2time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MethodHandle posix2time$handle() {
        return posix2time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MemorySegment posix2time$address() {
        return posix2time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static long posix2time(long x0) {
        var mh$ = posix2time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix2time", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzsetwall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tzsetwall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static FunctionDescriptor tzsetwall$descriptor() {
        return tzsetwall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MethodHandle tzsetwall$handle() {
        return tzsetwall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MemorySegment tzsetwall$address() {
        return tzsetwall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static void tzsetwall() {
        var mh$ = tzsetwall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzsetwall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time2posix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("time2posix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static FunctionDescriptor time2posix$descriptor() {
        return time2posix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MethodHandle time2posix$handle() {
        return time2posix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MemorySegment time2posix$address() {
        return time2posix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static long time2posix(long x0) {
        var mh$ = time2posix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time2posix", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static long timelocal(MemorySegment x0) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static long timegm(MemorySegment x0) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static int nanosleep(MemorySegment __rqtp, MemorySegment __rmtp) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __rqtp, __rmtp);
            }
            return (int)mh$.invokeExact(__rqtp, __rmtp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _CLOCK_REALTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_REALTIME = 0
     * }
     */
    public static int _CLOCK_REALTIME() {
        return _CLOCK_REALTIME;
    }
    private static final int _CLOCK_MONOTONIC = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC = 6
     * }
     */
    public static int _CLOCK_MONOTONIC() {
        return _CLOCK_MONOTONIC;
    }
    private static final int _CLOCK_MONOTONIC_RAW = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW = 4
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW() {
        return _CLOCK_MONOTONIC_RAW;
    }
    private static final int _CLOCK_MONOTONIC_RAW_APPROX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW_APPROX = 5
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW_APPROX() {
        return _CLOCK_MONOTONIC_RAW_APPROX;
    }
    private static final int _CLOCK_UPTIME_RAW = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW = 8
     * }
     */
    public static int _CLOCK_UPTIME_RAW() {
        return _CLOCK_UPTIME_RAW;
    }
    private static final int _CLOCK_UPTIME_RAW_APPROX = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW_APPROX = 9
     * }
     */
    public static int _CLOCK_UPTIME_RAW_APPROX() {
        return _CLOCK_UPTIME_RAW_APPROX;
    }
    private static final int _CLOCK_PROCESS_CPUTIME_ID = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_PROCESS_CPUTIME_ID = 12
     * }
     */
    public static int _CLOCK_PROCESS_CPUTIME_ID() {
        return _CLOCK_PROCESS_CPUTIME_ID;
    }
    private static final int _CLOCK_THREAD_CPUTIME_ID = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_THREAD_CPUTIME_ID = 16
     * }
     */
    public static int _CLOCK_THREAD_CPUTIME_ID() {
        return _CLOCK_THREAD_CPUTIME_ID;
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime_nsec_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock_gettime_nsec_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static FunctionDescriptor clock_gettime_nsec_np$descriptor() {
        return clock_gettime_nsec_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MethodHandle clock_gettime_nsec_np$handle() {
        return clock_gettime_nsec_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MemorySegment clock_gettime_nsec_np$address() {
        return clock_gettime_nsec_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static long clock_gettime_nsec_np(int __clock_id) {
        var mh$ = clock_gettime_nsec_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime_nsec_np", __clock_id);
            }
            return (long)mh$.invokeExact(__clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static int timespec_get(MemorySegment ts, int base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", ts, base);
            }
            return (int)mh$.invokeExact(ts, base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_wint_t wint_t
     * }
     */
    public static final OfInt wint_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wctype_t wctype_t
     * }
     */
    public static final OfInt wctype_t = Python_h.C_INT;

    private static class _DefaultRuneLocale$constants {
        public static final GroupLayout LAYOUT = _RuneLocale.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_DefaultRuneLocale").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _RuneLocale _DefaultRuneLocale
     * }
     */
    public static GroupLayout _DefaultRuneLocale$layout() {
        return _DefaultRuneLocale$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _RuneLocale _DefaultRuneLocale
     * }
     */
    public static MemorySegment _DefaultRuneLocale() {
        return _DefaultRuneLocale$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _RuneLocale _DefaultRuneLocale
     * }
     */
    public static void _DefaultRuneLocale(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _DefaultRuneLocale$constants.SEGMENT, 0L, _DefaultRuneLocale$constants.LAYOUT.byteSize());
    }

    private static class _CurrentRuneLocale$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_CurrentRuneLocale").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _RuneLocale *_CurrentRuneLocale
     * }
     */
    public static AddressLayout _CurrentRuneLocale$layout() {
        return _CurrentRuneLocale$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern _RuneLocale *_CurrentRuneLocale
     * }
     */
    public static MemorySegment _CurrentRuneLocale$segment() {
        return _CurrentRuneLocale$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _RuneLocale *_CurrentRuneLocale
     * }
     */
    public static MemorySegment _CurrentRuneLocale() {
        return _CurrentRuneLocale$constants.SEGMENT.get(_CurrentRuneLocale$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _RuneLocale *_CurrentRuneLocale
     * }
     */
    public static void _CurrentRuneLocale(MemorySegment varValue) {
        _CurrentRuneLocale$constants.SEGMENT.set(_CurrentRuneLocale$constants.LAYOUT, 0L, varValue);
    }

    private static class ___runetype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___runetype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long ___runetype(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor ___runetype$descriptor() {
        return ___runetype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long ___runetype(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle ___runetype$handle() {
        return ___runetype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long ___runetype(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment ___runetype$address() {
        return ___runetype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long ___runetype(__darwin_ct_rune_t)
     * }
     */
    public static long ___runetype(int x0) {
        var mh$ = ___runetype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___runetype", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor ___tolower$descriptor() {
        return ___tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle ___tolower$handle() {
        return ___tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment ___tolower$address() {
        return ___tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t)
     * }
     */
    public static int ___tolower(int x0) {
        var mh$ = ___tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___tolower", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor ___toupper$descriptor() {
        return ___toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle ___toupper$handle() {
        return ___toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment ___toupper$address() {
        return ___toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t)
     * }
     */
    public static int ___toupper(int x0) {
        var mh$ = ___toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___toupper", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __maskrune {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__maskrune");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __maskrune(__darwin_ct_rune_t, unsigned long)
     * }
     */
    public static FunctionDescriptor __maskrune$descriptor() {
        return __maskrune.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __maskrune(__darwin_ct_rune_t, unsigned long)
     * }
     */
    public static MethodHandle __maskrune$handle() {
        return __maskrune.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __maskrune(__darwin_ct_rune_t, unsigned long)
     * }
     */
    public static MemorySegment __maskrune$address() {
        return __maskrune.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __maskrune(__darwin_ct_rune_t, unsigned long)
     * }
     */
    public static int __maskrune(int x0, long x1) {
        var mh$ = __maskrune.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__maskrune", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __toupper(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor __toupper$descriptor() {
        return __toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __toupper(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle __toupper$handle() {
        return __toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __toupper(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment __toupper$address() {
        return __toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __darwin_ct_rune_t __toupper(__darwin_ct_rune_t)
     * }
     */
    public static int __toupper(int x0) {
        var mh$ = __toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__toupper", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __tolower(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor __tolower$descriptor() {
        return __tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __tolower(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle __tolower$handle() {
        return __tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __tolower(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment __tolower$address() {
        return __tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __darwin_ct_rune_t __tolower(__darwin_ct_rune_t)
     * }
     */
    public static int __tolower(int x0) {
        var mh$ = __tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tolower", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wctype_t wctype(const char *)
     * }
     */
    public static FunctionDescriptor wctype$descriptor() {
        return wctype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wctype_t wctype(const char *)
     * }
     */
    public static MethodHandle wctype$handle() {
        return wctype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wctype_t wctype(const char *)
     * }
     */
    public static MemorySegment wctype$address() {
        return wctype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wctype_t wctype(const char *)
     * }
     */
    public static int wctype(MemorySegment x0) {
        var mh$ = wctype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctype", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("btowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t btowc(int)
     * }
     */
    public static FunctionDescriptor btowc$descriptor() {
        return btowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t btowc(int)
     * }
     */
    public static MethodHandle btowc$handle() {
        return btowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t btowc(int)
     * }
     */
    public static MemorySegment btowc$address() {
        return btowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t btowc(int)
     * }
     */
    public static int btowc(int x0) {
        var mh$ = btowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btowc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *)
     * }
     */
    public static FunctionDescriptor fgetwc$descriptor() {
        return fgetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *)
     * }
     */
    public static MethodHandle fgetwc$handle() {
        return fgetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *)
     * }
     */
    public static MemorySegment fgetwc$address() {
        return fgetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *)
     * }
     */
    public static int fgetwc(MemorySegment x0) {
        var mh$ = fgetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetwc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *restrict, int, FILE *restrict)
     * }
     */
    public static FunctionDescriptor fgetws$descriptor() {
        return fgetws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *restrict, int, FILE *restrict)
     * }
     */
    public static MethodHandle fgetws$handle() {
        return fgetws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *restrict, int, FILE *restrict)
     * }
     */
    public static MemorySegment fgetws$address() {
        return fgetws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *restrict, int, FILE *restrict)
     * }
     */
    public static MemorySegment fgetws(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = fgetws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetws", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t, FILE *)
     * }
     */
    public static FunctionDescriptor fputwc$descriptor() {
        return fputwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t, FILE *)
     * }
     */
    public static MethodHandle fputwc$handle() {
        return fputwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t, FILE *)
     * }
     */
    public static MemorySegment fputwc$address() {
        return fputwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t, FILE *)
     * }
     */
    public static int fputwc(int x0, MemorySegment x1) {
        var mh$ = fputwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputwc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor fputws$descriptor() {
        return fputws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle fputws$handle() {
        return fputws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment fputws$address() {
        return fputws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputws(const wchar_t *restrict, FILE *restrict)
     * }
     */
    public static int fputws(MemorySegment x0, MemorySegment x1) {
        var mh$ = fputws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputws", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fwide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fwide(FILE *, int)
     * }
     */
    public static FunctionDescriptor fwide$descriptor() {
        return fwide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fwide(FILE *, int)
     * }
     */
    public static MethodHandle fwide$handle() {
        return fwide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fwide(FILE *, int)
     * }
     */
    public static MemorySegment fwide$address() {
        return fwide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fwide(FILE *, int)
     * }
     */
    public static int fwide(MemorySegment x0, int x1) {
        var mh$ = fwide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwide", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fwprintf(FILE *restrict, const wchar_t *restrict, ...)
     * }
     */
    public static class fwprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("fwprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fwprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fwprintf(FILE *restrict, const wchar_t *restrict, ...)
         * }
         */
        public static fwprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fwprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fwprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fwscanf(FILE *restrict, const wchar_t *restrict, ...)
     * }
     */
    public static class fwscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("fwscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fwscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fwscanf(FILE *restrict, const wchar_t *restrict, ...)
         * }
         */
        public static fwscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fwscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fwscanf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class getwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *)
     * }
     */
    public static FunctionDescriptor getwc$descriptor() {
        return getwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *)
     * }
     */
    public static MethodHandle getwc$handle() {
        return getwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *)
     * }
     */
    public static MemorySegment getwc$address() {
        return getwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwc(FILE *)
     * }
     */
    public static int getwc(MemorySegment x0) {
        var mh$ = getwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static FunctionDescriptor getwchar$descriptor() {
        return getwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MethodHandle getwchar$handle() {
        return getwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MemorySegment getwchar$address() {
        return getwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static int getwchar() {
        var mh$ = getwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbrlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor mbrlen$descriptor() {
        return mbrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle mbrlen$handle() {
        return mbrlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment mbrlen$address() {
        return mbrlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbrlen(const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static long mbrlen(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = mbrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbrlen", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbrtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbrtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *restrict, const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor mbrtowc$descriptor() {
        return mbrtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *restrict, const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle mbrtowc$handle() {
        return mbrtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *restrict, const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment mbrtowc$address() {
        return mbrtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *restrict, const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static long mbrtowc(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = mbrtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbrtowc", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbsinit(const mbstate_t *)
     * }
     */
    public static FunctionDescriptor mbsinit$descriptor() {
        return mbsinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbsinit(const mbstate_t *)
     * }
     */
    public static MethodHandle mbsinit$handle() {
        return mbsinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbsinit(const mbstate_t *)
     * }
     */
    public static MemorySegment mbsinit$address() {
        return mbsinit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbsinit(const mbstate_t *)
     * }
     */
    public static int mbsinit(MemorySegment x0) {
        var mh$ = mbsinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsinit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsrtowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsrtowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *restrict, const char **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor mbsrtowcs$descriptor() {
        return mbsrtowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *restrict, const char **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle mbsrtowcs$handle() {
        return mbsrtowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *restrict, const char **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment mbsrtowcs$address() {
        return mbsrtowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *restrict, const char **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static long mbsrtowcs(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = mbsrtowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsrtowcs", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t, FILE *)
     * }
     */
    public static FunctionDescriptor putwc$descriptor() {
        return putwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t, FILE *)
     * }
     */
    public static MethodHandle putwc$handle() {
        return putwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t, FILE *)
     * }
     */
    public static MemorySegment putwc$address() {
        return putwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwc(wchar_t, FILE *)
     * }
     */
    public static int putwc(int x0, MemorySegment x1) {
        var mh$ = putwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t)
     * }
     */
    public static FunctionDescriptor putwchar$descriptor() {
        return putwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t)
     * }
     */
    public static MethodHandle putwchar$handle() {
        return putwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t)
     * }
     */
    public static MemorySegment putwchar$address() {
        return putwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t)
     * }
     */
    public static int putwchar(int x0) {
        var mh$ = putwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwchar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int swprintf(wchar_t *restrict, size_t, const wchar_t *restrict, ...)
     * }
     */
    public static class swprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("swprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private swprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int swprintf(wchar_t *restrict, size_t, const wchar_t *restrict, ...)
         * }
         */
        public static swprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new swprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long x1, MemorySegment x2, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("swprintf", x0, x1, x2, x3);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int swscanf(const wchar_t *restrict, const wchar_t *restrict, ...)
     * }
     */
    public static class swscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("swscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private swscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int swscanf(const wchar_t *restrict, const wchar_t *restrict, ...)
         * }
         */
        public static swscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new swscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("swscanf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ungetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ungetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t, FILE *)
     * }
     */
    public static FunctionDescriptor ungetwc$descriptor() {
        return ungetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t, FILE *)
     * }
     */
    public static MethodHandle ungetwc$handle() {
        return ungetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t, FILE *)
     * }
     */
    public static MemorySegment ungetwc$address() {
        return ungetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t, FILE *)
     * }
     */
    public static int ungetwc(int x0, MemorySegment x1) {
        var mh$ = ungetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetwc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfwprintf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vfwprintf$descriptor() {
        return vfwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfwprintf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vfwprintf$handle() {
        return vfwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfwprintf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vfwprintf$address() {
        return vfwprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfwprintf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vfwprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfwprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vswprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vswprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vswprintf(wchar_t *restrict, size_t, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vswprintf$descriptor() {
        return vswprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vswprintf(wchar_t *restrict, size_t, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vswprintf$handle() {
        return vswprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vswprintf(wchar_t *restrict, size_t, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vswprintf$address() {
        return vswprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vswprintf(wchar_t *restrict, size_t, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vswprintf(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = vswprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vswprintf", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vwprintf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vwprintf$descriptor() {
        return vwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vwprintf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vwprintf$handle() {
        return vwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vwprintf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vwprintf$address() {
        return vwprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vwprintf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vwprintf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vwprintf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcrtomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcrtomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *restrict, wchar_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor wcrtomb$descriptor() {
        return wcrtomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *restrict, wchar_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle wcrtomb$handle() {
        return wcrtomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *restrict, wchar_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment wcrtomb$address() {
        return wcrtomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcrtomb(char *restrict, wchar_t, mbstate_t *restrict)
     * }
     */
    public static long wcrtomb(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wcrtomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcrtomb", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static FunctionDescriptor wcscat$descriptor() {
        return wcscat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MethodHandle wcscat$handle() {
        return wcscat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcscat$address() {
        return wcscat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcscat(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *wcschr(const wchar_t *, wchar_t)
     * }
     */
    public static FunctionDescriptor wcschr$descriptor() {
        return wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *wcschr(const wchar_t *, wchar_t)
     * }
     */
    public static MethodHandle wcschr$handle() {
        return wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *wcschr(const wchar_t *, wchar_t)
     * }
     */
    public static MemorySegment wcschr$address() {
        return wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *wcschr(const wchar_t *, wchar_t)
     * }
     */
    public static MemorySegment wcschr(MemorySegment x0, int x1) {
        var mh$ = wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcschr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcscmp$descriptor() {
        return wcscmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcscmp$handle() {
        return wcscmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcscmp$address() {
        return wcscmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static int wcscmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcscoll$descriptor() {
        return wcscoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcscoll$handle() {
        return wcscoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcscoll$address() {
        return wcscoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *, const wchar_t *)
     * }
     */
    public static int wcscoll(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscoll", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static FunctionDescriptor wcscpy$descriptor() {
        return wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MethodHandle wcscpy$handle() {
        return wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcscpy$address() {
        return wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcscpy(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcscspn$descriptor() {
        return wcscspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcscspn$handle() {
        return wcscspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcscspn$address() {
        return wcscspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static long wcscspn(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscspn", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *restrict, size_t, const wchar_t *restrict, const struct tm *restrict)
     * }
     */
    public static FunctionDescriptor wcsftime$descriptor() {
        return wcsftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *restrict, size_t, const wchar_t *restrict, const struct tm *restrict)
     * }
     */
    public static MethodHandle wcsftime$handle() {
        return wcsftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *restrict, size_t, const wchar_t *restrict, const struct tm *restrict)
     * }
     */
    public static MemorySegment wcsftime$address() {
        return wcsftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *restrict, size_t, const wchar_t *restrict, const struct tm *restrict)
     * }
     */
    public static long wcsftime(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = wcsftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsftime", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcslen(const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcslen$descriptor() {
        return wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcslen(const wchar_t *)
     * }
     */
    public static MethodHandle wcslen$handle() {
        return wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long wcslen(const wchar_t *)
     * }
     */
    public static MemorySegment wcslen$address() {
        return wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long wcslen(const wchar_t *)
     * }
     */
    public static long wcslen(MemorySegment x0) {
        var mh$ = wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslen", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcsncat$descriptor() {
        return wcsncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcsncat$handle() {
        return wcsncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsncat$address() {
        return wcsncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsncat(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcsncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcsncmp$descriptor() {
        return wcsncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcsncmp$handle() {
        return wcsncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcsncmp$address() {
        return wcsncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static int wcsncmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcsncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcsncpy$descriptor() {
        return wcsncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcsncpy$handle() {
        return wcsncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsncpy$address() {
        return wcsncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsncpy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcsncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcspbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcspbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcspbrk$descriptor() {
        return wcspbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcspbrk$handle() {
        return wcspbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcspbrk$address() {
        return wcspbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcspbrk(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcspbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcspbrk", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *, wchar_t)
     * }
     */
    public static FunctionDescriptor wcsrchr$descriptor() {
        return wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *, wchar_t)
     * }
     */
    public static MethodHandle wcsrchr$handle() {
        return wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *, wchar_t)
     * }
     */
    public static MemorySegment wcsrchr$address() {
        return wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *, wchar_t)
     * }
     */
    public static MemorySegment wcsrchr(MemorySegment x0, int x1) {
        var mh$ = wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrchr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrtombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrtombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *restrict, const wchar_t **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor wcsrtombs$descriptor() {
        return wcsrtombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *restrict, const wchar_t **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle wcsrtombs$handle() {
        return wcsrtombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *restrict, const wchar_t **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment wcsrtombs$address() {
        return wcsrtombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsrtombs(char *restrict, const wchar_t **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static long wcsrtombs(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = wcsrtombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrtombs", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcsspn$descriptor() {
        return wcsspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcsspn$handle() {
        return wcsspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcsspn$address() {
        return wcsspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static long wcsspn(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcsspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsspn", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static FunctionDescriptor wcsstr$descriptor() {
        return wcsstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MethodHandle wcsstr$handle() {
        return wcsstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcsstr$address() {
        return wcsstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcsstr(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcsstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsstr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcsxfrm$descriptor() {
        return wcsxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcsxfrm$handle() {
        return wcsxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsxfrm$address() {
        return wcsxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcsxfrm(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcsxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsxfrm", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctob(wint_t)
     * }
     */
    public static FunctionDescriptor wctob$descriptor() {
        return wctob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctob(wint_t)
     * }
     */
    public static MethodHandle wctob$handle() {
        return wctob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctob(wint_t)
     * }
     */
    public static MemorySegment wctob$address() {
        return wctob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctob(wint_t)
     * }
     */
    public static int wctob(int x0) {
        var mh$ = wctob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctob", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static FunctionDescriptor wcstod$descriptor() {
        return wcstod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MethodHandle wcstod$handle() {
        return wcstod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MemorySegment wcstod$address() {
        return wcstod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double wcstod(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static double wcstod(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcstod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *restrict, const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static FunctionDescriptor wcstok$descriptor() {
        return wcstok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *restrict, const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MethodHandle wcstok$handle() {
        return wcstok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *restrict, const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MemorySegment wcstok$address() {
        return wcstok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *restrict, const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MemorySegment wcstok(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = wcstok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static FunctionDescriptor wcstol$descriptor() {
        return wcstol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MethodHandle wcstol$handle() {
        return wcstol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MemorySegment wcstol$address() {
        return wcstol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long wcstol(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static long wcstol(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wcstol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstol", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static FunctionDescriptor wcstoul$descriptor() {
        return wcstoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MethodHandle wcstoul$handle() {
        return wcstoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MemorySegment wcstoul$address() {
        return wcstoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static long wcstoul(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wcstoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoul", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *wmemchr(const wchar_t *, wchar_t, size_t)
     * }
     */
    public static FunctionDescriptor wmemchr$descriptor() {
        return wmemchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *wmemchr(const wchar_t *, wchar_t, size_t)
     * }
     */
    public static MethodHandle wmemchr$handle() {
        return wmemchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *wmemchr(const wchar_t *, wchar_t, size_t)
     * }
     */
    public static MemorySegment wmemchr$address() {
        return wmemchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *wmemchr(const wchar_t *, wchar_t, size_t)
     * }
     */
    public static MemorySegment wmemchr(MemorySegment x0, int x1, long x2) {
        var mh$ = wmemchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemchr", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wmemcmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wmemcmp$descriptor() {
        return wmemcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wmemcmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wmemcmp$handle() {
        return wmemcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wmemcmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wmemcmp$address() {
        return wmemcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wmemcmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static int wmemcmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wmemcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemcmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *wmemcpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wmemcpy$descriptor() {
        return wmemcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *wmemcpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wmemcpy$handle() {
        return wmemcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *wmemcpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wmemcpy$address() {
        return wmemcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *wmemcpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wmemcpy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wmemcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemcpy", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *wmemmove(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wmemmove$descriptor() {
        return wmemmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *wmemmove(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wmemmove$handle() {
        return wmemmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *wmemmove(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wmemmove$address() {
        return wmemmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *wmemmove(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wmemmove(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wmemmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemmove", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wmemset(wchar_t *, wchar_t, size_t)
     * }
     */
    public static FunctionDescriptor wmemset$descriptor() {
        return wmemset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wmemset(wchar_t *, wchar_t, size_t)
     * }
     */
    public static MethodHandle wmemset$handle() {
        return wmemset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wmemset(wchar_t *, wchar_t, size_t)
     * }
     */
    public static MemorySegment wmemset$address() {
        return wmemset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wmemset(wchar_t *, wchar_t, size_t)
     * }
     */
    public static MemorySegment wmemset(MemorySegment x0, int x1, long x2) {
        var mh$ = wmemset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemset", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wprintf(const wchar_t *restrict, ...)
     * }
     */
    public static class wprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("wprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wprintf(const wchar_t *restrict, ...)
         * }
         */
        public static wprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wprintf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wscanf(const wchar_t *restrict, ...)
     * }
     */
    public static class wscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("wscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wscanf(const wchar_t *restrict, ...)
         * }
         */
        public static wscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wscanf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class wcswidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcswidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcswidth(const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcswidth$descriptor() {
        return wcswidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcswidth(const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcswidth$handle() {
        return wcswidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcswidth(const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcswidth$address() {
        return wcswidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcswidth(const wchar_t *, size_t)
     * }
     */
    public static int wcswidth(MemorySegment x0, long x1) {
        var mh$ = wcswidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcswidth", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcwidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcwidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcwidth(wchar_t)
     * }
     */
    public static FunctionDescriptor wcwidth$descriptor() {
        return wcwidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcwidth(wchar_t)
     * }
     */
    public static MethodHandle wcwidth$handle() {
        return wcwidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcwidth(wchar_t)
     * }
     */
    public static MemorySegment wcwidth$address() {
        return wcwidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcwidth(wchar_t)
     * }
     */
    public static int wcwidth(int x0) {
        var mh$ = wcwidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcwidth", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfwscanf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vfwscanf$descriptor() {
        return vfwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfwscanf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vfwscanf$handle() {
        return vfwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfwscanf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vfwscanf$address() {
        return vfwscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfwscanf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vfwscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfwscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vswscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vswscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vswscanf(const wchar_t *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vswscanf$descriptor() {
        return vswscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vswscanf(const wchar_t *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vswscanf$handle() {
        return vswscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vswscanf(const wchar_t *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vswscanf$address() {
        return vswscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vswscanf(const wchar_t *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vswscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vswscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vswscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vwscanf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vwscanf$descriptor() {
        return vwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vwscanf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vwscanf$handle() {
        return vwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vwscanf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vwscanf$address() {
        return vwscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vwscanf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vwscanf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vwscanf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static FunctionDescriptor wcstof$descriptor() {
        return wcstof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MethodHandle wcstof$handle() {
        return wcstof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MemorySegment wcstof$address() {
        return wcstof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float wcstof(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static float wcstof(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcstof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static FunctionDescriptor wcstoll$descriptor() {
        return wcstoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MethodHandle wcstoll$handle() {
        return wcstoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MemorySegment wcstoll$address() {
        return wcstoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static long wcstoll(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wcstoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoll", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static FunctionDescriptor wcstoull$descriptor() {
        return wcstoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MethodHandle wcstoull$handle() {
        return wcstoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MemorySegment wcstoull$address() {
        return wcstoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static long wcstoull(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wcstoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoull", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsnrtowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsnrtowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbsnrtowcs(wchar_t *restrict, const char **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor mbsnrtowcs$descriptor() {
        return mbsnrtowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbsnrtowcs(wchar_t *restrict, const char **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle mbsnrtowcs$handle() {
        return mbsnrtowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbsnrtowcs(wchar_t *restrict, const char **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment mbsnrtowcs$address() {
        return mbsnrtowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbsnrtowcs(wchar_t *restrict, const char **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static long mbsnrtowcs(MemorySegment x0, MemorySegment x1, long x2, long x3, MemorySegment x4) {
        var mh$ = mbsnrtowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsnrtowcs", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcpcpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static FunctionDescriptor wcpcpy$descriptor() {
        return wcpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcpcpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MethodHandle wcpcpy$handle() {
        return wcpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcpcpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcpcpy$address() {
        return wcpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcpcpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcpcpy(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcpcpy", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcpncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcpncpy$descriptor() {
        return wcpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcpncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcpncpy$handle() {
        return wcpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcpncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcpncpy$address() {
        return wcpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcpncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcpncpy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcpncpy", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcsdup$descriptor() {
        return wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *)
     * }
     */
    public static MethodHandle wcsdup$handle() {
        return wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *)
     * }
     */
    public static MemorySegment wcsdup$address() {
        return wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *)
     * }
     */
    public static MemorySegment wcsdup(MemorySegment x0) {
        var mh$ = wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsdup", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscasecmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcscasecmp$descriptor() {
        return wcscasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscasecmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcscasecmp$handle() {
        return wcscasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscasecmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcscasecmp$address() {
        return wcscasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscasecmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static int wcscasecmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscasecmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n)
     * }
     */
    public static FunctionDescriptor wcsncasecmp$descriptor() {
        return wcsncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n)
     * }
     */
    public static MethodHandle wcsncasecmp$handle() {
        return wcsncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n)
     * }
     */
    public static MemorySegment wcsncasecmp$address() {
        return wcsncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n)
     * }
     */
    public static int wcsncasecmp(MemorySegment x0, MemorySegment x1, long n) {
        var mh$ = wcsncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncasecmp", x0, x1, n);
            }
            return (int)mh$.invokeExact(x0, x1, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcsnlen$descriptor() {
        return wcsnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcsnlen$handle() {
        return wcsnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcsnlen$address() {
        return wcsnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *, size_t)
     * }
     */
    public static long wcsnlen(MemorySegment x0, long x1) {
        var mh$ = wcsnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnlen", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnrtombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnrtombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnrtombs(char *restrict, const wchar_t **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor wcsnrtombs$descriptor() {
        return wcsnrtombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnrtombs(char *restrict, const wchar_t **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle wcsnrtombs$handle() {
        return wcsnrtombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnrtombs(char *restrict, const wchar_t **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment wcsnrtombs$address() {
        return wcsnrtombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnrtombs(char *restrict, const wchar_t **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static long wcsnrtombs(MemorySegment x0, MemorySegment x1, long x2, long x3, MemorySegment x4) {
        var mh$ = wcsnrtombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnrtombs", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_wmemstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("open_wmemstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep)
     * }
     */
    public static FunctionDescriptor open_wmemstream$descriptor() {
        return open_wmemstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep)
     * }
     */
    public static MethodHandle open_wmemstream$handle() {
        return open_wmemstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_wmemstream$address() {
        return open_wmemstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_wmemstream(MemorySegment __bufp, MemorySegment __sizep) {
        var mh$ = open_wmemstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_wmemstream", __bufp, __sizep);
            }
            return (MemorySegment)mh$.invokeExact(__bufp, __sizep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetwln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetwln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *fgetwln(FILE *restrict, size_t *)
     * }
     */
    public static FunctionDescriptor fgetwln$descriptor() {
        return fgetwln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *fgetwln(FILE *restrict, size_t *)
     * }
     */
    public static MethodHandle fgetwln$handle() {
        return fgetwln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *fgetwln(FILE *restrict, size_t *)
     * }
     */
    public static MemorySegment fgetwln$address() {
        return fgetwln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *fgetwln(FILE *restrict, size_t *)
     * }
     */
    public static MemorySegment fgetwln(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetwln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetwln", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcslcat(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcslcat$descriptor() {
        return wcslcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcslcat(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcslcat$handle() {
        return wcslcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcslcat(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcslcat$address() {
        return wcslcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcslcat(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static long wcslcat(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcslcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslcat", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcslcpy(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcslcpy$descriptor() {
        return wcslcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcslcpy(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcslcpy$handle() {
        return wcslcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcslcpy(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcslcpy$address() {
        return wcslcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcslcpy(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static long wcslcpy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcslcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslcpy", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfLong u_long = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t quad_t
     * }
     */
    public static final OfLong quad_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef quad_t *qaddr_t
     * }
     */
    public static final AddressLayout qaddr_t = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char *caddr_t
     * }
     */
    public static final AddressLayout caddr_t = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t daddr_t
     * }
     */
    public static final OfInt daddr_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fixpt_t
     * }
     */
    public static final OfInt fixpt_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino_t ino_t
     * }
     */
    public static final OfLong ino_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t ino64_t
     * }
     */
    public static final OfLong ino64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t key_t
     * }
     */
    public static final OfInt key_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t nlink_t
     * }
     */
    public static final OfShort nlink_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t segsz_t
     * }
     */
    public static final OfInt segsz_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t swblk_t
     * }
     */
    public static final OfInt swblk_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = Python_h.C_INT;

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __int32_t fd_mask
     * }
     */
    public static final OfInt fd_mask = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_t pthread_t
     * }
     */
    public static final AddressLayout pthread_t = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_key_t pthread_key_t
     * }
     */
    public static final OfLong pthread_key_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfInt fsblkcnt_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfInt fsfilcnt_t = Python_h.C_INT;

    private static class __error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static FunctionDescriptor __error$descriptor() {
        return __error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MethodHandle __error$handle() {
        return __error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MemorySegment __error$address() {
        return __error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MemorySegment __error() {
        var mh$ = __error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__error");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = Python_h.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = Python_h.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static FunctionDescriptor wait$descriptor() {
        return wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MethodHandle wait$handle() {
        return wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MemorySegment wait$address() {
        return wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static int wait(MemorySegment x0) {
        var mh$ = wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static int waitpid(int x0, MemorySegment x1, int x2) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static int waitid(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static int wait3(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static int wait4(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca(long x0) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long malloc_type_id_t
     * }
     */
    public static final OfLong malloc_type_id_t = Python_h.C_LONG_LONG;

    private static class malloc_type_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_malloc$descriptor() {
        return malloc_type_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_malloc$handle() {
        return malloc_type_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc$address() {
        return malloc_type_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc(long size, long type_id) {
        var mh$ = malloc_type_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_malloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_calloc$descriptor() {
        return malloc_type_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_calloc$handle() {
        return malloc_type_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc$address() {
        return malloc_type_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc(long count, long size, long type_id) {
        var mh$ = malloc_type_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_calloc", count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_free$descriptor() {
        return malloc_type_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_free$handle() {
        return malloc_type_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_free$address() {
        return malloc_type_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_free(MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_free", ptr, type_id);
            }
            mh$.invokeExact(ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_realloc$descriptor() {
        return malloc_type_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_realloc$handle() {
        return malloc_type_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc$address() {
        return malloc_type_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc(MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_realloc", ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_valloc$descriptor() {
        return malloc_type_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_valloc$handle() {
        return malloc_type_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc$address() {
        return malloc_type_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc(long size, long type_id) {
        var mh$ = malloc_type_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_valloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_aligned_alloc$descriptor() {
        return malloc_type_aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_aligned_alloc$handle() {
        return malloc_type_aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc$address() {
        return malloc_type_aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc(long alignment, long size, long type_id) {
        var mh$ = malloc_type_aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_aligned_alloc", alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_posix_memalign$descriptor() {
        return malloc_type_posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_posix_memalign$handle() {
        return malloc_type_posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_posix_memalign$address() {
        return malloc_type_posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static int malloc_type_posix_memalign(MemorySegment memptr, long alignment, long size, long type_id) {
        var mh$ = malloc_type_posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_posix_memalign", memptr, alignment, size, type_id);
            }
            return (int)mh$.invokeExact(memptr, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_malloc$descriptor() {
        return malloc_type_zone_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_malloc$handle() {
        return malloc_type_zone_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc$address() {
        return malloc_type_zone_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_malloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_calloc$descriptor() {
        return malloc_type_zone_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_calloc$handle() {
        return malloc_type_zone_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc$address() {
        return malloc_type_zone_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc(MemorySegment zone, long count, long size, long type_id) {
        var mh$ = malloc_type_zone_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_calloc", zone, count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_free$descriptor() {
        return malloc_type_zone_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_free$handle() {
        return malloc_type_zone_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_free$address() {
        return malloc_type_zone_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_zone_free(MemorySegment zone, MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_zone_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_free", zone, ptr, type_id);
            }
            mh$.invokeExact(zone, ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_realloc$descriptor() {
        return malloc_type_zone_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_realloc$handle() {
        return malloc_type_zone_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc$address() {
        return malloc_type_zone_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc(MemorySegment zone, MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_zone_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_realloc", zone, ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_valloc$descriptor() {
        return malloc_type_zone_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_valloc$handle() {
        return malloc_type_zone_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc$address() {
        return malloc_type_zone_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_valloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_memalign$descriptor() {
        return malloc_type_zone_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_memalign$handle() {
        return malloc_type_zone_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign$address() {
        return malloc_type_zone_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign(MemorySegment zone, long alignment, long size, long type_id) {
        var mh$ = malloc_type_zone_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_memalign", zone, alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static void quick_exit(int x0) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long x2) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int x1) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static int getloadavg(MemorySegment x0, int x1) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dst, MemorySegment __src, long __len) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dst, __src, __len);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset(MemorySegment __b, int __c, long __len) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __b, __c, __len);
            }
            return (MemorySegment)mh$.invokeExact(__b, __c, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __s1, __s2);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __s1, __s2, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __charset);
            }
            return (MemorySegment)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok(MemorySegment __str, MemorySegment __sep) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __str, __sep);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __s1, __s2, __n);
            }
            return (long)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __str, MemorySegment __sep, MemorySegment __lasts) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __str, __sep, __lasts);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep, __lasts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __strerrbuf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s1) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s1);
            }
            return (MemorySegment)mh$.invokeExact(__s1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dst, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dst, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __s1, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __s1, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static long strnlen(MemorySegment __s1, long __n) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __s1, __n);
            }
            return (long)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static FunctionDescriptor memset_s$descriptor() {
        return memset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MethodHandle memset_s$handle() {
        return memset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MemorySegment memset_s$address() {
        return memset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static int memset_s(MemorySegment __s, long __smax, int __c, long __n) {
        var mh$ = memset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_s", __s, __smax, __c, __n);
            }
            return (int)mh$.invokeExact(__s, __smax, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem(MemorySegment __big, long __big_len, MemorySegment __little, long __little_len) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __big, __big_len, __little, __little_len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __big_len, __little, __little_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset_pattern4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern4$descriptor() {
        return memset_pattern4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern4$handle() {
        return memset_pattern4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern4$address() {
        return memset_pattern4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static void memset_pattern4(MemorySegment __b, MemorySegment __pattern4, long __len) {
        var mh$ = memset_pattern4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern4", __b, __pattern4, __len);
            }
            mh$.invokeExact(__b, __pattern4, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset_pattern8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern8$descriptor() {
        return memset_pattern8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern8$handle() {
        return memset_pattern8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern8$address() {
        return memset_pattern8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static void memset_pattern8(MemorySegment __b, MemorySegment __pattern8, long __len) {
        var mh$ = memset_pattern8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern8", __b, __pattern8, __len);
            }
            mh$.invokeExact(__b, __pattern8, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset_pattern16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern16$descriptor() {
        return memset_pattern16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern16$handle() {
        return memset_pattern16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern16$address() {
        return memset_pattern16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static void memset_pattern16(MemorySegment __b, MemorySegment __pattern16, long __len) {
        var mh$ = memset_pattern16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern16", __b, __pattern16, __len);
            }
            mh$.invokeExact(__b, __pattern16, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strnstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static FunctionDescriptor strnstr$descriptor() {
        return strnstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MethodHandle strnstr$handle() {
        return strnstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr$address() {
        return strnstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr(MemorySegment __big, MemorySegment __little, long __len) {
        var mh$ = strnstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnstr", __big, __little, __len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcat(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcpy(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static FunctionDescriptor strmode$descriptor() {
        return strmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MethodHandle strmode$handle() {
        return strmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MemorySegment strmode$address() {
        return strmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static void strmode(int __mode, MemorySegment __bp) {
        var mh$ = strmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmode", __mode, __bp);
            }
            mh$.invokeExact(__mode, __bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timingsafe_bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("timingsafe_bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static FunctionDescriptor timingsafe_bcmp$descriptor() {
        return timingsafe_bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MethodHandle timingsafe_bcmp$handle() {
        return timingsafe_bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MemorySegment timingsafe_bcmp$address() {
        return timingsafe_bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static int timingsafe_bcmp(MemorySegment __b1, MemorySegment __b2, long __len) {
        var mh$ = timingsafe_bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timingsafe_bcmp", __b1, __b2, __len);
            }
            return (int)mh$.invokeExact(__b1, __b2, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strsignal_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strsignal_r$descriptor() {
        return strsignal_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strsignal_r$handle() {
        return strsignal_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strsignal_r$address() {
        return strsignal_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static int strsignal_r(int __sig, MemorySegment __strsignalbuf, long __buflen) {
        var mh$ = strsignal_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal_r", __sig, __strsignalbuf, __buflen);
            }
            return (int)mh$.invokeExact(__sig, __strsignalbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static int bcmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static void bcopy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static void bzero(MemorySegment x0, long x1) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index(MemorySegment x0, int x1) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex(MemorySegment x0, int x1) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static int ffs(int x0) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static int strcasecmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static int strncasecmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static int ffsl(long x0) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static int ffsll(long x0) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static FunctionDescriptor fls$descriptor() {
        return fls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MethodHandle fls$handle() {
        return fls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MemorySegment fls$address() {
        return fls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static int fls(int x0) {
        var mh$ = fls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fls", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("flsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static FunctionDescriptor flsl$descriptor() {
        return flsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MethodHandle flsl$handle() {
        return flsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MemorySegment flsl$address() {
        return flsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static int flsl(long x0) {
        var mh$ = flsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("flsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static FunctionDescriptor flsll$descriptor() {
        return flsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MethodHandle flsll$handle() {
        return flsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MemorySegment flsll$address() {
        return flsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static int flsll(long x0) {
        var mh$ = flsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlistbulk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getattrlistbulk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static FunctionDescriptor getattrlistbulk$descriptor() {
        return getattrlistbulk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MethodHandle getattrlistbulk$handle() {
        return getattrlistbulk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MemorySegment getattrlistbulk$address() {
        return getattrlistbulk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static int getattrlistbulk(int x0, MemorySegment x1, MemorySegment x2, long x3, long x4) {
        var mh$ = getattrlistbulk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistbulk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static FunctionDescriptor getattrlistat$descriptor() {
        return getattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MethodHandle getattrlistat$handle() {
        return getattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MemorySegment getattrlistat$address() {
        return getattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static int getattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, long x5) {
        var mh$ = getattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static FunctionDescriptor setattrlistat$descriptor() {
        return setattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MethodHandle setattrlistat$handle() {
        return setattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MemorySegment setattrlistat$address() {
        return setattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static int setattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = setattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freadlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("freadlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor freadlink$descriptor() {
        return freadlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MethodHandle freadlink$handle() {
        return freadlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MemorySegment freadlink$address() {
        return freadlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static long freadlink(int x0, MemorySegment x1, long x2) {
        var mh$ = freadlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freadlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class faccessat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("faccessat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static FunctionDescriptor faccessat$descriptor() {
        return faccessat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MethodHandle faccessat$handle() {
        return faccessat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MemorySegment faccessat$address() {
        return faccessat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static int faccessat(int x0, MemorySegment x1, int x2, int x3) {
        var mh$ = faccessat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("faccessat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchownat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchownat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static FunctionDescriptor fchownat$descriptor() {
        return fchownat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MethodHandle fchownat$handle() {
        return fchownat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MemorySegment fchownat$address() {
        return fchownat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static int fchownat(int x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = fchownat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchownat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class linkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("linkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static FunctionDescriptor linkat$descriptor() {
        return linkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MethodHandle linkat$handle() {
        return linkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MemorySegment linkat$address() {
        return linkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static int linkat(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = linkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("linkat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("readlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static FunctionDescriptor readlinkat$descriptor() {
        return readlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MethodHandle readlinkat$handle() {
        return readlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MemorySegment readlinkat$address() {
        return readlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static long readlinkat(int x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = readlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlinkat", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("symlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor symlinkat$descriptor() {
        return symlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MethodHandle symlinkat$handle() {
        return symlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MemorySegment symlinkat$address() {
        return symlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static int symlinkat(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = symlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static FunctionDescriptor unlinkat$descriptor() {
        return unlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MethodHandle unlinkat$handle() {
        return unlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MemorySegment unlinkat$address() {
        return unlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static int unlinkat(int x0, MemorySegment x1, int x2) {
        var mh$ = unlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _exit$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static void _exit(int x0) {
        var mh$ = _exit$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static FunctionDescriptor access$descriptor() {
        return access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MethodHandle access$handle() {
        return access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MemorySegment access$address() {
        return access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static int access(MemorySegment x0, int x1) {
        var mh$ = access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("access", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("alarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static FunctionDescriptor alarm$descriptor() {
        return alarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MethodHandle alarm$handle() {
        return alarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MemorySegment alarm$address() {
        return alarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static int alarm(int x0) {
        var mh$ = alarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alarm", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static FunctionDescriptor chdir$descriptor() {
        return chdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MethodHandle chdir$handle() {
        return chdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MemorySegment chdir$address() {
        return chdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static int chdir(MemorySegment x0) {
        var mh$ = chdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor chown$descriptor() {
        return chown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle chown$handle() {
        return chown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment chown$address() {
        return chown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static int chown(MemorySegment x0, int x1, int x2) {
        var mh$ = chown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static FunctionDescriptor close$descriptor() {
        return close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MethodHandle close$handle() {
        return close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MemorySegment close$address() {
        return close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static int close(int x0) {
        var mh$ = close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("close", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static FunctionDescriptor dup$descriptor() {
        return dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MethodHandle dup$handle() {
        return dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MemorySegment dup$address() {
        return dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static int dup(int x0) {
        var mh$ = dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("dup2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static FunctionDescriptor dup2$descriptor() {
        return dup2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MethodHandle dup2$handle() {
        return dup2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MemorySegment dup2$address() {
        return dup2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static int dup2(int x0, int x1) {
        var mh$ = dup2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup2", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execl(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("execl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execl(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execl", __path, __arg0, x2);
                }
                return (int) spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execle(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("execle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execle(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execle", __path, __arg0, x2);
                }
                return (int) spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execlp(const char *__file, const char *__arg0, ...)
     * }
     */
    public static class execlp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("execlp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execlp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execlp(const char *__file, const char *__arg0, ...)
         * }
         */
        public static execlp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execlp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __file, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execlp", __file, __arg0, x2);
                }
                return (int) spreader.invokeExact(__file, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class execv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("execv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execv$descriptor() {
        return execv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MethodHandle execv$handle() {
        return execv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MemorySegment execv$address() {
        return execv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static int execv(MemorySegment __path, MemorySegment __argv) {
        var mh$ = execv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execv", __path, __argv);
            }
            return (int)mh$.invokeExact(__path, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("execve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static FunctionDescriptor execve$descriptor() {
        return execve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MethodHandle execve$handle() {
        return execve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MemorySegment execve$address() {
        return execve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static int execve(MemorySegment __file, MemorySegment __argv, MemorySegment __envp) {
        var mh$ = execve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execve", __file, __argv, __envp);
            }
            return (int)mh$.invokeExact(__file, __argv, __envp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("execvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvp$descriptor() {
        return execvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MethodHandle execvp$handle() {
        return execvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MemorySegment execvp$address() {
        return execvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static int execvp(MemorySegment __file, MemorySegment __argv) {
        var mh$ = execvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvp", __file, __argv);
            }
            return (int)mh$.invokeExact(__file, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static FunctionDescriptor fork$descriptor() {
        return fork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MethodHandle fork$handle() {
        return fork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MemorySegment fork$address() {
        return fork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static int fork() {
        var mh$ = fork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fpathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static FunctionDescriptor fpathconf$descriptor() {
        return fpathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MethodHandle fpathconf$handle() {
        return fpathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MemorySegment fpathconf$address() {
        return fpathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static long fpathconf(int x0, int x1) {
        var mh$ = fpathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static FunctionDescriptor getcwd$descriptor() {
        return getcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MethodHandle getcwd$handle() {
        return getcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd$address() {
        return getcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd(MemorySegment x0, long x1) {
        var mh$ = getcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getcwd", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static FunctionDescriptor getegid$descriptor() {
        return getegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MethodHandle getegid$handle() {
        return getegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MemorySegment getegid$address() {
        return getegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static int getegid() {
        var mh$ = getegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getegid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class geteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("geteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static FunctionDescriptor geteuid$descriptor() {
        return geteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MethodHandle geteuid$handle() {
        return geteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MemorySegment geteuid$address() {
        return geteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static int geteuid() {
        var mh$ = geteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("geteuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static FunctionDescriptor getgid$descriptor() {
        return getgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MethodHandle getgid$handle() {
        return getgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MemorySegment getgid$address() {
        return getgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static int getgid() {
        var mh$ = getgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getgroups$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static FunctionDescriptor getgroups$descriptor() {
        return getgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MethodHandle getgroups$handle() {
        return getgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MemorySegment getgroups$address() {
        return getgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static int getgroups(int x0, MemorySegment x1) {
        var mh$ = getgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static FunctionDescriptor getlogin$descriptor() {
        return getlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MethodHandle getlogin$handle() {
        return getlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin$address() {
        return getlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin() {
        var mh$ = getlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static FunctionDescriptor getpgrp$descriptor() {
        return getpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MethodHandle getpgrp$handle() {
        return getpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MemorySegment getpgrp$address() {
        return getpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static int getpgrp() {
        var mh$ = getpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static FunctionDescriptor getpid$descriptor() {
        return getpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MethodHandle getpid$handle() {
        return getpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MemorySegment getpid$address() {
        return getpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static int getpid() {
        var mh$ = getpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getppid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getppid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static FunctionDescriptor getppid$descriptor() {
        return getppid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MethodHandle getppid$handle() {
        return getppid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MemorySegment getppid$address() {
        return getppid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static int getppid() {
        var mh$ = getppid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getppid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static FunctionDescriptor getuid$descriptor() {
        return getuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MethodHandle getuid$handle() {
        return getuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MemorySegment getuid$address() {
        return getuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static int getuid() {
        var mh$ = getuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isatty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isatty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static FunctionDescriptor isatty$descriptor() {
        return isatty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MethodHandle isatty$handle() {
        return isatty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MemorySegment isatty$address() {
        return isatty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static int isatty(int x0) {
        var mh$ = isatty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isatty", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static FunctionDescriptor link$descriptor() {
        return link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MethodHandle link$handle() {
        return link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MemorySegment link$address() {
        return link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static int link(MemorySegment x0, MemorySegment x1) {
        var mh$ = link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("link", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static FunctionDescriptor lseek$descriptor() {
        return lseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MethodHandle lseek$handle() {
        return lseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MemorySegment lseek$address() {
        return lseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static long lseek(int x0, long x1, int x2) {
        var mh$ = lseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lseek", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static FunctionDescriptor pathconf$descriptor() {
        return pathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MethodHandle pathconf$handle() {
        return pathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MemorySegment pathconf$address() {
        return pathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static long pathconf(MemorySegment x0, int x1) {
        var mh$ = pathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static FunctionDescriptor pause$descriptor() {
        return pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MethodHandle pause$handle() {
        return pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MemorySegment pause$address() {
        return pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static int pause() {
        var mh$ = pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pause");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static FunctionDescriptor pipe$descriptor() {
        return pipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MethodHandle pipe$handle() {
        return pipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MemorySegment pipe$address() {
        return pipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static int pipe(MemorySegment x0) {
        var mh$ = pipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pipe", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static FunctionDescriptor read$descriptor() {
        return read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MethodHandle read$handle() {
        return read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MemorySegment read$address() {
        return read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static long read(int x0, MemorySegment x1, long x2) {
        var mh$ = read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rmdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static FunctionDescriptor rmdir$descriptor() {
        return rmdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MethodHandle rmdir$handle() {
        return rmdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MemorySegment rmdir$address() {
        return rmdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static int rmdir(MemorySegment x0) {
        var mh$ = rmdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static FunctionDescriptor setgid$descriptor() {
        return setgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MethodHandle setgid$handle() {
        return setgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MemorySegment setgid$address() {
        return setgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static int setgid(int x0) {
        var mh$ = setgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static FunctionDescriptor setpgid$descriptor() {
        return setpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MethodHandle setpgid$handle() {
        return setpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MemorySegment setpgid$address() {
        return setpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static int setpgid(int x0, int x1) {
        var mh$ = setpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static FunctionDescriptor setsid$descriptor() {
        return setsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MethodHandle setsid$handle() {
        return setsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MemorySegment setsid$address() {
        return setsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static int setsid() {
        var mh$ = setsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static FunctionDescriptor setuid$descriptor() {
        return setuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MethodHandle setuid$handle() {
        return setuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MemorySegment setuid$address() {
        return setuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static int setuid(int x0) {
        var mh$ = setuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static FunctionDescriptor sleep$descriptor() {
        return sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MethodHandle sleep$handle() {
        return sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MemorySegment sleep$address() {
        return sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static int sleep(int x0) {
        var mh$ = sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sysconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sysconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static FunctionDescriptor sysconf$descriptor() {
        return sysconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MethodHandle sysconf$handle() {
        return sysconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MemorySegment sysconf$address() {
        return sysconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static long sysconf(int x0) {
        var mh$ = sysconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysconf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcgetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tcgetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static FunctionDescriptor tcgetpgrp$descriptor() {
        return tcgetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MethodHandle tcgetpgrp$handle() {
        return tcgetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MemorySegment tcgetpgrp$address() {
        return tcgetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static int tcgetpgrp(int x0) {
        var mh$ = tcgetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcgetpgrp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcsetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tcsetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static FunctionDescriptor tcsetpgrp$descriptor() {
        return tcsetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MethodHandle tcsetpgrp$handle() {
        return tcsetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MemorySegment tcsetpgrp$address() {
        return tcsetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static int tcsetpgrp(int x0, int x1) {
        var mh$ = tcsetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcsetpgrp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ttyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static FunctionDescriptor ttyname$descriptor() {
        return ttyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MethodHandle ttyname$handle() {
        return ttyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname$address() {
        return ttyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname(int x0) {
        var mh$ = ttyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ttyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor ttyname_r$descriptor() {
        return ttyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MethodHandle ttyname_r$handle() {
        return ttyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MemorySegment ttyname_r$address() {
        return ttyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static int ttyname_r(int x0, MemorySegment x1, long x2) {
        var mh$ = ttyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname_r", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static int unlink(MemorySegment x0) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static FunctionDescriptor write$descriptor() {
        return write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MethodHandle write$handle() {
        return write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MemorySegment write$address() {
        return write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static long write(int __fd, MemorySegment __buf, long __nbyte) {
        var mh$ = write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("write", __fd, __buf, __nbyte);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class confstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("confstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor confstr$descriptor() {
        return confstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MethodHandle confstr$handle() {
        return confstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MemorySegment confstr$address() {
        return confstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static long confstr(int x0, MemorySegment x1, long x2) {
        var mh$ = confstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("confstr", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static FunctionDescriptor getopt$descriptor() {
        return getopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MethodHandle getopt$handle() {
        return getopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MemorySegment getopt$address() {
        return getopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static int getopt(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optarg$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("optarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static AddressLayout optarg$layout() {
        return optarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg$segment() {
        return optarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg() {
        return optarg$constants.SEGMENT.get(optarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static void optarg(MemorySegment varValue) {
        optarg$constants.SEGMENT.set(optarg$constants.LAYOUT, 0L, varValue);
    }

    private static class optind$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("optind").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static OfInt optind$layout() {
        return optind$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static MemorySegment optind$segment() {
        return optind$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static int optind() {
        return optind$constants.SEGMENT.get(optind$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static void optind(int varValue) {
        optind$constants.SEGMENT.set(optind$constants.LAYOUT, 0L, varValue);
    }

    private static class opterr$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("opterr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static OfInt opterr$layout() {
        return opterr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static MemorySegment opterr$segment() {
        return opterr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static int opterr() {
        return opterr$constants.SEGMENT.get(opterr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static void opterr(int varValue) {
        opterr$constants.SEGMENT.set(opterr$constants.LAYOUT, 0L, varValue);
    }

    private static class optopt$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("optopt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static OfInt optopt$layout() {
        return optopt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static MemorySegment optopt$segment() {
        return optopt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static int optopt() {
        return optopt$constants.SEGMENT.get(optopt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static void optopt(int varValue) {
        optopt$constants.SEGMENT.set(optopt$constants.LAYOUT, 0L, varValue);
    }

    private static class brk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("brk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static FunctionDescriptor brk$descriptor() {
        return brk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MethodHandle brk$handle() {
        return brk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk$address() {
        return brk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk(MemorySegment x0) {
        var mh$ = brk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("brk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chroot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chroot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static FunctionDescriptor chroot$descriptor() {
        return chroot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MethodHandle chroot$handle() {
        return chroot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MemorySegment chroot$address() {
        return chroot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static int chroot(MemorySegment x0) {
        var mh$ = chroot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chroot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("crypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static FunctionDescriptor crypt$descriptor() {
        return crypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MethodHandle crypt$handle() {
        return crypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt$address() {
        return crypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt(MemorySegment x0, MemorySegment x1) {
        var mh$ = crypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crypt", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class encrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("encrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static FunctionDescriptor encrypt$descriptor() {
        return encrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MethodHandle encrypt$handle() {
        return encrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MemorySegment encrypt$address() {
        return encrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static void encrypt(MemorySegment x0, int x1) {
        var mh$ = encrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("encrypt", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static FunctionDescriptor fchdir$descriptor() {
        return fchdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MethodHandle fchdir$handle() {
        return fchdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MemorySegment fchdir$address() {
        return fchdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static int fchdir(int x0) {
        var mh$ = fchdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static FunctionDescriptor gethostid$descriptor() {
        return gethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MethodHandle gethostid$handle() {
        return gethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MemorySegment gethostid$address() {
        return gethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static long gethostid() {
        var mh$ = gethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostid");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static FunctionDescriptor getpgid$descriptor() {
        return getpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MethodHandle getpgid$handle() {
        return getpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MemorySegment getpgid$address() {
        return getpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static int getpgid(int x0) {
        var mh$ = getpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static FunctionDescriptor getsid$descriptor() {
        return getsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MethodHandle getsid$handle() {
        return getsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MemorySegment getsid$address() {
        return getsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static int getsid(int x0) {
        var mh$ = getsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdtablesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdtablesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static FunctionDescriptor getdtablesize$descriptor() {
        return getdtablesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MethodHandle getdtablesize$handle() {
        return getdtablesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MemorySegment getdtablesize$address() {
        return getdtablesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static int getdtablesize() {
        var mh$ = getdtablesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdtablesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpagesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpagesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static FunctionDescriptor getpagesize$descriptor() {
        return getpagesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MethodHandle getpagesize$handle() {
        return getpagesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MemorySegment getpagesize$address() {
        return getpagesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static int getpagesize() {
        var mh$ = getpagesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpagesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static FunctionDescriptor getpass$descriptor() {
        return getpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MethodHandle getpass$handle() {
        return getpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass$address() {
        return getpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass(MemorySegment x0) {
        var mh$ = getpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpass", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static FunctionDescriptor getwd$descriptor() {
        return getwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MethodHandle getwd$handle() {
        return getwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd$address() {
        return getwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd(MemorySegment x0) {
        var mh$ = getwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwd", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor lchown$descriptor() {
        return lchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle lchown$handle() {
        return lchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment lchown$address() {
        return lchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static int lchown(MemorySegment x0, int x1, int x2) {
        var mh$ = lchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lockf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lockf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static FunctionDescriptor lockf$descriptor() {
        return lockf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MethodHandle lockf$handle() {
        return lockf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MemorySegment lockf$address() {
        return lockf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static int lockf(int x0, int x1, long x2) {
        var mh$ = lockf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lockf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static FunctionDescriptor nice$descriptor() {
        return nice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MethodHandle nice$handle() {
        return nice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MemorySegment nice$address() {
        return nice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static int nice(int x0) {
        var mh$ = nice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nice", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pread$descriptor() {
        return pread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pread$handle() {
        return pread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pread$address() {
        return pread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pread(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pread", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pwrite$descriptor() {
        return pwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pwrite$handle() {
        return pwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pwrite$address() {
        return pwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pwrite(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pwrite", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static FunctionDescriptor sbrk$descriptor() {
        return sbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MethodHandle sbrk$handle() {
        return sbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk$address() {
        return sbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk(int x0) {
        var mh$ = sbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbrk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static FunctionDescriptor setpgrp$descriptor() {
        return setpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MethodHandle setpgrp$handle() {
        return setpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MemorySegment setpgrp$address() {
        return setpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static int setpgrp() {
        var mh$ = setpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setregid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setregid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static FunctionDescriptor setregid$descriptor() {
        return setregid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MethodHandle setregid$handle() {
        return setregid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MemorySegment setregid$address() {
        return setregid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static int setregid(int x0, int x1) {
        var mh$ = setregid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setregid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setreuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setreuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static FunctionDescriptor setreuid$descriptor() {
        return setreuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MethodHandle setreuid$handle() {
        return setreuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MemorySegment setreuid$address() {
        return setreuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static int setreuid(int x0, int x1) {
        var mh$ = setreuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setreuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static FunctionDescriptor sync$descriptor() {
        return sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MethodHandle sync$handle() {
        return sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MemorySegment sync$address() {
        return sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static void sync() {
        var mh$ = sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("truncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static FunctionDescriptor truncate$descriptor() {
        return truncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MethodHandle truncate$handle() {
        return truncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MemorySegment truncate$address() {
        return truncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static int truncate(MemorySegment x0, long x1) {
        var mh$ = truncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ualarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ualarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static FunctionDescriptor ualarm$descriptor() {
        return ualarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MethodHandle ualarm$handle() {
        return ualarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MemorySegment ualarm$address() {
        return ualarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static int ualarm(int x0, int x1) {
        var mh$ = ualarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ualarm", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class usleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("usleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static FunctionDescriptor usleep$descriptor() {
        return usleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MethodHandle usleep$handle() {
        return usleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MemorySegment usleep$address() {
        return usleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static int usleep(int x0) {
        var mh$ = usleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("usleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static FunctionDescriptor vfork$descriptor() {
        return vfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MethodHandle vfork$handle() {
        return vfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MemorySegment vfork$address() {
        return vfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static int vfork() {
        var mh$ = vfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static FunctionDescriptor fsync$descriptor() {
        return fsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MethodHandle fsync$handle() {
        return fsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MemorySegment fsync$address() {
        return fsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static int fsync(int x0) {
        var mh$ = fsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftruncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ftruncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static FunctionDescriptor ftruncate$descriptor() {
        return ftruncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MethodHandle ftruncate$handle() {
        return ftruncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MemorySegment ftruncate$address() {
        return ftruncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static int ftruncate(int x0, long x1) {
        var mh$ = ftruncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftruncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getlogin_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static FunctionDescriptor getlogin_r$descriptor() {
        return getlogin_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MethodHandle getlogin_r$handle() {
        return getlogin_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MemorySegment getlogin_r$address() {
        return getlogin_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static int getlogin_r(MemorySegment x0, long x1) {
        var mh$ = getlogin_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin_r", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor fchown$descriptor() {
        return fchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MethodHandle fchown$handle() {
        return fchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MemorySegment fchown$address() {
        return fchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static int fchown(int x0, int x1, int x2) {
        var mh$ = fchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static FunctionDescriptor gethostname$descriptor() {
        return gethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MethodHandle gethostname$handle() {
        return gethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MemorySegment gethostname$address() {
        return gethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static int gethostname(MemorySegment x0, long x1) {
        var mh$ = gethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("readlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor readlink$descriptor() {
        return readlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MethodHandle readlink$handle() {
        return readlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MemorySegment readlink$address() {
        return readlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static long readlink(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = readlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static FunctionDescriptor setegid$descriptor() {
        return setegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MethodHandle setegid$handle() {
        return setegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MemorySegment setegid$address() {
        return setegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static int setegid(int x0) {
        var mh$ = setegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setegid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("seteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static FunctionDescriptor seteuid$descriptor() {
        return seteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MethodHandle seteuid$handle() {
        return seteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MemorySegment seteuid$address() {
        return seteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static int seteuid(int x0) {
        var mh$ = seteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seteuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static FunctionDescriptor symlink$descriptor() {
        return symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MethodHandle symlink$handle() {
        return symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MemorySegment symlink$address() {
        return symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static int symlink(MemorySegment x0, MemorySegment x1) {
        var mh$ = symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlink", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pselect$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static int pselect(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("select$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static int select(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accessx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("accessx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static FunctionDescriptor accessx_np$descriptor() {
        return accessx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MethodHandle accessx_np$handle() {
        return accessx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MemorySegment accessx_np$address() {
        return accessx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static int accessx_np(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = accessx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accessx_np", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static FunctionDescriptor acct$descriptor() {
        return acct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MethodHandle acct$handle() {
        return acct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MemorySegment acct$address() {
        return acct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static int acct(MemorySegment x0) {
        var mh$ = acct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acct", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class add_profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("add_profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor add_profil$descriptor() {
        return add_profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle add_profil$handle() {
        return add_profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment add_profil$address() {
        return add_profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int add_profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = add_profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("add_profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("endusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static FunctionDescriptor endusershell$descriptor() {
        return endusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MethodHandle endusershell$handle() {
        return endusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MemorySegment endusershell$address() {
        return endusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static void endusershell() {
        var mh$ = endusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvP$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("execvP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvP$descriptor() {
        return execvP$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MethodHandle execvP$handle() {
        return execvP$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MemorySegment execvP$address() {
        return execvP$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static int execvP(MemorySegment __file, MemorySegment __searchpath, MemorySegment __argv) {
        var mh$ = execvP$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvP", __file, __searchpath, __argv);
            }
            return (int)mh$.invokeExact(__file, __searchpath, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflagstostr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fflagstostr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static FunctionDescriptor fflagstostr$descriptor() {
        return fflagstostr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MethodHandle fflagstostr$handle() {
        return fflagstostr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr$address() {
        return fflagstostr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr(long x0) {
        var mh$ = fflagstostr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflagstostr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static FunctionDescriptor getdomainname$descriptor() {
        return getdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MethodHandle getdomainname$handle() {
        return getdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MemorySegment getdomainname$address() {
        return getdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static int getdomainname(MemorySegment x0, int x1) {
        var mh$ = getdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrouplist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getgrouplist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static FunctionDescriptor getgrouplist$descriptor() {
        return getgrouplist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MethodHandle getgrouplist$handle() {
        return getgrouplist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MemorySegment getgrouplist$address() {
        return getgrouplist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static int getgrouplist(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = getgrouplist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrouplist", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostuuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gethostuuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static FunctionDescriptor gethostuuid$descriptor() {
        return gethostuuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MethodHandle gethostuuid$handle() {
        return gethostuuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MemorySegment gethostuuid$address() {
        return gethostuuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static int gethostuuid(MemorySegment x0, MemorySegment x1) {
        var mh$ = gethostuuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostuuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static FunctionDescriptor getmode$descriptor() {
        return getmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MethodHandle getmode$handle() {
        return getmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MemorySegment getmode$address() {
        return getmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static short getmode(MemorySegment x0, short x1) {
        var mh$ = getmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getmode", x0, x1);
            }
            return (short)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeereid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpeereid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor getpeereid$descriptor() {
        return getpeereid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MethodHandle getpeereid$handle() {
        return getpeereid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MemorySegment getpeereid$address() {
        return getpeereid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static int getpeereid(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getpeereid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeereid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getsgroups_np$descriptor() {
        return getsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getsgroups_np$handle() {
        return getsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getsgroups_np$address() {
        return getsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static int getsgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static FunctionDescriptor getusershell$descriptor() {
        return getusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MethodHandle getusershell$handle() {
        return getusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell$address() {
        return getusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell() {
        var mh$ = getusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getusershell");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getwgroups_np$descriptor() {
        return getwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getwgroups_np$handle() {
        return getwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getwgroups_np$address() {
        return getwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static int getwgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("initgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static FunctionDescriptor initgroups$descriptor() {
        return initgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MethodHandle initgroups$handle() {
        return initgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MemorySegment initgroups$address() {
        return initgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static int initgroups(MemorySegment x0, int x1) {
        var mh$ = initgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class issetugid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("issetugid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static FunctionDescriptor issetugid$descriptor() {
        return issetugid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MethodHandle issetugid$handle() {
        return issetugid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MemorySegment issetugid$address() {
        return issetugid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static int issetugid() {
        var mh$ = issetugid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("issetugid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment x0) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mknod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknod$descriptor() {
        return mknod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknod$handle() {
        return mknod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknod$address() {
        return mknod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static int mknod(MemorySegment x0, short x1, int x2) {
        var mh$ = mknod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknod", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpath_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkpath_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpath_np$descriptor() {
        return mkpath_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpath_np$handle() {
        return mkpath_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpath_np$address() {
        return mkpath_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static int mkpath_np(MemorySegment path, short omode) {
        var mh$ = mkpath_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpath_np", path, omode);
            }
            return (int)mh$.invokeExact(path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpathat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkpathat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpathat_np$descriptor() {
        return mkpathat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpathat_np$handle() {
        return mkpathat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpathat_np$address() {
        return mkpathat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static int mkpathat_np(int dfd, MemorySegment path, short omode) {
        var mh$ = mkpathat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpathat_np", dfd, path, omode);
            }
            return (int)mh$.invokeExact(dfd, path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static int mkstemps(MemorySegment x0, int x1) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkostemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemp$descriptor() {
        return mkostemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MethodHandle mkostemp$handle() {
        return mkostemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MemorySegment mkostemp$address() {
        return mkostemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static int mkostemp(MemorySegment path, int oflags) {
        var mh$ = mkostemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemp", path, oflags);
            }
            return (int)mh$.invokeExact(path, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkostemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemps$descriptor() {
        return mkostemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostemps$handle() {
        return mkostemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostemps$address() {
        return mkostemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static int mkostemps(MemorySegment path, int slen, int oflags) {
        var mh$ = mkostemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemps", path, slen, oflags);
            }
            return (int)mh$.invokeExact(path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp_dprotected_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkstemp_dprotected_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static FunctionDescriptor mkstemp_dprotected_np$descriptor() {
        return mkstemp_dprotected_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MethodHandle mkstemp_dprotected_np$handle() {
        return mkstemp_dprotected_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MemorySegment mkstemp_dprotected_np$address() {
        return mkstemp_dprotected_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static int mkstemp_dprotected_np(MemorySegment path, int dpclass, int dpflags) {
        var mh$ = mkstemp_dprotected_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp_dprotected_np", path, dpclass, dpflags);
            }
            return (int)mh$.invokeExact(path, dpclass, dpflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtempat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkdtempat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static FunctionDescriptor mkdtempat_np$descriptor() {
        return mkdtempat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MethodHandle mkdtempat_np$handle() {
        return mkdtempat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np$address() {
        return mkdtempat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np(int dfd, MemorySegment path) {
        var mh$ = mkdtempat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtempat_np", dfd, path);
            }
            return (MemorySegment)mh$.invokeExact(dfd, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkstempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static FunctionDescriptor mkstempsat_np$descriptor() {
        return mkstempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MethodHandle mkstempsat_np$handle() {
        return mkstempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MemorySegment mkstempsat_np$address() {
        return mkstempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static int mkstempsat_np(int dfd, MemorySegment path, int slen) {
        var mh$ = mkstempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstempsat_np", dfd, path, slen);
            }
            return (int)mh$.invokeExact(dfd, path, slen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkostempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostempsat_np$descriptor() {
        return mkostempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostempsat_np$handle() {
        return mkostempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostempsat_np$address() {
        return mkostempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static int mkostempsat_np(int dfd, MemorySegment path, int slen, int oflags) {
        var mh$ = mkostempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostempsat_np", dfd, path, slen, oflags);
            }
            return (int)mh$.invokeExact(dfd, path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nfssvc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nfssvc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static FunctionDescriptor nfssvc$descriptor() {
        return nfssvc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MethodHandle nfssvc$handle() {
        return nfssvc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MemorySegment nfssvc$address() {
        return nfssvc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static int nfssvc(int x0, MemorySegment x1) {
        var mh$ = nfssvc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nfssvc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor profil$descriptor() {
        return profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle profil$handle() {
        return profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment profil$address() {
        return profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor pthread_setugid_np$descriptor() {
        return pthread_setugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MethodHandle pthread_setugid_np$handle() {
        return pthread_setugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MemorySegment pthread_setugid_np$address() {
        return pthread_setugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static int pthread_setugid_np(int x0, int x1) {
        var mh$ = pthread_setugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor pthread_getugid_np$descriptor() {
        return pthread_getugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MethodHandle pthread_getugid_np$handle() {
        return pthread_getugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MemorySegment pthread_getugid_np$address() {
        return pthread_getugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static int pthread_getugid_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_getugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reboot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("reboot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static FunctionDescriptor reboot$descriptor() {
        return reboot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MethodHandle reboot$handle() {
        return reboot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MemorySegment reboot$address() {
        return reboot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static int reboot(int x0) {
        var mh$ = reboot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reboot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class revoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("revoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static FunctionDescriptor revoke$descriptor() {
        return revoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MethodHandle revoke$handle() {
        return revoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MemorySegment revoke$address() {
        return revoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static int revoke(MemorySegment x0) {
        var mh$ = revoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("revoke", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rcmd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static FunctionDescriptor rcmd$descriptor() {
        return rcmd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MethodHandle rcmd$handle() {
        return rcmd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MemorySegment rcmd$address() {
        return rcmd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static int rcmd(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = rcmd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rcmd_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static FunctionDescriptor rcmd_af$descriptor() {
        return rcmd_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MethodHandle rcmd_af$handle() {
        return rcmd_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MemorySegment rcmd_af$address() {
        return rcmd_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static int rcmd_af(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6) {
        var mh$ = rcmd_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd_af", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static FunctionDescriptor rresvport$descriptor() {
        return rresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MethodHandle rresvport$handle() {
        return rresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MemorySegment rresvport$address() {
        return rresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static int rresvport(MemorySegment x0) {
        var mh$ = rresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rresvport_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static FunctionDescriptor rresvport_af$descriptor() {
        return rresvport_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MethodHandle rresvport_af$handle() {
        return rresvport_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MemorySegment rresvport_af$address() {
        return rresvport_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static int rresvport_af(MemorySegment x0, int x1) {
        var mh$ = rresvport_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport_af", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok$descriptor() {
        return iruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok$handle() {
        return iruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok$address() {
        return iruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static int iruserok(long x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = iruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok_sa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iruserok_sa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok_sa$descriptor() {
        return iruserok_sa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok_sa$handle() {
        return iruserok_sa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok_sa$address() {
        return iruserok_sa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static int iruserok_sa(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = iruserok_sa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok_sa", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor ruserok$descriptor() {
        return ruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MethodHandle ruserok$handle() {
        return ruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MemorySegment ruserok$address() {
        return ruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static int ruserok(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static FunctionDescriptor setdomainname$descriptor() {
        return setdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MethodHandle setdomainname$handle() {
        return setdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MemorySegment setdomainname$address() {
        return setdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static int setdomainname(MemorySegment x0, int x1) {
        var mh$ = setdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static FunctionDescriptor setgroups$descriptor() {
        return setgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MethodHandle setgroups$handle() {
        return setgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MemorySegment setgroups$address() {
        return setgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static int setgroups(int x0, MemorySegment x1) {
        var mh$ = setgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static FunctionDescriptor sethostid$descriptor() {
        return sethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MethodHandle sethostid$handle() {
        return sethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MemorySegment sethostid$address() {
        return sethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static void sethostid(long x0) {
        var mh$ = sethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostid", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static FunctionDescriptor sethostname$descriptor() {
        return sethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MethodHandle sethostname$handle() {
        return sethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MemorySegment sethostname$address() {
        return sethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static int sethostname(MemorySegment x0, int x1) {
        var mh$ = sethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static FunctionDescriptor setlogin$descriptor() {
        return setlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MethodHandle setlogin$handle() {
        return setlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MemorySegment setlogin$address() {
        return setlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static int setlogin(MemorySegment x0) {
        var mh$ = setlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlogin", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static FunctionDescriptor setmode$descriptor() {
        return setmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MethodHandle setmode$handle() {
        return setmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode$address() {
        return setmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode(MemorySegment x0) {
        var mh$ = setmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setmode", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setrgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static FunctionDescriptor setrgid$descriptor() {
        return setrgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MethodHandle setrgid$handle() {
        return setrgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MemorySegment setrgid$address() {
        return setrgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static int setrgid(int x0) {
        var mh$ = setrgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setruid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setruid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static FunctionDescriptor setruid$descriptor() {
        return setruid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MethodHandle setruid$handle() {
        return setruid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MemorySegment setruid$address() {
        return setruid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static int setruid(int x0) {
        var mh$ = setruid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setruid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setsgroups_np$descriptor() {
        return setsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setsgroups_np$handle() {
        return setsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setsgroups_np$address() {
        return setsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static int setsgroups_np(int x0, MemorySegment x1) {
        var mh$ = setsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static FunctionDescriptor setusershell$descriptor() {
        return setusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MethodHandle setusershell$handle() {
        return setusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MemorySegment setusershell$address() {
        return setusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static void setusershell() {
        var mh$ = setusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setwgroups_np$descriptor() {
        return setwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setwgroups_np$handle() {
        return setwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setwgroups_np$address() {
        return setwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static int setwgroups_np(int x0, MemorySegment x1) {
        var mh$ = setwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtofflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtofflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static FunctionDescriptor strtofflags$descriptor() {
        return strtofflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MethodHandle strtofflags$handle() {
        return strtofflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MemorySegment strtofflags$address() {
        return strtofflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static int strtofflags(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strtofflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtofflags", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swapon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("swapon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static FunctionDescriptor swapon$descriptor() {
        return swapon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MethodHandle swapon$handle() {
        return swapon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MemorySegment swapon$address() {
        return swapon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static int swapon(MemorySegment x0) {
        var mh$ = swapon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swapon", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyslot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ttyslot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static FunctionDescriptor ttyslot$descriptor() {
        return ttyslot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MethodHandle ttyslot$handle() {
        return ttyslot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MemorySegment ttyslot$address() {
        return ttyslot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static int ttyslot() {
        var mh$ = ttyslot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyslot");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class undelete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("undelete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static FunctionDescriptor undelete$descriptor() {
        return undelete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MethodHandle undelete$handle() {
        return undelete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MemorySegment undelete$address() {
        return undelete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static int undelete(MemorySegment x0) {
        var mh$ = undelete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("undelete", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unwhiteout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unwhiteout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static FunctionDescriptor unwhiteout$descriptor() {
        return unwhiteout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MethodHandle unwhiteout$handle() {
        return unwhiteout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MemorySegment unwhiteout$address() {
        return unwhiteout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static int unwhiteout(MemorySegment x0) {
        var mh$ = unwhiteout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unwhiteout", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int syscall(int, ...)
     * }
     */
    public static class syscall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_INT
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("syscall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private syscall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int syscall(int, ...)
         * }
         */
        public static syscall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new syscall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("syscall", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fgetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fgetattrlist$descriptor() {
        return fgetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fgetattrlist$handle() {
        return fgetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fgetattrlist$address() {
        return fgetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fgetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fgetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fsetattrlist$descriptor() {
        return fsetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fsetattrlist$handle() {
        return fsetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fsetattrlist$address() {
        return fsetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fsetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fsetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor getattrlist$descriptor() {
        return getattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle getattrlist$handle() {
        return getattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment getattrlist$address() {
        return getattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int getattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = getattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor setattrlist$descriptor() {
        return setattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle setattrlist$handle() {
        return setattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment setattrlist$address() {
        return setattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int setattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = setattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exchangedata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exchangedata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor exchangedata$descriptor() {
        return exchangedata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle exchangedata$handle() {
        return exchangedata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment exchangedata$address() {
        return exchangedata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static int exchangedata(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = exchangedata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exchangedata", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdirentriesattr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdirentriesattr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static FunctionDescriptor getdirentriesattr$descriptor() {
        return getdirentriesattr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MethodHandle getdirentriesattr$handle() {
        return getdirentriesattr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MemorySegment getdirentriesattr$address() {
        return getdirentriesattr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static int getdirentriesattr(int x0, MemorySegment x1, MemorySegment x2, long x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7) {
        var mh$ = getdirentriesattr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdirentriesattr", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class searchfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("searchfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static FunctionDescriptor searchfs$descriptor() {
        return searchfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MethodHandle searchfs$handle() {
        return searchfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MemorySegment searchfs$address() {
        return searchfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static int searchfs(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5) {
        var mh$ = searchfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("searchfs", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor fsctl$descriptor() {
        return fsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle fsctl$handle() {
        return fsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment fsctl$address() {
        return fsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static int fsctl(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = fsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ffsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor ffsctl$descriptor() {
        return ffsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle ffsctl$handle() {
        return ffsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment ffsctl$address() {
        return ffsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static int ffsctl(int x0, long x1, MemorySegment x2, int x3) {
        var mh$ = ffsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static FunctionDescriptor fsync_volume_np$descriptor() {
        return fsync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MethodHandle fsync_volume_np$handle() {
        return fsync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MemorySegment fsync_volume_np$address() {
        return fsync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static int fsync_volume_np(int x0, int x1) {
        var mh$ = fsync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static FunctionDescriptor sync_volume_np$descriptor() {
        return sync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MethodHandle sync_volume_np$handle() {
        return sync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MemorySegment sync_volume_np$address() {
        return sync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static int sync_volume_np(MemorySegment x0, int x1) {
        var mh$ = sync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optreset$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("optreset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static OfInt optreset$layout() {
        return optreset$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static MemorySegment optreset$segment() {
        return optreset$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static int optreset() {
        return optreset$constants.SEGMENT.get(optreset$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static void optreset(int varValue) {
        optreset$constants.SEGMENT.set(optreset$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef uintptr_t Py_uintptr_t
     * }
     */
    public static final OfLong Py_uintptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t Py_intptr_t
     * }
     */
    public static final OfLong Py_intptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ssize_t Py_ssize_t
     * }
     */
    public static final OfLong Py_ssize_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t Py_hash_t
     * }
     */
    public static final OfLong Py_hash_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t Py_uhash_t
     * }
     */
    public static final OfLong Py_uhash_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t Py_ssize_clean_t
     * }
     */
    public static final OfLong Py_ssize_clean_t = Python_h.C_LONG;

    private static class PyMem_Malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyMem_Malloc$descriptor() {
        return PyMem_Malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MethodHandle PyMem_Malloc$handle() {
        return PyMem_Malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_Malloc$address() {
        return PyMem_Malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_Malloc(long size) {
        var mh$ = PyMem_Malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyMem_Calloc$descriptor() {
        return PyMem_Calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyMem_Calloc$handle() {
        return PyMem_Calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_Calloc$address() {
        return PyMem_Calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_Calloc(long nelem, long elsize) {
        var mh$ = PyMem_Calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Calloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyMem_Realloc$descriptor() {
        return PyMem_Realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyMem_Realloc$handle() {
        return PyMem_Realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_Realloc$address() {
        return PyMem_Realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_Realloc(MemorySegment ptr, long new_size) {
        var mh$ = PyMem_Realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Realloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static FunctionDescriptor PyMem_Free$descriptor() {
        return PyMem_Free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static MethodHandle PyMem_Free$handle() {
        return PyMem_Free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static MemorySegment PyMem_Free$address() {
        return PyMem_Free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static void PyMem_Free(MemorySegment ptr) {
        var mh$ = PyMem_Free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawMalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawMalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyMem_RawMalloc$descriptor() {
        return PyMem_RawMalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static MethodHandle PyMem_RawMalloc$handle() {
        return PyMem_RawMalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_RawMalloc$address() {
        return PyMem_RawMalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_RawMalloc(long size) {
        var mh$ = PyMem_RawMalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawMalloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawCalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawCalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyMem_RawCalloc$descriptor() {
        return PyMem_RawCalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyMem_RawCalloc$handle() {
        return PyMem_RawCalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_RawCalloc$address() {
        return PyMem_RawCalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_RawCalloc(long nelem, long elsize) {
        var mh$ = PyMem_RawCalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawCalloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawRealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawRealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyMem_RawRealloc$descriptor() {
        return PyMem_RawRealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyMem_RawRealloc$handle() {
        return PyMem_RawRealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_RawRealloc$address() {
        return PyMem_RawRealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_RawRealloc(MemorySegment ptr, long new_size) {
        var mh$ = PyMem_RawRealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawRealloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static FunctionDescriptor PyMem_RawFree$descriptor() {
        return PyMem_RawFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static MethodHandle PyMem_RawFree$handle() {
        return PyMem_RawFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static MemorySegment PyMem_RawFree$address() {
        return PyMem_RawFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static void PyMem_RawFree(MemorySegment ptr) {
        var mh$ = PyMem_RawFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawFree", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PYMEM_DOMAIN_RAW = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_DOMAIN_RAW = 0
     * }
     */
    public static int PYMEM_DOMAIN_RAW() {
        return PYMEM_DOMAIN_RAW;
    }
    private static final int PYMEM_DOMAIN_MEM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_DOMAIN_MEM = 1
     * }
     */
    public static int PYMEM_DOMAIN_MEM() {
        return PYMEM_DOMAIN_MEM;
    }
    private static final int PYMEM_DOMAIN_OBJ = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_DOMAIN_OBJ = 2
     * }
     */
    public static int PYMEM_DOMAIN_OBJ() {
        return PYMEM_DOMAIN_OBJ;
    }
    private static final int PYMEM_ALLOCATOR_NOT_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_NOT_SET = 0
     * }
     */
    public static int PYMEM_ALLOCATOR_NOT_SET() {
        return PYMEM_ALLOCATOR_NOT_SET;
    }
    private static final int PYMEM_ALLOCATOR_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_DEFAULT = 1
     * }
     */
    public static int PYMEM_ALLOCATOR_DEFAULT() {
        return PYMEM_ALLOCATOR_DEFAULT;
    }
    private static final int PYMEM_ALLOCATOR_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_DEBUG = 2
     * }
     */
    public static int PYMEM_ALLOCATOR_DEBUG() {
        return PYMEM_ALLOCATOR_DEBUG;
    }
    private static final int PYMEM_ALLOCATOR_MALLOC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_MALLOC = 3
     * }
     */
    public static int PYMEM_ALLOCATOR_MALLOC() {
        return PYMEM_ALLOCATOR_MALLOC;
    }
    private static final int PYMEM_ALLOCATOR_MALLOC_DEBUG = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_MALLOC_DEBUG = 4
     * }
     */
    public static int PYMEM_ALLOCATOR_MALLOC_DEBUG() {
        return PYMEM_ALLOCATOR_MALLOC_DEBUG;
    }
    private static final int PYMEM_ALLOCATOR_PYMALLOC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_PYMALLOC = 5
     * }
     */
    public static int PYMEM_ALLOCATOR_PYMALLOC() {
        return PYMEM_ALLOCATOR_PYMALLOC;
    }
    private static final int PYMEM_ALLOCATOR_PYMALLOC_DEBUG = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_PYMALLOC_DEBUG = 6
     * }
     */
    public static int PYMEM_ALLOCATOR_PYMALLOC_DEBUG() {
        return PYMEM_ALLOCATOR_PYMALLOC_DEBUG;
    }
    private static final int PYMEM_ALLOCATOR_MIMALLOC = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_MIMALLOC = 7
     * }
     */
    public static int PYMEM_ALLOCATOR_MIMALLOC() {
        return PYMEM_ALLOCATOR_MIMALLOC;
    }
    private static final int PYMEM_ALLOCATOR_MIMALLOC_DEBUG = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_MIMALLOC_DEBUG = 8
     * }
     */
    public static int PYMEM_ALLOCATOR_MIMALLOC_DEBUG() {
        return PYMEM_ALLOCATOR_MIMALLOC_DEBUG;
    }

    private static class PyMem_GetAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_GetAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static FunctionDescriptor PyMem_GetAllocator$descriptor() {
        return PyMem_GetAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MethodHandle PyMem_GetAllocator$handle() {
        return PyMem_GetAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MemorySegment PyMem_GetAllocator$address() {
        return PyMem_GetAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static void PyMem_GetAllocator(int domain, MemorySegment allocator) {
        var mh$ = PyMem_GetAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_GetAllocator", domain, allocator);
            }
            mh$.invokeExact(domain, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_SetAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_SetAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static FunctionDescriptor PyMem_SetAllocator$descriptor() {
        return PyMem_SetAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MethodHandle PyMem_SetAllocator$handle() {
        return PyMem_SetAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MemorySegment PyMem_SetAllocator$address() {
        return PyMem_SetAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static void PyMem_SetAllocator(int domain, MemorySegment allocator) {
        var mh$ = PyMem_SetAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_SetAllocator", domain, allocator);
            }
            mh$.invokeExact(domain, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_SetupDebugHooks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_SetupDebugHooks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static FunctionDescriptor PyMem_SetupDebugHooks$descriptor() {
        return PyMem_SetupDebugHooks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static MethodHandle PyMem_SetupDebugHooks$handle() {
        return PyMem_SetupDebugHooks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static MemorySegment PyMem_SetupDebugHooks$address() {
        return PyMem_SetupDebugHooks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static void PyMem_SetupDebugHooks() {
        var mh$ = PyMem_SetupDebugHooks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_SetupDebugHooks");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CheckBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CheckBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_CheckBuffer$descriptor() {
        return PyObject_CheckBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_CheckBuffer$handle() {
        return PyObject_CheckBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_CheckBuffer$address() {
        return PyObject_CheckBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static int PyObject_CheckBuffer(MemorySegment obj) {
        var mh$ = PyObject_CheckBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CheckBuffer", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static FunctionDescriptor PyObject_GetBuffer$descriptor() {
        return PyObject_GetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static MethodHandle PyObject_GetBuffer$handle() {
        return PyObject_GetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static MemorySegment PyObject_GetBuffer$address() {
        return PyObject_GetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static int PyObject_GetBuffer(MemorySegment obj, MemorySegment view, int flags) {
        var mh$ = PyObject_GetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetBuffer", obj, view, flags);
            }
            return (int)mh$.invokeExact(obj, view, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_GetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_GetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static FunctionDescriptor PyBuffer_GetPointer$descriptor() {
        return PyBuffer_GetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MethodHandle PyBuffer_GetPointer$handle() {
        return PyBuffer_GetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MemorySegment PyBuffer_GetPointer$address() {
        return PyBuffer_GetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MemorySegment PyBuffer_GetPointer(MemorySegment view, MemorySegment indices) {
        var mh$ = PyBuffer_GetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_GetPointer", view, indices);
            }
            return (MemorySegment)mh$.invokeExact(view, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_SizeFromFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_SizeFromFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static FunctionDescriptor PyBuffer_SizeFromFormat$descriptor() {
        return PyBuffer_SizeFromFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static MethodHandle PyBuffer_SizeFromFormat$handle() {
        return PyBuffer_SizeFromFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static MemorySegment PyBuffer_SizeFromFormat$address() {
        return PyBuffer_SizeFromFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static long PyBuffer_SizeFromFormat(MemorySegment format) {
        var mh$ = PyBuffer_SizeFromFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_SizeFromFormat", format);
            }
            return (long)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_ToContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_ToContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static FunctionDescriptor PyBuffer_ToContiguous$descriptor() {
        return PyBuffer_ToContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static MethodHandle PyBuffer_ToContiguous$handle() {
        return PyBuffer_ToContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static MemorySegment PyBuffer_ToContiguous$address() {
        return PyBuffer_ToContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static int PyBuffer_ToContiguous(MemorySegment buf, MemorySegment view, long len, byte order) {
        var mh$ = PyBuffer_ToContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_ToContiguous", buf, view, len, order);
            }
            return (int)mh$.invokeExact(buf, view, len, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FromContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FromContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static FunctionDescriptor PyBuffer_FromContiguous$descriptor() {
        return PyBuffer_FromContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static MethodHandle PyBuffer_FromContiguous$handle() {
        return PyBuffer_FromContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static MemorySegment PyBuffer_FromContiguous$address() {
        return PyBuffer_FromContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static int PyBuffer_FromContiguous(MemorySegment view, MemorySegment buf, long len, byte order) {
        var mh$ = PyBuffer_FromContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FromContiguous", view, buf, len, order);
            }
            return (int)mh$.invokeExact(view, buf, len, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CopyData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CopyData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static FunctionDescriptor PyObject_CopyData$descriptor() {
        return PyObject_CopyData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static MethodHandle PyObject_CopyData$handle() {
        return PyObject_CopyData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static MemorySegment PyObject_CopyData$address() {
        return PyObject_CopyData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static int PyObject_CopyData(MemorySegment dest, MemorySegment src) {
        var mh$ = PyObject_CopyData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CopyData", dest, src);
            }
            return (int)mh$.invokeExact(dest, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_IsContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_IsContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static FunctionDescriptor PyBuffer_IsContiguous$descriptor() {
        return PyBuffer_IsContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static MethodHandle PyBuffer_IsContiguous$handle() {
        return PyBuffer_IsContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static MemorySegment PyBuffer_IsContiguous$address() {
        return PyBuffer_IsContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static int PyBuffer_IsContiguous(MemorySegment view, byte fort) {
        var mh$ = PyBuffer_IsContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_IsContiguous", view, fort);
            }
            return (int)mh$.invokeExact(view, fort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FillContiguousStrides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FillContiguousStrides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static FunctionDescriptor PyBuffer_FillContiguousStrides$descriptor() {
        return PyBuffer_FillContiguousStrides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static MethodHandle PyBuffer_FillContiguousStrides$handle() {
        return PyBuffer_FillContiguousStrides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static MemorySegment PyBuffer_FillContiguousStrides$address() {
        return PyBuffer_FillContiguousStrides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static void PyBuffer_FillContiguousStrides(int ndims, MemorySegment shape, MemorySegment strides, int itemsize, byte fort) {
        var mh$ = PyBuffer_FillContiguousStrides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FillContiguousStrides", ndims, shape, strides, itemsize, fort);
            }
            mh$.invokeExact(ndims, shape, strides, itemsize, fort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FillInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FillInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static FunctionDescriptor PyBuffer_FillInfo$descriptor() {
        return PyBuffer_FillInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static MethodHandle PyBuffer_FillInfo$handle() {
        return PyBuffer_FillInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static MemorySegment PyBuffer_FillInfo$address() {
        return PyBuffer_FillInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static int PyBuffer_FillInfo(MemorySegment view, MemorySegment o, MemorySegment buf, long len, int readonly, int flags) {
        var mh$ = PyBuffer_FillInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FillInfo", view, o, buf, len, readonly, flags);
            }
            return (int)mh$.invokeExact(view, o, buf, len, readonly, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static FunctionDescriptor PyBuffer_Release$descriptor() {
        return PyBuffer_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static MethodHandle PyBuffer_Release$handle() {
        return PyBuffer_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static MemorySegment PyBuffer_Release$address() {
        return PyBuffer_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static void PyBuffer_Release(MemorySegment view) {
        var mh$ = PyBuffer_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_Release", view);
            }
            mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMutex_Lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMutex_Lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMutex_Lock(PyMutex *m)
     * }
     */
    public static FunctionDescriptor PyMutex_Lock$descriptor() {
        return PyMutex_Lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMutex_Lock(PyMutex *m)
     * }
     */
    public static MethodHandle PyMutex_Lock$handle() {
        return PyMutex_Lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMutex_Lock(PyMutex *m)
     * }
     */
    public static MemorySegment PyMutex_Lock$address() {
        return PyMutex_Lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMutex_Lock(PyMutex *m)
     * }
     */
    public static void PyMutex_Lock(MemorySegment m) {
        var mh$ = PyMutex_Lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMutex_Lock", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMutex_Unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMutex_Unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMutex_Unlock(PyMutex *m)
     * }
     */
    public static FunctionDescriptor PyMutex_Unlock$descriptor() {
        return PyMutex_Unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMutex_Unlock(PyMutex *m)
     * }
     */
    public static MethodHandle PyMutex_Unlock$handle() {
        return PyMutex_Unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMutex_Unlock(PyMutex *m)
     * }
     */
    public static MemorySegment PyMutex_Unlock$address() {
        return PyMutex_Unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMutex_Unlock(PyMutex *m)
     * }
     */
    public static void PyMutex_Unlock(MemorySegment m) {
        var mh$ = PyMutex_Unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMutex_Unlock", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Is {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Is");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static FunctionDescriptor Py_Is$descriptor() {
        return Py_Is.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static MethodHandle Py_Is$handle() {
        return Py_Is.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static MemorySegment Py_Is$address() {
        return Py_Is.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static int Py_Is(MemorySegment x, MemorySegment y) {
        var mh$ = Py_Is.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Is", x, y);
            }
            return (int)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyLong_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static GroupLayout PyLong_Type$layout() {
        return PyLong_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static MemorySegment PyLong_Type() {
        return PyLong_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static void PyLong_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyLong_Type$constants.SEGMENT, 0L, PyLong_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBool_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBool_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static GroupLayout PyBool_Type$layout() {
        return PyBool_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static MemorySegment PyBool_Type() {
        return PyBool_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static void PyBool_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBool_Type$constants.SEGMENT, 0L, PyBool_Type$constants.LAYOUT.byteSize());
    }

    private static class _Py_SetRefcnt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_SetRefcnt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_SetRefcnt(PyObject *ob, Py_ssize_t refcnt)
     * }
     */
    public static FunctionDescriptor _Py_SetRefcnt$descriptor() {
        return _Py_SetRefcnt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_SetRefcnt(PyObject *ob, Py_ssize_t refcnt)
     * }
     */
    public static MethodHandle _Py_SetRefcnt$handle() {
        return _Py_SetRefcnt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_SetRefcnt(PyObject *ob, Py_ssize_t refcnt)
     * }
     */
    public static MemorySegment _Py_SetRefcnt$address() {
        return _Py_SetRefcnt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_SetRefcnt(PyObject *ob, Py_ssize_t refcnt)
     * }
     */
    public static void _Py_SetRefcnt(MemorySegment ob, long refcnt) {
        var mh$ = _Py_SetRefcnt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_SetRefcnt", ob, refcnt);
            }
            mh$.invokeExact(ob, refcnt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromSpec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromSpec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static FunctionDescriptor PyType_FromSpec$descriptor() {
        return PyType_FromSpec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MethodHandle PyType_FromSpec$handle() {
        return PyType_FromSpec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MemorySegment PyType_FromSpec$address() {
        return PyType_FromSpec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MemorySegment PyType_FromSpec(MemorySegment x0) {
        var mh$ = PyType_FromSpec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromSpec", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromSpecWithBases {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromSpecWithBases");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromSpecWithBases$descriptor() {
        return PyType_FromSpecWithBases.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromSpecWithBases$handle() {
        return PyType_FromSpecWithBases.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromSpecWithBases$address() {
        return PyType_FromSpecWithBases.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromSpecWithBases(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_FromSpecWithBases.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromSpecWithBases", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetSlot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetSlot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static FunctionDescriptor PyType_GetSlot$descriptor() {
        return PyType_GetSlot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MethodHandle PyType_GetSlot$handle() {
        return PyType_GetSlot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MemorySegment PyType_GetSlot$address() {
        return PyType_GetSlot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MemorySegment PyType_GetSlot(MemorySegment x0, int x1) {
        var mh$ = PyType_GetSlot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetSlot", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromModuleAndSpec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromModuleAndSpec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromModuleAndSpec$descriptor() {
        return PyType_FromModuleAndSpec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromModuleAndSpec$handle() {
        return PyType_FromModuleAndSpec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromModuleAndSpec$address() {
        return PyType_FromModuleAndSpec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromModuleAndSpec(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyType_FromModuleAndSpec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromModuleAndSpec", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetModule$descriptor() {
        return PyType_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetModule$handle() {
        return PyType_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModule$address() {
        return PyType_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModule(MemorySegment x0) {
        var mh$ = PyType_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModuleState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModuleState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetModuleState$descriptor() {
        return PyType_GetModuleState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetModuleState$handle() {
        return PyType_GetModuleState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModuleState$address() {
        return PyType_GetModuleState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModuleState(MemorySegment x0) {
        var mh$ = PyType_GetModuleState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModuleState", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetName$descriptor() {
        return PyType_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetName$handle() {
        return PyType_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetName$address() {
        return PyType_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetName(MemorySegment x0) {
        var mh$ = PyType_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetQualName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetQualName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetQualName$descriptor() {
        return PyType_GetQualName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetQualName$handle() {
        return PyType_GetQualName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetQualName$address() {
        return PyType_GetQualName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetQualName(MemorySegment x0) {
        var mh$ = PyType_GetQualName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetQualName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetFullyQualifiedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetFullyQualifiedName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetFullyQualifiedName(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyType_GetFullyQualifiedName$descriptor() {
        return PyType_GetFullyQualifiedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetFullyQualifiedName(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyType_GetFullyQualifiedName$handle() {
        return PyType_GetFullyQualifiedName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetFullyQualifiedName(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyType_GetFullyQualifiedName$address() {
        return PyType_GetFullyQualifiedName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetFullyQualifiedName(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyType_GetFullyQualifiedName(MemorySegment type) {
        var mh$ = PyType_GetFullyQualifiedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetFullyQualifiedName", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModuleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModuleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleName(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyType_GetModuleName$descriptor() {
        return PyType_GetModuleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleName(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyType_GetModuleName$handle() {
        return PyType_GetModuleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleName(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyType_GetModuleName$address() {
        return PyType_GetModuleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleName(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyType_GetModuleName(MemorySegment type) {
        var mh$ = PyType_GetModuleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModuleName", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromMetaclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromMetaclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromMetaclass$descriptor() {
        return PyType_FromMetaclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromMetaclass$handle() {
        return PyType_FromMetaclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromMetaclass$address() {
        return PyType_FromMetaclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromMetaclass(PyTypeObject *, PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromMetaclass(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyType_FromMetaclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromMetaclass", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetTypeData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetTypeData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static FunctionDescriptor PyObject_GetTypeData$descriptor() {
        return PyObject_GetTypeData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static MethodHandle PyObject_GetTypeData$handle() {
        return PyObject_GetTypeData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static MemorySegment PyObject_GetTypeData$address() {
        return PyObject_GetTypeData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_GetTypeData(PyObject *obj, PyTypeObject *cls)
     * }
     */
    public static MemorySegment PyObject_GetTypeData(MemorySegment obj, MemorySegment cls) {
        var mh$ = PyObject_GetTypeData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetTypeData", obj, cls);
            }
            return (MemorySegment)mh$.invokeExact(obj, cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetTypeDataSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetTypeDataSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static FunctionDescriptor PyType_GetTypeDataSize$descriptor() {
        return PyType_GetTypeDataSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static MethodHandle PyType_GetTypeDataSize$handle() {
        return PyType_GetTypeDataSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static MemorySegment PyType_GetTypeDataSize$address() {
        return PyType_GetTypeDataSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
     * }
     */
    public static long PyType_GetTypeDataSize(MemorySegment cls) {
        var mh$ = PyType_GetTypeDataSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetTypeDataSize", cls);
            }
            return (long)mh$.invokeExact(cls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_IsSubtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_IsSubtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_IsSubtype$descriptor() {
        return PyType_IsSubtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_IsSubtype$handle() {
        return PyType_IsSubtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_IsSubtype$address() {
        return PyType_IsSubtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static int PyType_IsSubtype(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_IsSubtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_IsSubtype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyType_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static GroupLayout PyType_Type$layout() {
        return PyType_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static MemorySegment PyType_Type() {
        return PyType_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static void PyType_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyType_Type$constants.SEGMENT, 0L, PyType_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBaseObject_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBaseObject_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static GroupLayout PyBaseObject_Type$layout() {
        return PyBaseObject_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static MemorySegment PyBaseObject_Type() {
        return PyBaseObject_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static void PyBaseObject_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBaseObject_Type$constants.SEGMENT, 0L, PyBaseObject_Type$constants.LAYOUT.byteSize());
    }

    private static class PySuper_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySuper_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static GroupLayout PySuper_Type$layout() {
        return PySuper_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static MemorySegment PySuper_Type() {
        return PySuper_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static void PySuper_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySuper_Type$constants.SEGMENT, 0L, PySuper_Type$constants.LAYOUT.byteSize());
    }

    private static class PyType_GetFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetFlags$descriptor() {
        return PyType_GetFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetFlags$handle() {
        return PyType_GetFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetFlags$address() {
        return PyType_GetFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static long PyType_GetFlags(MemorySegment x0) {
        var mh$ = PyType_GetFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetFlags", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Ready {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Ready");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_Ready$descriptor() {
        return PyType_Ready.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_Ready$handle() {
        return PyType_Ready.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_Ready$address() {
        return PyType_Ready.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static int PyType_Ready(MemorySegment x0) {
        var mh$ = PyType_Ready.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Ready", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GenericAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GenericAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyType_GenericAlloc$descriptor() {
        return PyType_GenericAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyType_GenericAlloc$handle() {
        return PyType_GenericAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyType_GenericAlloc$address() {
        return PyType_GenericAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyType_GenericAlloc(MemorySegment x0, long x1) {
        var mh$ = PyType_GenericAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GenericAlloc", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GenericNew {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GenericNew");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_GenericNew$descriptor() {
        return PyType_GenericNew.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyType_GenericNew$handle() {
        return PyType_GenericNew.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyType_GenericNew$address() {
        return PyType_GenericNew.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyType_GenericNew(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyType_GenericNew.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GenericNew", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_ClearCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_ClearCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static FunctionDescriptor PyType_ClearCache$descriptor() {
        return PyType_ClearCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static MethodHandle PyType_ClearCache$handle() {
        return PyType_ClearCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static MemorySegment PyType_ClearCache$address() {
        return PyType_ClearCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static int PyType_ClearCache() {
        var mh$ = PyType_ClearCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_ClearCache");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Modified {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Modified");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_Modified$descriptor() {
        return PyType_Modified.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_Modified$handle() {
        return PyType_Modified.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_Modified$address() {
        return PyType_Modified.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static void PyType_Modified(MemorySegment x0) {
        var mh$ = PyType_Modified.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Modified", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Repr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Repr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Repr$descriptor() {
        return PyObject_Repr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Repr$handle() {
        return PyObject_Repr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Repr$address() {
        return PyObject_Repr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Repr(MemorySegment x0) {
        var mh$ = PyObject_Repr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Repr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Str$descriptor() {
        return PyObject_Str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Str$handle() {
        return PyObject_Str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Str$address() {
        return PyObject_Str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Str(MemorySegment x0) {
        var mh$ = PyObject_Str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Str", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_ASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_ASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_ASCII$descriptor() {
        return PyObject_ASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MethodHandle PyObject_ASCII$handle() {
        return PyObject_ASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ASCII$address() {
        return PyObject_ASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ASCII(MemorySegment x0) {
        var mh$ = PyObject_ASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_ASCII", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Bytes$descriptor() {
        return PyObject_Bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Bytes$handle() {
        return PyObject_Bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Bytes$address() {
        return PyObject_Bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Bytes(MemorySegment x0) {
        var mh$ = PyObject_Bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Bytes", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_RichCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_RichCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyObject_RichCompare$descriptor() {
        return PyObject_RichCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyObject_RichCompare$handle() {
        return PyObject_RichCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompare$address() {
        return PyObject_RichCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompare(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_RichCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_RichCompare", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_RichCompareBool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_RichCompareBool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyObject_RichCompareBool$descriptor() {
        return PyObject_RichCompareBool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyObject_RichCompareBool$handle() {
        return PyObject_RichCompareBool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompareBool$address() {
        return PyObject_RichCompareBool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static int PyObject_RichCompareBool(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_RichCompareBool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_RichCompareBool", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAttrString$descriptor() {
        return PyObject_GetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyObject_GetAttrString$handle() {
        return PyObject_GetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_GetAttrString$address() {
        return PyObject_GetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_GetAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAttrString", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SetAttrString$descriptor() {
        return PyObject_SetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_SetAttrString$handle() {
        return PyObject_SetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_SetAttrString$address() {
        return PyObject_SetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static int PyObject_SetAttrString(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_SetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetAttrString", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_DelAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_DelAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_DelAttrString(PyObject *v, const char *name)
     * }
     */
    public static FunctionDescriptor PyObject_DelAttrString$descriptor() {
        return PyObject_DelAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_DelAttrString(PyObject *v, const char *name)
     * }
     */
    public static MethodHandle PyObject_DelAttrString$handle() {
        return PyObject_DelAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_DelAttrString(PyObject *v, const char *name)
     * }
     */
    public static MemorySegment PyObject_DelAttrString$address() {
        return PyObject_DelAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_DelAttrString(PyObject *v, const char *name)
     * }
     */
    public static int PyObject_DelAttrString(MemorySegment v, MemorySegment name) {
        var mh$ = PyObject_DelAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_DelAttrString", v, name);
            }
            return (int)mh$.invokeExact(v, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttrString$descriptor() {
        return PyObject_HasAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyObject_HasAttrString$handle() {
        return PyObject_HasAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_HasAttrString$address() {
        return PyObject_HasAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static int PyObject_HasAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttrString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAttr$descriptor() {
        return PyObject_GetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetAttr$handle() {
        return PyObject_GetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAttr$address() {
        return PyObject_GetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetOptionalAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetOptionalAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GetOptionalAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static FunctionDescriptor PyObject_GetOptionalAttr$descriptor() {
        return PyObject_GetOptionalAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GetOptionalAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MethodHandle PyObject_GetOptionalAttr$handle() {
        return PyObject_GetOptionalAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GetOptionalAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MemorySegment PyObject_GetOptionalAttr$address() {
        return PyObject_GetOptionalAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GetOptionalAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static int PyObject_GetOptionalAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GetOptionalAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetOptionalAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetOptionalAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetOptionalAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GetOptionalAttrString(PyObject *, const char *, PyObject **)
     * }
     */
    public static FunctionDescriptor PyObject_GetOptionalAttrString$descriptor() {
        return PyObject_GetOptionalAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GetOptionalAttrString(PyObject *, const char *, PyObject **)
     * }
     */
    public static MethodHandle PyObject_GetOptionalAttrString$handle() {
        return PyObject_GetOptionalAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GetOptionalAttrString(PyObject *, const char *, PyObject **)
     * }
     */
    public static MemorySegment PyObject_GetOptionalAttrString$address() {
        return PyObject_GetOptionalAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GetOptionalAttrString(PyObject *, const char *, PyObject **)
     * }
     */
    public static int PyObject_GetOptionalAttrString(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GetOptionalAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetOptionalAttrString", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SetAttr$descriptor() {
        return PyObject_SetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_SetAttr$handle() {
        return PyObject_SetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_SetAttr$address() {
        return PyObject_SetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int PyObject_SetAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_SetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_DelAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_DelAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_DelAttr(PyObject *v, PyObject *name)
     * }
     */
    public static FunctionDescriptor PyObject_DelAttr$descriptor() {
        return PyObject_DelAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_DelAttr(PyObject *v, PyObject *name)
     * }
     */
    public static MethodHandle PyObject_DelAttr$handle() {
        return PyObject_DelAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_DelAttr(PyObject *v, PyObject *name)
     * }
     */
    public static MemorySegment PyObject_DelAttr$address() {
        return PyObject_DelAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_DelAttr(PyObject *v, PyObject *name)
     * }
     */
    public static int PyObject_DelAttr(MemorySegment v, MemorySegment name) {
        var mh$ = PyObject_DelAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_DelAttr", v, name);
            }
            return (int)mh$.invokeExact(v, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttr$descriptor() {
        return PyObject_HasAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_HasAttr$handle() {
        return PyObject_HasAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_HasAttr$address() {
        return PyObject_HasAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static int PyObject_HasAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttr", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttrWithError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttrWithError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttrWithError(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttrWithError$descriptor() {
        return PyObject_HasAttrWithError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttrWithError(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_HasAttrWithError$handle() {
        return PyObject_HasAttrWithError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttrWithError(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_HasAttrWithError$address() {
        return PyObject_HasAttrWithError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttrWithError(PyObject *, PyObject *)
     * }
     */
    public static int PyObject_HasAttrWithError(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttrWithError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttrWithError", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttrStringWithError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttrStringWithError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttrStringWithError(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttrStringWithError$descriptor() {
        return PyObject_HasAttrStringWithError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttrStringWithError(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyObject_HasAttrStringWithError$handle() {
        return PyObject_HasAttrStringWithError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttrStringWithError(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_HasAttrStringWithError$address() {
        return PyObject_HasAttrStringWithError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttrStringWithError(PyObject *, const char *)
     * }
     */
    public static int PyObject_HasAttrStringWithError(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttrStringWithError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttrStringWithError", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SelfIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SelfIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SelfIter$descriptor() {
        return PyObject_SelfIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_SelfIter$handle() {
        return PyObject_SelfIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_SelfIter$address() {
        return PyObject_SelfIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_SelfIter(MemorySegment x0) {
        var mh$ = PyObject_SelfIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SelfIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericGetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericGetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericGetAttr$descriptor() {
        return PyObject_GenericGetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GenericGetAttr$handle() {
        return PyObject_GenericGetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericGetAttr$address() {
        return PyObject_GenericGetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericGetAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GenericGetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericGetAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericSetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericSetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericSetAttr$descriptor() {
        return PyObject_GenericSetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GenericSetAttr$handle() {
        return PyObject_GenericSetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericSetAttr$address() {
        return PyObject_GenericSetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int PyObject_GenericSetAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GenericSetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericSetAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericSetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericSetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericSetDict$descriptor() {
        return PyObject_GenericSetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static MethodHandle PyObject_GenericSetDict$handle() {
        return PyObject_GenericSetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericSetDict$address() {
        return PyObject_GenericSetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static int PyObject_GenericSetDict(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GenericSetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericSetDict", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Hash$descriptor() {
        return PyObject_Hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Hash$handle() {
        return PyObject_Hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Hash$address() {
        return PyObject_Hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static long PyObject_Hash(MemorySegment x0) {
        var mh$ = PyObject_Hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Hash", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HashNotImplemented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HashNotImplemented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_HashNotImplemented$descriptor() {
        return PyObject_HashNotImplemented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static MethodHandle PyObject_HashNotImplemented$handle() {
        return PyObject_HashNotImplemented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static MemorySegment PyObject_HashNotImplemented$address() {
        return PyObject_HashNotImplemented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static long PyObject_HashNotImplemented(MemorySegment x0) {
        var mh$ = PyObject_HashNotImplemented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HashNotImplemented", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IsTrue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IsTrue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_IsTrue$descriptor() {
        return PyObject_IsTrue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static MethodHandle PyObject_IsTrue$handle() {
        return PyObject_IsTrue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static MemorySegment PyObject_IsTrue$address() {
        return PyObject_IsTrue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static int PyObject_IsTrue(MemorySegment x0) {
        var mh$ = PyObject_IsTrue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IsTrue", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Not {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Not");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Not$descriptor() {
        return PyObject_Not.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Not$handle() {
        return PyObject_Not.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Not$address() {
        return PyObject_Not.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static int PyObject_Not(MemorySegment x0) {
        var mh$ = PyObject_Not.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Not", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCallable_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCallable_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCallable_Check$descriptor() {
        return PyCallable_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static MethodHandle PyCallable_Check$handle() {
        return PyCallable_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static MemorySegment PyCallable_Check$address() {
        return PyCallable_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static int PyCallable_Check(MemorySegment x0) {
        var mh$ = PyCallable_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCallable_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_ClearWeakRefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_ClearWeakRefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_ClearWeakRefs$descriptor() {
        return PyObject_ClearWeakRefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static MethodHandle PyObject_ClearWeakRefs$handle() {
        return PyObject_ClearWeakRefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ClearWeakRefs$address() {
        return PyObject_ClearWeakRefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static void PyObject_ClearWeakRefs(MemorySegment x0) {
        var mh$ = PyObject_ClearWeakRefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_ClearWeakRefs", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Dir$descriptor() {
        return PyObject_Dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Dir$handle() {
        return PyObject_Dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Dir$address() {
        return PyObject_Dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Dir(MemorySegment x0) {
        var mh$ = PyObject_Dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Dir", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ReprEnter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ReprEnter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_ReprEnter$descriptor() {
        return Py_ReprEnter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static MethodHandle Py_ReprEnter$handle() {
        return Py_ReprEnter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static MemorySegment Py_ReprEnter$address() {
        return Py_ReprEnter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static int Py_ReprEnter(MemorySegment x0) {
        var mh$ = Py_ReprEnter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ReprEnter", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ReprLeave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ReprLeave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_ReprLeave$descriptor() {
        return Py_ReprLeave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static MethodHandle Py_ReprLeave$handle() {
        return Py_ReprLeave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static MemorySegment Py_ReprLeave$address() {
        return Py_ReprLeave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static void Py_ReprLeave(MemorySegment x0) {
        var mh$ = Py_ReprLeave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ReprLeave", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_Dealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_Dealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_Dealloc$descriptor() {
        return _Py_Dealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static MethodHandle _Py_Dealloc$handle() {
        return _Py_Dealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static MemorySegment _Py_Dealloc$address() {
        return _Py_Dealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static void _Py_Dealloc(MemorySegment x0) {
        var mh$ = _Py_Dealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_Dealloc", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IncRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IncRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_IncRef$descriptor() {
        return Py_IncRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static MethodHandle Py_IncRef$handle() {
        return Py_IncRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static MemorySegment Py_IncRef$address() {
        return Py_IncRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static void Py_IncRef(MemorySegment x0) {
        var mh$ = Py_IncRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IncRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_DecRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_DecRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_DecRef$descriptor() {
        return Py_DecRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static MethodHandle Py_DecRef$handle() {
        return Py_DecRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static MemorySegment Py_DecRef$address() {
        return Py_DecRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static void Py_DecRef(MemorySegment x0) {
        var mh$ = Py_DecRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_DecRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_IncRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_IncRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_IncRef$descriptor() {
        return _Py_IncRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static MethodHandle _Py_IncRef$handle() {
        return _Py_IncRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static MemorySegment _Py_IncRef$address() {
        return _Py_IncRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static void _Py_IncRef(MemorySegment x0) {
        var mh$ = _Py_IncRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_IncRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_DecRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_DecRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_DecRef$descriptor() {
        return _Py_DecRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static MethodHandle _Py_DecRef$handle() {
        return _Py_DecRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static MemorySegment _Py_DecRef$address() {
        return _Py_DecRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static void _Py_DecRef(MemorySegment x0) {
        var mh$ = _Py_DecRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_DecRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_NewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_NewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static FunctionDescriptor Py_NewRef$descriptor() {
        return Py_NewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MethodHandle Py_NewRef$handle() {
        return Py_NewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_NewRef$address() {
        return Py_NewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_NewRef(MemorySegment obj) {
        var mh$ = Py_NewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_NewRef", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_XNewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_XNewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static FunctionDescriptor Py_XNewRef$descriptor() {
        return Py_XNewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MethodHandle Py_XNewRef$handle() {
        return Py_XNewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_XNewRef$address() {
        return Py_XNewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_XNewRef(MemorySegment obj) {
        var mh$ = Py_XNewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_XNewRef", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_GetConstant(unsigned int constant_id)
     * }
     */
    public static FunctionDescriptor Py_GetConstant$descriptor() {
        return Py_GetConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_GetConstant(unsigned int constant_id)
     * }
     */
    public static MethodHandle Py_GetConstant$handle() {
        return Py_GetConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_GetConstant(unsigned int constant_id)
     * }
     */
    public static MemorySegment Py_GetConstant$address() {
        return Py_GetConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_GetConstant(unsigned int constant_id)
     * }
     */
    public static MemorySegment Py_GetConstant(int constant_id) {
        var mh$ = Py_GetConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetConstant", constant_id);
            }
            return (MemorySegment)mh$.invokeExact(constant_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetConstantBorrowed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetConstantBorrowed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_GetConstantBorrowed(unsigned int constant_id)
     * }
     */
    public static FunctionDescriptor Py_GetConstantBorrowed$descriptor() {
        return Py_GetConstantBorrowed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_GetConstantBorrowed(unsigned int constant_id)
     * }
     */
    public static MethodHandle Py_GetConstantBorrowed$handle() {
        return Py_GetConstantBorrowed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_GetConstantBorrowed(unsigned int constant_id)
     * }
     */
    public static MemorySegment Py_GetConstantBorrowed$address() {
        return Py_GetConstantBorrowed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_GetConstantBorrowed(unsigned int constant_id)
     * }
     */
    public static MemorySegment Py_GetConstantBorrowed(int constant_id) {
        var mh$ = Py_GetConstantBorrowed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetConstantBorrowed", constant_id);
            }
            return (MemorySegment)mh$.invokeExact(constant_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NoneStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_NoneStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static GroupLayout _Py_NoneStruct$layout() {
        return _Py_NoneStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static MemorySegment _Py_NoneStruct() {
        return _Py_NoneStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static void _Py_NoneStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_NoneStruct$constants.SEGMENT, 0L, _Py_NoneStruct$constants.LAYOUT.byteSize());
    }

    private static class Py_IsNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsNone$descriptor() {
        return Py_IsNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsNone$handle() {
        return Py_IsNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsNone$address() {
        return Py_IsNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static int Py_IsNone(MemorySegment x) {
        var mh$ = Py_IsNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsNone", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NotImplementedStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_NotImplementedStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static GroupLayout _Py_NotImplementedStruct$layout() {
        return _Py_NotImplementedStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static MemorySegment _Py_NotImplementedStruct() {
        return _Py_NotImplementedStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static void _Py_NotImplementedStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_NotImplementedStruct$constants.SEGMENT, 0L, _Py_NotImplementedStruct$constants.LAYOUT.byteSize());
    }
    private static final int PYGEN_RETURN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_RETURN = 0
     * }
     */
    public static int PYGEN_RETURN() {
        return PYGEN_RETURN;
    }
    private static final int PYGEN_ERROR = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_ERROR = -1
     * }
     */
    public static int PYGEN_ERROR() {
        return PYGEN_ERROR;
    }
    private static final int PYGEN_NEXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_NEXT = 1
     * }
     */
    public static int PYGEN_NEXT() {
        return PYGEN_NEXT;
    }

    private static class _Py_NewReference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_NewReference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static FunctionDescriptor _Py_NewReference$descriptor() {
        return _Py_NewReference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static MethodHandle _Py_NewReference$handle() {
        return _Py_NewReference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static MemorySegment _Py_NewReference$address() {
        return _Py_NewReference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static void _Py_NewReference(MemorySegment op) {
        var mh$ = _Py_NewReference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_NewReference", op);
            }
            mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NewReferenceNoTotal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_NewReferenceNoTotal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_NewReferenceNoTotal(PyObject *op)
     * }
     */
    public static FunctionDescriptor _Py_NewReferenceNoTotal$descriptor() {
        return _Py_NewReferenceNoTotal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_NewReferenceNoTotal(PyObject *op)
     * }
     */
    public static MethodHandle _Py_NewReferenceNoTotal$handle() {
        return _Py_NewReferenceNoTotal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_NewReferenceNoTotal(PyObject *op)
     * }
     */
    public static MemorySegment _Py_NewReferenceNoTotal$address() {
        return _Py_NewReferenceNoTotal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_NewReferenceNoTotal(PyObject *op)
     * }
     */
    public static void _Py_NewReferenceNoTotal(MemorySegment op) {
        var mh$ = _Py_NewReferenceNoTotal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_NewReferenceNoTotal", op);
            }
            mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_ResurrectReference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_ResurrectReference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_ResurrectReference(PyObject *op)
     * }
     */
    public static FunctionDescriptor _Py_ResurrectReference$descriptor() {
        return _Py_ResurrectReference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_ResurrectReference(PyObject *op)
     * }
     */
    public static MethodHandle _Py_ResurrectReference$handle() {
        return _Py_ResurrectReference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_ResurrectReference(PyObject *op)
     * }
     */
    public static MemorySegment _Py_ResurrectReference$address() {
        return _Py_ResurrectReference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_ResurrectReference(PyObject *op)
     * }
     */
    public static void _Py_ResurrectReference(MemorySegment op) {
        var mh$ = _Py_ResurrectReference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_ResurrectReference", op);
            }
            mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t printfunc
     * }
     */
    public static final OfLong printfunc = Python_h.C_LONG;

    private static class _PyType_Name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_Name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyType_Name$descriptor() {
        return _PyType_Name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyType_Name$handle() {
        return _PyType_Name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyType_Name$address() {
        return _PyType_Name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyType_Name(MemorySegment x0) {
        var mh$ = _PyType_Name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_Name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_Lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_Lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyType_Lookup$descriptor() {
        return _PyType_Lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyType_Lookup$handle() {
        return _PyType_Lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_Lookup$address() {
        return _PyType_Lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_Lookup(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_Lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_Lookup", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_LookupRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_LookupRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_LookupRef(PyTypeObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyType_LookupRef$descriptor() {
        return _PyType_LookupRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_LookupRef(PyTypeObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyType_LookupRef$handle() {
        return _PyType_LookupRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_LookupRef(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_LookupRef$address() {
        return _PyType_LookupRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_LookupRef(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_LookupRef(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_LookupRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_LookupRef", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetDict(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetDict$descriptor() {
        return PyType_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetDict(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetDict$handle() {
        return PyType_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetDict(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetDict$address() {
        return PyType_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetDict(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetDict(MemorySegment x0) {
        var mh$ = PyType_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetDict", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static FunctionDescriptor PyObject_Print$descriptor() {
        return PyObject_Print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static MethodHandle PyObject_Print$handle() {
        return PyObject_Print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static MemorySegment PyObject_Print$address() {
        return PyObject_Print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static int PyObject_Print(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_Print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Print", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_BreakPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_BreakPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static FunctionDescriptor _Py_BreakPoint$descriptor() {
        return _Py_BreakPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static MethodHandle _Py_BreakPoint$handle() {
        return _Py_BreakPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static MemorySegment _Py_BreakPoint$address() {
        return _Py_BreakPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static void _Py_BreakPoint() {
        var mh$ = _Py_BreakPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_BreakPoint");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_Dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_Dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_Dump$descriptor() {
        return _PyObject_Dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_Dump$handle() {
        return _PyObject_Dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_Dump$address() {
        return _PyObject_Dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static void _PyObject_Dump(MemorySegment x0) {
        var mh$ = _PyObject_Dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_Dump", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetAttrId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetAttrId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyObject_GetAttrId$descriptor() {
        return _PyObject_GetAttrId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MethodHandle _PyObject_GetAttrId$handle() {
        return _PyObject_GetAttrId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_GetAttrId$address() {
        return _PyObject_GetAttrId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_GetAttrId(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyObject_GetAttrId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetAttrId", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetDictPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetDictPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GetDictPtr$descriptor() {
        return _PyObject_GetDictPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_GetDictPtr$handle() {
        return _PyObject_GetDictPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetDictPtr$address() {
        return _PyObject_GetDictPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetDictPtr(MemorySegment x0) {
        var mh$ = _PyObject_GetDictPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetDictPtr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallFinalizer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFinalizer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_CallFinalizer$descriptor() {
        return PyObject_CallFinalizer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static MethodHandle PyObject_CallFinalizer$handle() {
        return PyObject_CallFinalizer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static MemorySegment PyObject_CallFinalizer$address() {
        return PyObject_CallFinalizer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static void PyObject_CallFinalizer(MemorySegment x0) {
        var mh$ = PyObject_CallFinalizer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallFinalizer", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallFinalizerFromDealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFinalizerFromDealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_CallFinalizerFromDealloc$descriptor() {
        return PyObject_CallFinalizerFromDealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static MethodHandle PyObject_CallFinalizerFromDealloc$handle() {
        return PyObject_CallFinalizerFromDealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static MemorySegment PyObject_CallFinalizerFromDealloc$address() {
        return PyObject_CallFinalizerFromDealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static int PyObject_CallFinalizerFromDealloc(MemorySegment x0) {
        var mh$ = PyObject_CallFinalizerFromDealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallFinalizerFromDealloc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Object_ClearWeakRefsNoCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Object_ClearWeakRefsNoCallbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnstable_Object_ClearWeakRefsNoCallbacks(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnstable_Object_ClearWeakRefsNoCallbacks$descriptor() {
        return PyUnstable_Object_ClearWeakRefsNoCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnstable_Object_ClearWeakRefsNoCallbacks(PyObject *)
     * }
     */
    public static MethodHandle PyUnstable_Object_ClearWeakRefsNoCallbacks$handle() {
        return PyUnstable_Object_ClearWeakRefsNoCallbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnstable_Object_ClearWeakRefsNoCallbacks(PyObject *)
     * }
     */
    public static MemorySegment PyUnstable_Object_ClearWeakRefsNoCallbacks$address() {
        return PyUnstable_Object_ClearWeakRefsNoCallbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnstable_Object_ClearWeakRefsNoCallbacks(PyObject *)
     * }
     */
    public static void PyUnstable_Object_ClearWeakRefsNoCallbacks(MemorySegment x0) {
        var mh$ = PyUnstable_Object_ClearWeakRefsNoCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Object_ClearWeakRefsNoCallbacks", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GenericGetAttrWithDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GenericGetAttrWithDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor _PyObject_GenericGetAttrWithDict$descriptor() {
        return _PyObject_GenericGetAttrWithDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle _PyObject_GenericGetAttrWithDict$handle() {
        return _PyObject_GenericGetAttrWithDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment _PyObject_GenericGetAttrWithDict$address() {
        return _PyObject_GenericGetAttrWithDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment _PyObject_GenericGetAttrWithDict(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = _PyObject_GenericGetAttrWithDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GenericGetAttrWithDict", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GenericSetAttrWithDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GenericSetAttrWithDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GenericSetAttrWithDict$descriptor() {
        return _PyObject_GenericSetAttrWithDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyObject_GenericSetAttrWithDict$handle() {
        return _PyObject_GenericSetAttrWithDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GenericSetAttrWithDict$address() {
        return _PyObject_GenericSetAttrWithDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int _PyObject_GenericSetAttrWithDict(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyObject_GenericSetAttrWithDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GenericSetAttrWithDict", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_FunctionStr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_FunctionStr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_FunctionStr$descriptor() {
        return _PyObject_FunctionStr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_FunctionStr$handle() {
        return _PyObject_FunctionStr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_FunctionStr$address() {
        return _PyObject_FunctionStr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_FunctionStr(MemorySegment x0) {
        var mh$ = _PyObject_FunctionStr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_FunctionStr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_AssertFailed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_AssertFailed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static FunctionDescriptor _PyObject_AssertFailed$descriptor() {
        return _PyObject_AssertFailed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static MethodHandle _PyObject_AssertFailed$handle() {
        return _PyObject_AssertFailed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static MemorySegment _PyObject_AssertFailed$address() {
        return _PyObject_AssertFailed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static void _PyObject_AssertFailed(MemorySegment obj, MemorySegment expr, MemorySegment msg, MemorySegment file, int line, MemorySegment function) {
        var mh$ = _PyObject_AssertFailed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_AssertFailed", obj, expr, msg, file, line, function);
            }
            mh$.invokeExact(obj, expr, msg, file, line, function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static FunctionDescriptor _PyTrash_begin$descriptor() {
        return _PyTrash_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static MethodHandle _PyTrash_begin$handle() {
        return _PyTrash_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static MemorySegment _PyTrash_begin$address() {
        return _PyTrash_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static int _PyTrash_begin(MemorySegment tstate, MemorySegment op) {
        var mh$ = _PyTrash_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_begin", tstate, op);
            }
            return (int)mh$.invokeExact(tstate, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor _PyTrash_end$descriptor() {
        return _PyTrash_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static MethodHandle _PyTrash_end$handle() {
        return _PyTrash_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static MemorySegment _PyTrash_end$address() {
        return _PyTrash_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static void _PyTrash_end(MemorySegment tstate) {
        var mh$ = _PyTrash_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_end", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_thread_deposit_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_thread_deposit_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTrash_thread_deposit_object(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static FunctionDescriptor _PyTrash_thread_deposit_object$descriptor() {
        return _PyTrash_thread_deposit_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTrash_thread_deposit_object(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static MethodHandle _PyTrash_thread_deposit_object$handle() {
        return _PyTrash_thread_deposit_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTrash_thread_deposit_object(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static MemorySegment _PyTrash_thread_deposit_object$address() {
        return _PyTrash_thread_deposit_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTrash_thread_deposit_object(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static void _PyTrash_thread_deposit_object(MemorySegment tstate, MemorySegment op) {
        var mh$ = _PyTrash_thread_deposit_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_thread_deposit_object", tstate, op);
            }
            mh$.invokeExact(tstate, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_thread_destroy_chain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_thread_destroy_chain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTrash_thread_destroy_chain(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor _PyTrash_thread_destroy_chain$descriptor() {
        return _PyTrash_thread_destroy_chain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTrash_thread_destroy_chain(PyThreadState *tstate)
     * }
     */
    public static MethodHandle _PyTrash_thread_destroy_chain$handle() {
        return _PyTrash_thread_destroy_chain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTrash_thread_destroy_chain(PyThreadState *tstate)
     * }
     */
    public static MemorySegment _PyTrash_thread_destroy_chain$address() {
        return _PyTrash_thread_destroy_chain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTrash_thread_destroy_chain(PyThreadState *tstate)
     * }
     */
    public static void _PyTrash_thread_destroy_chain(MemorySegment tstate) {
        var mh$ = _PyTrash_thread_destroy_chain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_thread_destroy_chain", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetItemData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetItemData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_GetItemData(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_GetItemData$descriptor() {
        return PyObject_GetItemData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_GetItemData(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_GetItemData$handle() {
        return PyObject_GetItemData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_GetItemData(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_GetItemData$address() {
        return PyObject_GetItemData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_GetItemData(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_GetItemData(MemorySegment obj) {
        var mh$ = PyObject_GetItemData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetItemData", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_VisitManagedDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_VisitManagedDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_VisitManagedDict(PyObject *obj, visitproc visit, void *arg)
     * }
     */
    public static FunctionDescriptor PyObject_VisitManagedDict$descriptor() {
        return PyObject_VisitManagedDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_VisitManagedDict(PyObject *obj, visitproc visit, void *arg)
     * }
     */
    public static MethodHandle PyObject_VisitManagedDict$handle() {
        return PyObject_VisitManagedDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_VisitManagedDict(PyObject *obj, visitproc visit, void *arg)
     * }
     */
    public static MemorySegment PyObject_VisitManagedDict$address() {
        return PyObject_VisitManagedDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_VisitManagedDict(PyObject *obj, visitproc visit, void *arg)
     * }
     */
    public static int PyObject_VisitManagedDict(MemorySegment obj, MemorySegment visit, MemorySegment arg) {
        var mh$ = PyObject_VisitManagedDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_VisitManagedDict", obj, visit, arg);
            }
            return (int)mh$.invokeExact(obj, visit, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_SetManagedDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_SetManagedDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_SetManagedDict(PyObject *obj, PyObject *new_dict)
     * }
     */
    public static FunctionDescriptor _PyObject_SetManagedDict$descriptor() {
        return _PyObject_SetManagedDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_SetManagedDict(PyObject *obj, PyObject *new_dict)
     * }
     */
    public static MethodHandle _PyObject_SetManagedDict$handle() {
        return _PyObject_SetManagedDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_SetManagedDict(PyObject *obj, PyObject *new_dict)
     * }
     */
    public static MemorySegment _PyObject_SetManagedDict$address() {
        return _PyObject_SetManagedDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_SetManagedDict(PyObject *obj, PyObject *new_dict)
     * }
     */
    public static int _PyObject_SetManagedDict(MemorySegment obj, MemorySegment new_dict) {
        var mh$ = _PyObject_SetManagedDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_SetManagedDict", obj, new_dict);
            }
            return (int)mh$.invokeExact(obj, new_dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_ClearManagedDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_ClearManagedDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_ClearManagedDict(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_ClearManagedDict$descriptor() {
        return PyObject_ClearManagedDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_ClearManagedDict(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_ClearManagedDict$handle() {
        return PyObject_ClearManagedDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_ClearManagedDict(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_ClearManagedDict$address() {
        return PyObject_ClearManagedDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_ClearManagedDict(PyObject *obj)
     * }
     */
    public static void PyObject_ClearManagedDict(MemorySegment obj) {
        var mh$ = PyObject_ClearManagedDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_ClearManagedDict", obj);
            }
            mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_AddWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_AddWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_AddWatcher(PyType_WatchCallback callback)
     * }
     */
    public static FunctionDescriptor PyType_AddWatcher$descriptor() {
        return PyType_AddWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_AddWatcher(PyType_WatchCallback callback)
     * }
     */
    public static MethodHandle PyType_AddWatcher$handle() {
        return PyType_AddWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_AddWatcher(PyType_WatchCallback callback)
     * }
     */
    public static MemorySegment PyType_AddWatcher$address() {
        return PyType_AddWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_AddWatcher(PyType_WatchCallback callback)
     * }
     */
    public static int PyType_AddWatcher(MemorySegment callback) {
        var mh$ = PyType_AddWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_AddWatcher", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_ClearWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_ClearWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_ClearWatcher(int watcher_id)
     * }
     */
    public static FunctionDescriptor PyType_ClearWatcher$descriptor() {
        return PyType_ClearWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_ClearWatcher(int watcher_id)
     * }
     */
    public static MethodHandle PyType_ClearWatcher$handle() {
        return PyType_ClearWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_ClearWatcher(int watcher_id)
     * }
     */
    public static MemorySegment PyType_ClearWatcher$address() {
        return PyType_ClearWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_ClearWatcher(int watcher_id)
     * }
     */
    public static int PyType_ClearWatcher(int watcher_id) {
        var mh$ = PyType_ClearWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_ClearWatcher", watcher_id);
            }
            return (int)mh$.invokeExact(watcher_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Watch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Watch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_Watch(int watcher_id, PyObject *type)
     * }
     */
    public static FunctionDescriptor PyType_Watch$descriptor() {
        return PyType_Watch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_Watch(int watcher_id, PyObject *type)
     * }
     */
    public static MethodHandle PyType_Watch$handle() {
        return PyType_Watch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_Watch(int watcher_id, PyObject *type)
     * }
     */
    public static MemorySegment PyType_Watch$address() {
        return PyType_Watch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_Watch(int watcher_id, PyObject *type)
     * }
     */
    public static int PyType_Watch(int watcher_id, MemorySegment type) {
        var mh$ = PyType_Watch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Watch", watcher_id, type);
            }
            return (int)mh$.invokeExact(watcher_id, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Unwatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Unwatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_Unwatch(int watcher_id, PyObject *type)
     * }
     */
    public static FunctionDescriptor PyType_Unwatch$descriptor() {
        return PyType_Unwatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_Unwatch(int watcher_id, PyObject *type)
     * }
     */
    public static MethodHandle PyType_Unwatch$handle() {
        return PyType_Unwatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_Unwatch(int watcher_id, PyObject *type)
     * }
     */
    public static MemorySegment PyType_Unwatch$address() {
        return PyType_Unwatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_Unwatch(int watcher_id, PyObject *type)
     * }
     */
    public static int PyType_Unwatch(int watcher_id, MemorySegment type) {
        var mh$ = PyType_Unwatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Unwatch", watcher_id, type);
            }
            return (int)mh$.invokeExact(watcher_id, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Type_AssignVersionTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Type_AssignVersionTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyUnstable_Type_AssignVersionTag$descriptor() {
        return PyUnstable_Type_AssignVersionTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyUnstable_Type_AssignVersionTag$handle() {
        return PyUnstable_Type_AssignVersionTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyUnstable_Type_AssignVersionTag$address() {
        return PyUnstable_Type_AssignVersionTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)
     * }
     */
    public static int PyUnstable_Type_AssignVersionTag(MemorySegment type) {
        var mh$ = PyUnstable_Type_AssignVersionTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Type_AssignVersionTag", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PyRefTracer_CREATE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyRefTracer_CREATE = 0
     * }
     */
    public static int PyRefTracer_CREATE() {
        return PyRefTracer_CREATE;
    }
    private static final int PyRefTracer_DESTROY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyRefTracer_DESTROY = 1
     * }
     */
    public static int PyRefTracer_DESTROY() {
        return PyRefTracer_DESTROY;
    }

    private static class PyRefTracer_SetTracer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRefTracer_SetTracer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRefTracer_SetTracer(PyRefTracer tracer, void *data)
     * }
     */
    public static FunctionDescriptor PyRefTracer_SetTracer$descriptor() {
        return PyRefTracer_SetTracer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRefTracer_SetTracer(PyRefTracer tracer, void *data)
     * }
     */
    public static MethodHandle PyRefTracer_SetTracer$handle() {
        return PyRefTracer_SetTracer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRefTracer_SetTracer(PyRefTracer tracer, void *data)
     * }
     */
    public static MemorySegment PyRefTracer_SetTracer$address() {
        return PyRefTracer_SetTracer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRefTracer_SetTracer(PyRefTracer tracer, void *data)
     * }
     */
    public static int PyRefTracer_SetTracer(MemorySegment tracer, MemorySegment data) {
        var mh$ = PyRefTracer_SetTracer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRefTracer_SetTracer", tracer, data);
            }
            return (int)mh$.invokeExact(tracer, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRefTracer_GetTracer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRefTracer_GetTracer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyRefTracer PyRefTracer_GetTracer(void **)
     * }
     */
    public static FunctionDescriptor PyRefTracer_GetTracer$descriptor() {
        return PyRefTracer_GetTracer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyRefTracer PyRefTracer_GetTracer(void **)
     * }
     */
    public static MethodHandle PyRefTracer_GetTracer$handle() {
        return PyRefTracer_GetTracer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyRefTracer PyRefTracer_GetTracer(void **)
     * }
     */
    public static MemorySegment PyRefTracer_GetTracer$address() {
        return PyRefTracer_GetTracer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyRefTracer PyRefTracer_GetTracer(void **)
     * }
     */
    public static MemorySegment PyRefTracer_GetTracer(MemorySegment x0) {
        var mh$ = PyRefTracer_GetTracer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRefTracer_GetTracer", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModuleByDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModuleByDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyType_GetModuleByDef$descriptor() {
        return PyType_GetModuleByDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static MethodHandle PyType_GetModuleByDef$handle() {
        return PyType_GetModuleByDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static MemorySegment PyType_GetModuleByDef$address() {
        return PyType_GetModuleByDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static MemorySegment PyType_GetModuleByDef(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_GetModuleByDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModuleByDef", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyObject_Malloc$descriptor() {
        return PyObject_Malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MethodHandle PyObject_Malloc$handle() {
        return PyObject_Malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyObject_Malloc$address() {
        return PyObject_Malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyObject_Malloc(long size) {
        var mh$ = PyObject_Malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyObject_Calloc$descriptor() {
        return PyObject_Calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyObject_Calloc$handle() {
        return PyObject_Calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyObject_Calloc$address() {
        return PyObject_Calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyObject_Calloc(long nelem, long elsize) {
        var mh$ = PyObject_Calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Calloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyObject_Realloc$descriptor() {
        return PyObject_Realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyObject_Realloc$handle() {
        return PyObject_Realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyObject_Realloc$address() {
        return PyObject_Realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyObject_Realloc(MemorySegment ptr, long new_size) {
        var mh$ = PyObject_Realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Realloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static FunctionDescriptor PyObject_Free$descriptor() {
        return PyObject_Free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static MethodHandle PyObject_Free$handle() {
        return PyObject_Free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static MemorySegment PyObject_Free$address() {
        return PyObject_Free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static void PyObject_Free(MemorySegment ptr) {
        var mh$ = PyObject_Free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Init$descriptor() {
        return PyObject_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyObject_Init$handle() {
        return PyObject_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyObject_Init$address() {
        return PyObject_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyObject_Init(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Init", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_InitVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_InitVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyObject_InitVar$descriptor() {
        return PyObject_InitVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyObject_InitVar$handle() {
        return PyObject_InitVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyObject_InitVar$address() {
        return PyObject_InitVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyObject_InitVar(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = PyObject_InitVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_InitVar", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_New$descriptor() {
        return _PyObject_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyObject_New$handle() {
        return _PyObject_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_New$address() {
        return _PyObject_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_New(MemorySegment x0) {
        var mh$ = _PyObject_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_NewVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_NewVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_NewVar$descriptor() {
        return _PyObject_NewVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_NewVar$handle() {
        return _PyObject_NewVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_NewVar$address() {
        return _PyObject_NewVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_NewVar(MemorySegment x0, long x1) {
        var mh$ = _PyObject_NewVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_NewVar", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Collect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Collect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static FunctionDescriptor PyGC_Collect$descriptor() {
        return PyGC_Collect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static MethodHandle PyGC_Collect$handle() {
        return PyGC_Collect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static MemorySegment PyGC_Collect$address() {
        return PyGC_Collect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static long PyGC_Collect() {
        var mh$ = PyGC_Collect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Collect");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static FunctionDescriptor PyGC_Enable$descriptor() {
        return PyGC_Enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static MethodHandle PyGC_Enable$handle() {
        return PyGC_Enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static MemorySegment PyGC_Enable$address() {
        return PyGC_Enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static int PyGC_Enable() {
        var mh$ = PyGC_Enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Enable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Disable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Disable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static FunctionDescriptor PyGC_Disable$descriptor() {
        return PyGC_Disable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static MethodHandle PyGC_Disable$handle() {
        return PyGC_Disable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static MemorySegment PyGC_Disable$address() {
        return PyGC_Disable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static int PyGC_Disable() {
        var mh$ = PyGC_Disable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Disable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_IsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_IsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static FunctionDescriptor PyGC_IsEnabled$descriptor() {
        return PyGC_IsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static MethodHandle PyGC_IsEnabled$handle() {
        return PyGC_IsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static MemorySegment PyGC_IsEnabled$address() {
        return PyGC_IsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static int PyGC_IsEnabled() {
        var mh$ = PyGC_IsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_IsEnabled");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_Resize$descriptor() {
        return _PyObject_GC_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_GC_Resize$handle() {
        return _PyObject_GC_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_Resize$address() {
        return _PyObject_GC_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_Resize(MemorySegment x0, long x1) {
        var mh$ = _PyObject_GC_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_Resize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_New$descriptor() {
        return _PyObject_GC_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyObject_GC_New$handle() {
        return _PyObject_GC_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_GC_New$address() {
        return _PyObject_GC_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_GC_New(MemorySegment x0) {
        var mh$ = _PyObject_GC_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_NewVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_NewVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_NewVar$descriptor() {
        return _PyObject_GC_NewVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_GC_NewVar$handle() {
        return _PyObject_GC_NewVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_NewVar$address() {
        return _PyObject_GC_NewVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_NewVar(MemorySegment x0, long x1) {
        var mh$ = _PyObject_GC_NewVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_NewVar", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_Track {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_Track");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_Track$descriptor() {
        return PyObject_GC_Track.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static MethodHandle PyObject_GC_Track$handle() {
        return PyObject_GC_Track.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static MemorySegment PyObject_GC_Track$address() {
        return PyObject_GC_Track.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static void PyObject_GC_Track(MemorySegment x0) {
        var mh$ = PyObject_GC_Track.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_Track", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_UnTrack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_UnTrack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_UnTrack$descriptor() {
        return PyObject_GC_UnTrack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static MethodHandle PyObject_GC_UnTrack$handle() {
        return PyObject_GC_UnTrack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static MemorySegment PyObject_GC_UnTrack$address() {
        return PyObject_GC_UnTrack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static void PyObject_GC_UnTrack(MemorySegment x0) {
        var mh$ = PyObject_GC_UnTrack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_UnTrack", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_Del {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_Del");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_Del$descriptor() {
        return PyObject_GC_Del.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static MethodHandle PyObject_GC_Del$handle() {
        return PyObject_GC_Del.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static MemorySegment PyObject_GC_Del$address() {
        return PyObject_GC_Del.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static void PyObject_GC_Del(MemorySegment x0) {
        var mh$ = PyObject_GC_Del.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_Del", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_IsTracked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_IsTracked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_IsTracked$descriptor() {
        return PyObject_GC_IsTracked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GC_IsTracked$handle() {
        return PyObject_GC_IsTracked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GC_IsTracked$address() {
        return PyObject_GC_IsTracked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static int PyObject_GC_IsTracked(MemorySegment x0) {
        var mh$ = PyObject_GC_IsTracked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_IsTracked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_IsFinalized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_IsFinalized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_IsFinalized$descriptor() {
        return PyObject_GC_IsFinalized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GC_IsFinalized$handle() {
        return PyObject_GC_IsFinalized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GC_IsFinalized$address() {
        return PyObject_GC_IsFinalized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static int PyObject_GC_IsFinalized(MemorySegment x0) {
        var mh$ = PyObject_GC_IsFinalized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_IsFinalized", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetArenaAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetArenaAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static FunctionDescriptor PyObject_GetArenaAllocator$descriptor() {
        return PyObject_GetArenaAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MethodHandle PyObject_GetArenaAllocator$handle() {
        return PyObject_GetArenaAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MemorySegment PyObject_GetArenaAllocator$address() {
        return PyObject_GetArenaAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static void PyObject_GetArenaAllocator(MemorySegment allocator) {
        var mh$ = PyObject_GetArenaAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetArenaAllocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetArenaAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetArenaAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static FunctionDescriptor PyObject_SetArenaAllocator$descriptor() {
        return PyObject_SetArenaAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MethodHandle PyObject_SetArenaAllocator$handle() {
        return PyObject_SetArenaAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MemorySegment PyObject_SetArenaAllocator$address() {
        return PyObject_SetArenaAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static void PyObject_SetArenaAllocator(MemorySegment allocator) {
        var mh$ = PyObject_SetArenaAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetArenaAllocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IS_GC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IS_GC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_IS_GC$descriptor() {
        return PyObject_IS_GC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_IS_GC$handle() {
        return PyObject_IS_GC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_IS_GC$address() {
        return PyObject_IS_GC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static int PyObject_IS_GC(MemorySegment obj) {
        var mh$ = PyObject_IS_GC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IS_GC", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_SUPPORTS_WEAKREFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_SUPPORTS_WEAKREFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyType_SUPPORTS_WEAKREFS$descriptor() {
        return PyType_SUPPORTS_WEAKREFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyType_SUPPORTS_WEAKREFS$handle() {
        return PyType_SUPPORTS_WEAKREFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyType_SUPPORTS_WEAKREFS$address() {
        return PyType_SUPPORTS_WEAKREFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static int PyType_SUPPORTS_WEAKREFS(MemorySegment type) {
        var mh$ = PyType_SUPPORTS_WEAKREFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_SUPPORTS_WEAKREFS", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GET_WEAKREFS_LISTPTR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GET_WEAKREFS_LISTPTR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyObject_GET_WEAKREFS_LISTPTR$descriptor() {
        return PyObject_GET_WEAKREFS_LISTPTR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static MethodHandle PyObject_GET_WEAKREFS_LISTPTR$handle() {
        return PyObject_GET_WEAKREFS_LISTPTR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static MemorySegment PyObject_GET_WEAKREFS_LISTPTR$address() {
        return PyObject_GET_WEAKREFS_LISTPTR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static MemorySegment PyObject_GET_WEAKREFS_LISTPTR(MemorySegment op) {
        var mh$ = PyObject_GET_WEAKREFS_LISTPTR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GET_WEAKREFS_LISTPTR", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Object_GC_NewWithExtraData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Object_GC_NewWithExtraData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_Object_GC_NewWithExtraData(PyTypeObject *, size_t)
     * }
     */
    public static FunctionDescriptor PyUnstable_Object_GC_NewWithExtraData$descriptor() {
        return PyUnstable_Object_GC_NewWithExtraData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_Object_GC_NewWithExtraData(PyTypeObject *, size_t)
     * }
     */
    public static MethodHandle PyUnstable_Object_GC_NewWithExtraData$handle() {
        return PyUnstable_Object_GC_NewWithExtraData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_Object_GC_NewWithExtraData(PyTypeObject *, size_t)
     * }
     */
    public static MemorySegment PyUnstable_Object_GC_NewWithExtraData$address() {
        return PyUnstable_Object_GC_NewWithExtraData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnstable_Object_GC_NewWithExtraData(PyTypeObject *, size_t)
     * }
     */
    public static MemorySegment PyUnstable_Object_GC_NewWithExtraData(MemorySegment x0, long x1) {
        var mh$ = PyUnstable_Object_GC_NewWithExtraData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Object_GC_NewWithExtraData", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_GC_VisitObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_GC_VisitObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)
     * }
     */
    public static FunctionDescriptor PyUnstable_GC_VisitObjects$descriptor() {
        return PyUnstable_GC_VisitObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)
     * }
     */
    public static MethodHandle PyUnstable_GC_VisitObjects$handle() {
        return PyUnstable_GC_VisitObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)
     * }
     */
    public static MemorySegment PyUnstable_GC_VisitObjects$address() {
        return PyUnstable_GC_VisitObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, void *arg)
     * }
     */
    public static void PyUnstable_GC_VisitObjects(MemorySegment callback, MemorySegment arg) {
        var mh$ = PyUnstable_GC_VisitObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_GC_VisitObjects", callback, arg);
            }
            mh$.invokeExact(callback, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_HashDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static FunctionDescriptor _Py_HashDouble$descriptor() {
        return _Py_HashDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static MethodHandle _Py_HashDouble$handle() {
        return _Py_HashDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static MemorySegment _Py_HashDouble$address() {
        return _Py_HashDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static long _Py_HashDouble(MemorySegment x0, double x1) {
        var mh$ = _Py_HashDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_HashDouble", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyHash_GetFuncDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyHash_GetFuncDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static FunctionDescriptor PyHash_GetFuncDef$descriptor() {
        return PyHash_GetFuncDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static MethodHandle PyHash_GetFuncDef$handle() {
        return PyHash_GetFuncDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static MemorySegment PyHash_GetFuncDef$address() {
        return PyHash_GetFuncDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static MemorySegment PyHash_GetFuncDef() {
        var mh$ = PyHash_GetFuncDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyHash_GetFuncDef");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_HashPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_HashPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t Py_HashPointer(const void *ptr)
     * }
     */
    public static FunctionDescriptor Py_HashPointer$descriptor() {
        return Py_HashPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t Py_HashPointer(const void *ptr)
     * }
     */
    public static MethodHandle Py_HashPointer$handle() {
        return Py_HashPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t Py_HashPointer(const void *ptr)
     * }
     */
    public static MemorySegment Py_HashPointer$address() {
        return Py_HashPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t Py_HashPointer(const void *ptr)
     * }
     */
    public static long Py_HashPointer(MemorySegment ptr) {
        var mh$ = Py_HashPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_HashPointer", ptr);
            }
            return (long)mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_GenericHash(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericHash$descriptor() {
        return PyObject_GenericHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_GenericHash(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GenericHash$handle() {
        return PyObject_GenericHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_GenericHash(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericHash$address() {
        return PyObject_GenericHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t PyObject_GenericHash(PyObject *)
     * }
     */
    public static long PyObject_GenericHash(MemorySegment x0) {
        var mh$ = PyObject_GenericHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericHash", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_DebugFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_DebugFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static OfInt Py_DebugFlag$layout() {
        return Py_DebugFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static MemorySegment Py_DebugFlag$segment() {
        return Py_DebugFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static int Py_DebugFlag() {
        return Py_DebugFlag$constants.SEGMENT.get(Py_DebugFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static void Py_DebugFlag(int varValue) {
        Py_DebugFlag$constants.SEGMENT.set(Py_DebugFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_VerboseFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_VerboseFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static OfInt Py_VerboseFlag$layout() {
        return Py_VerboseFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static MemorySegment Py_VerboseFlag$segment() {
        return Py_VerboseFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static int Py_VerboseFlag() {
        return Py_VerboseFlag$constants.SEGMENT.get(Py_VerboseFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static void Py_VerboseFlag(int varValue) {
        Py_VerboseFlag$constants.SEGMENT.set(Py_VerboseFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_QuietFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_QuietFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static OfInt Py_QuietFlag$layout() {
        return Py_QuietFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static MemorySegment Py_QuietFlag$segment() {
        return Py_QuietFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static int Py_QuietFlag() {
        return Py_QuietFlag$constants.SEGMENT.get(Py_QuietFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static void Py_QuietFlag(int varValue) {
        Py_QuietFlag$constants.SEGMENT.set(Py_QuietFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_InteractiveFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_InteractiveFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static OfInt Py_InteractiveFlag$layout() {
        return Py_InteractiveFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static MemorySegment Py_InteractiveFlag$segment() {
        return Py_InteractiveFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static int Py_InteractiveFlag() {
        return Py_InteractiveFlag$constants.SEGMENT.get(Py_InteractiveFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static void Py_InteractiveFlag(int varValue) {
        Py_InteractiveFlag$constants.SEGMENT.set(Py_InteractiveFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_InspectFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_InspectFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static OfInt Py_InspectFlag$layout() {
        return Py_InspectFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static MemorySegment Py_InspectFlag$segment() {
        return Py_InspectFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static int Py_InspectFlag() {
        return Py_InspectFlag$constants.SEGMENT.get(Py_InspectFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static void Py_InspectFlag(int varValue) {
        Py_InspectFlag$constants.SEGMENT.set(Py_InspectFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_OptimizeFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_OptimizeFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static OfInt Py_OptimizeFlag$layout() {
        return Py_OptimizeFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static MemorySegment Py_OptimizeFlag$segment() {
        return Py_OptimizeFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static int Py_OptimizeFlag() {
        return Py_OptimizeFlag$constants.SEGMENT.get(Py_OptimizeFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static void Py_OptimizeFlag(int varValue) {
        Py_OptimizeFlag$constants.SEGMENT.set(Py_OptimizeFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_NoSiteFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_NoSiteFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static OfInt Py_NoSiteFlag$layout() {
        return Py_NoSiteFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static MemorySegment Py_NoSiteFlag$segment() {
        return Py_NoSiteFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static int Py_NoSiteFlag() {
        return Py_NoSiteFlag$constants.SEGMENT.get(Py_NoSiteFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static void Py_NoSiteFlag(int varValue) {
        Py_NoSiteFlag$constants.SEGMENT.set(Py_NoSiteFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_BytesWarningFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_BytesWarningFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static OfInt Py_BytesWarningFlag$layout() {
        return Py_BytesWarningFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static MemorySegment Py_BytesWarningFlag$segment() {
        return Py_BytesWarningFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static int Py_BytesWarningFlag() {
        return Py_BytesWarningFlag$constants.SEGMENT.get(Py_BytesWarningFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static void Py_BytesWarningFlag(int varValue) {
        Py_BytesWarningFlag$constants.SEGMENT.set(Py_BytesWarningFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_FrozenFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_FrozenFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static OfInt Py_FrozenFlag$layout() {
        return Py_FrozenFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static MemorySegment Py_FrozenFlag$segment() {
        return Py_FrozenFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static int Py_FrozenFlag() {
        return Py_FrozenFlag$constants.SEGMENT.get(Py_FrozenFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static void Py_FrozenFlag(int varValue) {
        Py_FrozenFlag$constants.SEGMENT.set(Py_FrozenFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_IgnoreEnvironmentFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_IgnoreEnvironmentFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static OfInt Py_IgnoreEnvironmentFlag$layout() {
        return Py_IgnoreEnvironmentFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static MemorySegment Py_IgnoreEnvironmentFlag$segment() {
        return Py_IgnoreEnvironmentFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static int Py_IgnoreEnvironmentFlag() {
        return Py_IgnoreEnvironmentFlag$constants.SEGMENT.get(Py_IgnoreEnvironmentFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static void Py_IgnoreEnvironmentFlag(int varValue) {
        Py_IgnoreEnvironmentFlag$constants.SEGMENT.set(Py_IgnoreEnvironmentFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_DontWriteBytecodeFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_DontWriteBytecodeFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static OfInt Py_DontWriteBytecodeFlag$layout() {
        return Py_DontWriteBytecodeFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static MemorySegment Py_DontWriteBytecodeFlag$segment() {
        return Py_DontWriteBytecodeFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static int Py_DontWriteBytecodeFlag() {
        return Py_DontWriteBytecodeFlag$constants.SEGMENT.get(Py_DontWriteBytecodeFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static void Py_DontWriteBytecodeFlag(int varValue) {
        Py_DontWriteBytecodeFlag$constants.SEGMENT.set(Py_DontWriteBytecodeFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_NoUserSiteDirectory$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_NoUserSiteDirectory").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static OfInt Py_NoUserSiteDirectory$layout() {
        return Py_NoUserSiteDirectory$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static MemorySegment Py_NoUserSiteDirectory$segment() {
        return Py_NoUserSiteDirectory$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static int Py_NoUserSiteDirectory() {
        return Py_NoUserSiteDirectory$constants.SEGMENT.get(Py_NoUserSiteDirectory$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static void Py_NoUserSiteDirectory(int varValue) {
        Py_NoUserSiteDirectory$constants.SEGMENT.set(Py_NoUserSiteDirectory$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_UnbufferedStdioFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_UnbufferedStdioFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static OfInt Py_UnbufferedStdioFlag$layout() {
        return Py_UnbufferedStdioFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static MemorySegment Py_UnbufferedStdioFlag$segment() {
        return Py_UnbufferedStdioFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static int Py_UnbufferedStdioFlag() {
        return Py_UnbufferedStdioFlag$constants.SEGMENT.get(Py_UnbufferedStdioFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static void Py_UnbufferedStdioFlag(int varValue) {
        Py_UnbufferedStdioFlag$constants.SEGMENT.set(Py_UnbufferedStdioFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_HashRandomizationFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_HashRandomizationFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static OfInt Py_HashRandomizationFlag$layout() {
        return Py_HashRandomizationFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static MemorySegment Py_HashRandomizationFlag$segment() {
        return Py_HashRandomizationFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static int Py_HashRandomizationFlag() {
        return Py_HashRandomizationFlag$constants.SEGMENT.get(Py_HashRandomizationFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static void Py_HashRandomizationFlag(int varValue) {
        Py_HashRandomizationFlag$constants.SEGMENT.set(Py_HashRandomizationFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_IsolatedFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_IsolatedFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static OfInt Py_IsolatedFlag$layout() {
        return Py_IsolatedFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static MemorySegment Py_IsolatedFlag$segment() {
        return Py_IsolatedFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static int Py_IsolatedFlag() {
        return Py_IsolatedFlag$constants.SEGMENT.get(Py_IsolatedFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static void Py_IsolatedFlag(int varValue) {
        Py_IsolatedFlag$constants.SEGMENT.set(Py_IsolatedFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_GETENV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GETENV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *Py_GETENV(const char *name)
     * }
     */
    public static FunctionDescriptor Py_GETENV$descriptor() {
        return Py_GETENV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *Py_GETENV(const char *name)
     * }
     */
    public static MethodHandle Py_GETENV$handle() {
        return Py_GETENV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *Py_GETENV(const char *name)
     * }
     */
    public static MemorySegment Py_GETENV$address() {
        return Py_GETENV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *Py_GETENV(const char *name)
     * }
     */
    public static MemorySegment Py_GETENV(MemorySegment name) {
        var mh$ = Py_GETENV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GETENV", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyByteArray_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static GroupLayout PyByteArray_Type$layout() {
        return PyByteArray_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static MemorySegment PyByteArray_Type() {
        return PyByteArray_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static void PyByteArray_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyByteArray_Type$constants.SEGMENT, 0L, PyByteArray_Type$constants.LAYOUT.byteSize());
    }

    private static class PyByteArrayIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyByteArrayIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static GroupLayout PyByteArrayIter_Type$layout() {
        return PyByteArrayIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static MemorySegment PyByteArrayIter_Type() {
        return PyByteArrayIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static void PyByteArrayIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyByteArrayIter_Type$constants.SEGMENT, 0L, PyByteArrayIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyByteArray_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_FromObject$descriptor() {
        return PyByteArray_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_FromObject$handle() {
        return PyByteArray_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_FromObject$address() {
        return PyByteArray_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_FromObject(MemorySegment x0) {
        var mh$ = PyByteArray_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_Concat$descriptor() {
        return PyByteArray_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_Concat$handle() {
        return PyByteArray_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Concat$address() {
        return PyByteArray_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Concat(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyByteArray_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Concat", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyByteArray_FromStringAndSize$descriptor() {
        return PyByteArray_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyByteArray_FromStringAndSize$handle() {
        return PyByteArray_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_FromStringAndSize$address() {
        return PyByteArray_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_FromStringAndSize(MemorySegment x0, long x1) {
        var mh$ = PyByteArray_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_FromStringAndSize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_Size$descriptor() {
        return PyByteArray_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_Size$handle() {
        return PyByteArray_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Size$address() {
        return PyByteArray_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static long PyByteArray_Size(MemorySegment x0) {
        var mh$ = PyByteArray_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_AsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_AsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_AsString$descriptor() {
        return PyByteArray_AsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_AsString$handle() {
        return PyByteArray_AsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_AsString$address() {
        return PyByteArray_AsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_AsString(MemorySegment x0) {
        var mh$ = PyByteArray_AsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_AsString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyByteArray_Resize$descriptor() {
        return PyByteArray_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyByteArray_Resize$handle() {
        return PyByteArray_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_Resize$address() {
        return PyByteArray_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyByteArray_Resize(MemorySegment x0, long x1) {
        var mh$ = PyByteArray_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Resize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyByteArray_empty_string$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_CHAR);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyByteArray_empty_string").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static SequenceLayout _PyByteArray_empty_string$layout() {
        return _PyByteArray_empty_string$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static long[] _PyByteArray_empty_string$dimensions() {
        return _PyByteArray_empty_string$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static MemorySegment _PyByteArray_empty_string() {
        return _PyByteArray_empty_string$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static void _PyByteArray_empty_string(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyByteArray_empty_string$constants.SEGMENT, 0L, _PyByteArray_empty_string$constants.LAYOUT.byteSize());
    }

    private static class PyBytes_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBytes_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static GroupLayout PyBytes_Type$layout() {
        return PyBytes_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static MemorySegment PyBytes_Type() {
        return PyBytes_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static void PyBytes_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBytes_Type$constants.SEGMENT, 0L, PyBytes_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBytesIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBytesIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static GroupLayout PyBytesIter_Type$layout() {
        return PyBytesIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static MemorySegment PyBytesIter_Type() {
        return PyBytesIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static void PyBytesIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBytesIter_Type$constants.SEGMENT, 0L, PyBytesIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBytes_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyBytes_FromStringAndSize$descriptor() {
        return PyBytes_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyBytes_FromStringAndSize$handle() {
        return PyBytes_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyBytes_FromStringAndSize$address() {
        return PyBytes_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyBytes_FromStringAndSize(MemorySegment x0, long x1) {
        var mh$ = PyBytes_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromStringAndSize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static FunctionDescriptor PyBytes_FromString$descriptor() {
        return PyBytes_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MethodHandle PyBytes_FromString$handle() {
        return PyBytes_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MemorySegment PyBytes_FromString$address() {
        return PyBytes_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MemorySegment PyBytes_FromString(MemorySegment x0) {
        var mh$ = PyBytes_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_FromObject$descriptor() {
        return PyBytes_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_FromObject$handle() {
        return PyBytes_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_FromObject$address() {
        return PyBytes_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_FromObject(MemorySegment x0) {
        var mh$ = PyBytes_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromFormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromFormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static FunctionDescriptor PyBytes_FromFormatV$descriptor() {
        return PyBytes_FromFormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MethodHandle PyBytes_FromFormatV$handle() {
        return PyBytes_FromFormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MemorySegment PyBytes_FromFormatV$address() {
        return PyBytes_FromFormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MemorySegment PyBytes_FromFormatV(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_FromFormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromFormatV", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormat(const char *, ...)
     * }
     */
    public static class PyBytes_FromFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyBytes_FromFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyBytes_FromFormat(const char *, ...)
         * }
         */
        public static PyBytes_FromFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyBytes_FromFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyBytes_FromFormat", x0, x1);
                }
                return (MemorySegment) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyBytes_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_Size$descriptor() {
        return PyBytes_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_Size$handle() {
        return PyBytes_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_Size$address() {
        return PyBytes_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static long PyBytes_Size(MemorySegment x0) {
        var mh$ = PyBytes_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_AsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_AsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_AsString$descriptor() {
        return PyBytes_AsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_AsString$handle() {
        return PyBytes_AsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_AsString$address() {
        return PyBytes_AsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_AsString(MemorySegment x0) {
        var mh$ = PyBytes_AsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_AsString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_Repr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Repr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyBytes_Repr$descriptor() {
        return PyBytes_Repr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MethodHandle PyBytes_Repr$handle() {
        return PyBytes_Repr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MemorySegment PyBytes_Repr$address() {
        return PyBytes_Repr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MemorySegment PyBytes_Repr(MemorySegment x0, int x1) {
        var mh$ = PyBytes_Repr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Repr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_Concat$descriptor() {
        return PyBytes_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static MethodHandle PyBytes_Concat$handle() {
        return PyBytes_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static MemorySegment PyBytes_Concat$address() {
        return PyBytes_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static void PyBytes_Concat(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Concat", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_ConcatAndDel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_ConcatAndDel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_ConcatAndDel$descriptor() {
        return PyBytes_ConcatAndDel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static MethodHandle PyBytes_ConcatAndDel$handle() {
        return PyBytes_ConcatAndDel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static MemorySegment PyBytes_ConcatAndDel$address() {
        return PyBytes_ConcatAndDel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static void PyBytes_ConcatAndDel(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_ConcatAndDel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_ConcatAndDel", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_DecodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_DecodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static FunctionDescriptor PyBytes_DecodeEscape$descriptor() {
        return PyBytes_DecodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MethodHandle PyBytes_DecodeEscape$handle() {
        return PyBytes_DecodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MemorySegment PyBytes_DecodeEscape$address() {
        return PyBytes_DecodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MemorySegment PyBytes_DecodeEscape(MemorySegment x0, long x1, MemorySegment x2, long x3, MemorySegment x4) {
        var mh$ = PyBytes_DecodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_DecodeEscape", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_AsStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_AsStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static FunctionDescriptor PyBytes_AsStringAndSize$descriptor() {
        return PyBytes_AsStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static MethodHandle PyBytes_AsStringAndSize$handle() {
        return PyBytes_AsStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static MemorySegment PyBytes_AsStringAndSize$address() {
        return PyBytes_AsStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static int PyBytes_AsStringAndSize(MemorySegment obj, MemorySegment s, MemorySegment len) {
        var mh$ = PyBytes_AsStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_AsStringAndSize", obj, s, len);
            }
            return (int)mh$.invokeExact(obj, s, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyBytes_Resize$descriptor() {
        return _PyBytes_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyBytes_Resize$handle() {
        return _PyBytes_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyBytes_Resize$address() {
        return _PyBytes_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static int _PyBytes_Resize(MemorySegment x0, long x1) {
        var mh$ = _PyBytes_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_Resize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_Join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_Join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static FunctionDescriptor _PyBytes_Join$descriptor() {
        return _PyBytes_Join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static MethodHandle _PyBytes_Join$handle() {
        return _PyBytes_Join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static MemorySegment _PyBytes_Join$address() {
        return _PyBytes_Join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static MemorySegment _PyBytes_Join(MemorySegment sep, MemorySegment x) {
        var mh$ = _PyBytes_Join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_Join", sep, x);
            }
            return (MemorySegment)mh$.invokeExact(sep, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t Py_UCS4
     * }
     */
    public static final OfInt Py_UCS4 = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t Py_UCS2
     * }
     */
    public static final OfShort Py_UCS2 = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t Py_UCS1
     * }
     */
    public static final OfByte Py_UCS1 = Python_h.C_CHAR;

    private static class PyUnicode_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyUnicode_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static GroupLayout PyUnicode_Type$layout() {
        return PyUnicode_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static MemorySegment PyUnicode_Type() {
        return PyUnicode_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static void PyUnicode_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyUnicode_Type$constants.SEGMENT, 0L, PyUnicode_Type$constants.LAYOUT.byteSize());
    }

    private static class PyUnicodeIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyUnicodeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static GroupLayout PyUnicodeIter_Type$layout() {
        return PyUnicodeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static MemorySegment PyUnicodeIter_Type() {
        return PyUnicodeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static void PyUnicodeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyUnicodeIter_Type$constants.SEGMENT, 0L, PyUnicodeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyUnicode_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromStringAndSize$descriptor() {
        return PyUnicode_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromStringAndSize$handle() {
        return PyUnicode_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromStringAndSize$address() {
        return PyUnicode_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromStringAndSize(MemorySegment u, long size) {
        var mh$ = PyUnicode_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromStringAndSize", u, size);
            }
            return (MemorySegment)mh$.invokeExact(u, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromString$descriptor() {
        return PyUnicode_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MethodHandle PyUnicode_FromString$handle() {
        return PyUnicode_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_FromString$address() {
        return PyUnicode_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_FromString(MemorySegment u) {
        var mh$ = PyUnicode_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromString", u);
            }
            return (MemorySegment)mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Substring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Substring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor PyUnicode_Substring$descriptor() {
        return PyUnicode_Substring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle PyUnicode_Substring$handle() {
        return PyUnicode_Substring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Substring$address() {
        return PyUnicode_Substring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Substring(MemorySegment str, long start, long end) {
        var mh$ = PyUnicode_Substring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Substring", str, start, end);
            }
            return (MemorySegment)mh$.invokeExact(str, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUCS4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUCS4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUCS4$descriptor() {
        return PyUnicode_AsUCS4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MethodHandle PyUnicode_AsUCS4$handle() {
        return PyUnicode_AsUCS4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4$address() {
        return PyUnicode_AsUCS4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4(MemorySegment unicode, MemorySegment buffer, long buflen, int copy_null) {
        var mh$ = PyUnicode_AsUCS4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUCS4", unicode, buffer, buflen, copy_null);
            }
            return (MemorySegment)mh$.invokeExact(unicode, buffer, buflen, copy_null);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUCS4Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUCS4Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUCS4Copy$descriptor() {
        return PyUnicode_AsUCS4Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUCS4Copy$handle() {
        return PyUnicode_AsUCS4Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4Copy$address() {
        return PyUnicode_AsUCS4Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4Copy(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUCS4Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUCS4Copy", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_GetLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_GetLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_GetLength$descriptor() {
        return PyUnicode_GetLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_GetLength$handle() {
        return PyUnicode_GetLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_GetLength$address() {
        return PyUnicode_GetLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static long PyUnicode_GetLength(MemorySegment unicode) {
        var mh$ = PyUnicode_GetLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_GetLength", unicode);
            }
            return (long)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_ReadChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_ReadChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static FunctionDescriptor PyUnicode_ReadChar$descriptor() {
        return PyUnicode_ReadChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static MethodHandle PyUnicode_ReadChar$handle() {
        return PyUnicode_ReadChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static MemorySegment PyUnicode_ReadChar$address() {
        return PyUnicode_ReadChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static int PyUnicode_ReadChar(MemorySegment unicode, long index) {
        var mh$ = PyUnicode_ReadChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_ReadChar", unicode, index);
            }
            return (int)mh$.invokeExact(unicode, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_WriteChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_WriteChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static FunctionDescriptor PyUnicode_WriteChar$descriptor() {
        return PyUnicode_WriteChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static MethodHandle PyUnicode_WriteChar$handle() {
        return PyUnicode_WriteChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static MemorySegment PyUnicode_WriteChar$address() {
        return PyUnicode_WriteChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static int PyUnicode_WriteChar(MemorySegment unicode, long index, int character) {
        var mh$ = PyUnicode_WriteChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_WriteChar", unicode, index, character);
            }
            return (int)mh$.invokeExact(unicode, index, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static FunctionDescriptor PyUnicode_Resize$descriptor() {
        return PyUnicode_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static MethodHandle PyUnicode_Resize$handle() {
        return PyUnicode_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static MemorySegment PyUnicode_Resize$address() {
        return PyUnicode_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static int PyUnicode_Resize(MemorySegment unicode, long length) {
        var mh$ = PyUnicode_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Resize", unicode, length);
            }
            return (int)mh$.invokeExact(unicode, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromEncodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromEncodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromEncodedObject$descriptor() {
        return PyUnicode_FromEncodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_FromEncodedObject$handle() {
        return PyUnicode_FromEncodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_FromEncodedObject$address() {
        return PyUnicode_FromEncodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_FromEncodedObject(MemorySegment obj, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_FromEncodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromEncodedObject", obj, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(obj, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromObject$descriptor() {
        return PyUnicode_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MethodHandle PyUnicode_FromObject$handle() {
        return PyUnicode_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MemorySegment PyUnicode_FromObject$address() {
        return PyUnicode_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MemorySegment PyUnicode_FromObject(MemorySegment obj) {
        var mh$ = PyUnicode_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromFormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromFormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromFormatV$descriptor() {
        return PyUnicode_FromFormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MethodHandle PyUnicode_FromFormatV$handle() {
        return PyUnicode_FromFormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyUnicode_FromFormatV$address() {
        return PyUnicode_FromFormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyUnicode_FromFormatV(MemorySegment format, MemorySegment vargs) {
        var mh$ = PyUnicode_FromFormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromFormatV", format, vargs);
            }
            return (MemorySegment)mh$.invokeExact(format, vargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormat(const char *format, ...)
     * }
     */
    public static class PyUnicode_FromFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyUnicode_FromFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyUnicode_FromFormat(const char *format, ...)
         * }
         */
        public static PyUnicode_FromFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyUnicode_FromFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyUnicode_FromFormat", format, x1);
                }
                return (MemorySegment) spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyUnicode_InternInPlace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_InternInPlace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static FunctionDescriptor PyUnicode_InternInPlace$descriptor() {
        return PyUnicode_InternInPlace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static MethodHandle PyUnicode_InternInPlace$handle() {
        return PyUnicode_InternInPlace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static MemorySegment PyUnicode_InternInPlace$address() {
        return PyUnicode_InternInPlace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static void PyUnicode_InternInPlace(MemorySegment x0) {
        var mh$ = PyUnicode_InternInPlace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_InternInPlace", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_InternFromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_InternFromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static FunctionDescriptor PyUnicode_InternFromString$descriptor() {
        return PyUnicode_InternFromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MethodHandle PyUnicode_InternFromString$handle() {
        return PyUnicode_InternFromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_InternFromString$address() {
        return PyUnicode_InternFromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_InternFromString(MemorySegment u) {
        var mh$ = PyUnicode_InternFromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_InternFromString", u);
            }
            return (MemorySegment)mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromWideChar$descriptor() {
        return PyUnicode_FromWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromWideChar$handle() {
        return PyUnicode_FromWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromWideChar$address() {
        return PyUnicode_FromWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromWideChar(MemorySegment w, long size) {
        var mh$ = PyUnicode_FromWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromWideChar", w, size);
            }
            return (MemorySegment)mh$.invokeExact(w, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsWideChar$descriptor() {
        return PyUnicode_AsWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_AsWideChar$handle() {
        return PyUnicode_AsWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideChar$address() {
        return PyUnicode_AsWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static long PyUnicode_AsWideChar(MemorySegment unicode, MemorySegment w, long size) {
        var mh$ = PyUnicode_AsWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsWideChar", unicode, w, size);
            }
            return (long)mh$.invokeExact(unicode, w, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsWideCharString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsWideCharString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsWideCharString$descriptor() {
        return PyUnicode_AsWideCharString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MethodHandle PyUnicode_AsWideCharString$handle() {
        return PyUnicode_AsWideCharString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideCharString$address() {
        return PyUnicode_AsWideCharString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideCharString(MemorySegment unicode, MemorySegment size) {
        var mh$ = PyUnicode_AsWideCharString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsWideCharString", unicode, size);
            }
            return (MemorySegment)mh$.invokeExact(unicode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromOrdinal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromOrdinal$descriptor() {
        return PyUnicode_FromOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MethodHandle PyUnicode_FromOrdinal$handle() {
        return PyUnicode_FromOrdinal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MemorySegment PyUnicode_FromOrdinal$address() {
        return PyUnicode_FromOrdinal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MemorySegment PyUnicode_FromOrdinal(int ordinal) {
        var mh$ = PyUnicode_FromOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromOrdinal", ordinal);
            }
            return (MemorySegment)mh$.invokeExact(ordinal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_GetDefaultEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_GetDefaultEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static FunctionDescriptor PyUnicode_GetDefaultEncoding$descriptor() {
        return PyUnicode_GetDefaultEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MethodHandle PyUnicode_GetDefaultEncoding$handle() {
        return PyUnicode_GetDefaultEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MemorySegment PyUnicode_GetDefaultEncoding$address() {
        return PyUnicode_GetDefaultEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MemorySegment PyUnicode_GetDefaultEncoding() {
        var mh$ = PyUnicode_GetDefaultEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_GetDefaultEncoding");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_Decode$descriptor() {
        return PyUnicode_Decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_Decode$handle() {
        return PyUnicode_Decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Decode$address() {
        return PyUnicode_Decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Decode(MemorySegment s, long size, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_Decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Decode", s, size, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(s, size, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsDecodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsDecodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsDecodedObject$descriptor() {
        return PyUnicode_AsDecodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsDecodedObject$handle() {
        return PyUnicode_AsDecodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedObject$address() {
        return PyUnicode_AsDecodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedObject(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsDecodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsDecodedObject", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsDecodedUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsDecodedUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsDecodedUnicode$descriptor() {
        return PyUnicode_AsDecodedUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsDecodedUnicode$handle() {
        return PyUnicode_AsDecodedUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedUnicode$address() {
        return PyUnicode_AsDecodedUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedUnicode(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsDecodedUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsDecodedUnicode", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedObject$descriptor() {
        return PyUnicode_AsEncodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedObject$handle() {
        return PyUnicode_AsEncodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedObject$address() {
        return PyUnicode_AsEncodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedObject(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedObject", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedString$descriptor() {
        return PyUnicode_AsEncodedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedString$handle() {
        return PyUnicode_AsEncodedString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedString$address() {
        return PyUnicode_AsEncodedString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedString(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedString", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedUnicode$descriptor() {
        return PyUnicode_AsEncodedUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedUnicode$handle() {
        return PyUnicode_AsEncodedUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedUnicode$address() {
        return PyUnicode_AsEncodedUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedUnicode(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedUnicode", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_BuildEncodingMap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_BuildEncodingMap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static FunctionDescriptor PyUnicode_BuildEncodingMap$descriptor() {
        return PyUnicode_BuildEncodingMap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MethodHandle PyUnicode_BuildEncodingMap$handle() {
        return PyUnicode_BuildEncodingMap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MemorySegment PyUnicode_BuildEncodingMap$address() {
        return PyUnicode_BuildEncodingMap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MemorySegment PyUnicode_BuildEncodingMap(MemorySegment string) {
        var mh$ = PyUnicode_BuildEncodingMap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_BuildEncodingMap", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF7 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF7");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF7$descriptor() {
        return PyUnicode_DecodeUTF7.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF7$handle() {
        return PyUnicode_DecodeUTF7.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7$address() {
        return PyUnicode_DecodeUTF7.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUTF7.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF7", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF7Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF7Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF7Stateful$descriptor() {
        return PyUnicode_DecodeUTF7Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF7Stateful$handle() {
        return PyUnicode_DecodeUTF7Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7Stateful$address() {
        return PyUnicode_DecodeUTF7Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF7Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF7Stateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF8$descriptor() {
        return PyUnicode_DecodeUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF8$handle() {
        return PyUnicode_DecodeUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8$address() {
        return PyUnicode_DecodeUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF8", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF8Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF8Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF8Stateful$descriptor() {
        return PyUnicode_DecodeUTF8Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF8Stateful$handle() {
        return PyUnicode_DecodeUTF8Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8Stateful$address() {
        return PyUnicode_DecodeUTF8Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF8Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF8Stateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8String$descriptor() {
        return PyUnicode_AsUTF8String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8String$handle() {
        return PyUnicode_AsUTF8String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8String$address() {
        return PyUnicode_AsUTF8String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF8String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8AndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8AndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8AndSize$descriptor() {
        return PyUnicode_AsUTF8AndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8AndSize$handle() {
        return PyUnicode_AsUTF8AndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8AndSize$address() {
        return PyUnicode_AsUTF8AndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8AndSize(MemorySegment unicode, MemorySegment size) {
        var mh$ = PyUnicode_AsUTF8AndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8AndSize", unicode, size);
            }
            return (MemorySegment)mh$.invokeExact(unicode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF32$descriptor() {
        return PyUnicode_DecodeUTF32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF32$handle() {
        return PyUnicode_DecodeUTF32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32$address() {
        return PyUnicode_DecodeUTF32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder) {
        var mh$ = PyUnicode_DecodeUTF32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF32", string, length, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF32Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF32Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF32Stateful$descriptor() {
        return PyUnicode_DecodeUTF32Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF32Stateful$handle() {
        return PyUnicode_DecodeUTF32Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32Stateful$address() {
        return PyUnicode_DecodeUTF32Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF32Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF32Stateful", string, length, errors, byteorder, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF32String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF32String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF32String$descriptor() {
        return PyUnicode_AsUTF32String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF32String$handle() {
        return PyUnicode_AsUTF32String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF32String$address() {
        return PyUnicode_AsUTF32String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF32String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF32String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF32String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF16$descriptor() {
        return PyUnicode_DecodeUTF16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF16$handle() {
        return PyUnicode_DecodeUTF16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16$address() {
        return PyUnicode_DecodeUTF16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder) {
        var mh$ = PyUnicode_DecodeUTF16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF16", string, length, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF16Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF16Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF16Stateful$descriptor() {
        return PyUnicode_DecodeUTF16Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF16Stateful$handle() {
        return PyUnicode_DecodeUTF16Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16Stateful$address() {
        return PyUnicode_DecodeUTF16Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF16Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF16Stateful", string, length, errors, byteorder, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF16String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF16String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF16String$descriptor() {
        return PyUnicode_AsUTF16String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF16String$handle() {
        return PyUnicode_AsUTF16String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF16String$address() {
        return PyUnicode_AsUTF16String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF16String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF16String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF16String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUnicodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUnicodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUnicodeEscape$descriptor() {
        return PyUnicode_DecodeUnicodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUnicodeEscape$handle() {
        return PyUnicode_DecodeUnicodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUnicodeEscape$address() {
        return PyUnicode_DecodeUnicodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUnicodeEscape(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUnicodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUnicodeEscape", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUnicodeEscapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUnicodeEscapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUnicodeEscapeString$descriptor() {
        return PyUnicode_AsUnicodeEscapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUnicodeEscapeString$handle() {
        return PyUnicode_AsUnicodeEscapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeEscapeString$address() {
        return PyUnicode_AsUnicodeEscapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeEscapeString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUnicodeEscapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUnicodeEscapeString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeRawUnicodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeRawUnicodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeRawUnicodeEscape$descriptor() {
        return PyUnicode_DecodeRawUnicodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeRawUnicodeEscape$handle() {
        return PyUnicode_DecodeRawUnicodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeRawUnicodeEscape$address() {
        return PyUnicode_DecodeRawUnicodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeRawUnicodeEscape(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeRawUnicodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeRawUnicodeEscape", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsRawUnicodeEscapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsRawUnicodeEscapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsRawUnicodeEscapeString$descriptor() {
        return PyUnicode_AsRawUnicodeEscapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsRawUnicodeEscapeString$handle() {
        return PyUnicode_AsRawUnicodeEscapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsRawUnicodeEscapeString$address() {
        return PyUnicode_AsRawUnicodeEscapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsRawUnicodeEscapeString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsRawUnicodeEscapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsRawUnicodeEscapeString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLatin1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLatin1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLatin1$descriptor() {
        return PyUnicode_DecodeLatin1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLatin1$handle() {
        return PyUnicode_DecodeLatin1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLatin1$address() {
        return PyUnicode_DecodeLatin1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLatin1(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLatin1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLatin1", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsLatin1String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsLatin1String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsLatin1String$descriptor() {
        return PyUnicode_AsLatin1String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsLatin1String$handle() {
        return PyUnicode_AsLatin1String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsLatin1String$address() {
        return PyUnicode_AsLatin1String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsLatin1String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsLatin1String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsLatin1String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeASCII$descriptor() {
        return PyUnicode_DecodeASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeASCII$handle() {
        return PyUnicode_DecodeASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeASCII$address() {
        return PyUnicode_DecodeASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeASCII(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeASCII", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsASCIIString$descriptor() {
        return PyUnicode_AsASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsASCIIString$handle() {
        return PyUnicode_AsASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsASCIIString$address() {
        return PyUnicode_AsASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsASCIIString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsASCIIString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeCharmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeCharmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeCharmap$descriptor() {
        return PyUnicode_DecodeCharmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeCharmap$handle() {
        return PyUnicode_DecodeCharmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCharmap$address() {
        return PyUnicode_DecodeCharmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCharmap(MemorySegment string, long length, MemorySegment mapping, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeCharmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeCharmap", string, length, mapping, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, mapping, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsCharmapString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsCharmapString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsCharmapString$descriptor() {
        return PyUnicode_AsCharmapString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MethodHandle PyUnicode_AsCharmapString$handle() {
        return PyUnicode_AsCharmapString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MemorySegment PyUnicode_AsCharmapString$address() {
        return PyUnicode_AsCharmapString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MemorySegment PyUnicode_AsCharmapString(MemorySegment unicode, MemorySegment mapping) {
        var mh$ = PyUnicode_AsCharmapString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsCharmapString", unicode, mapping);
            }
            return (MemorySegment)mh$.invokeExact(unicode, mapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLocaleAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLocaleAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLocaleAndSize$descriptor() {
        return PyUnicode_DecodeLocaleAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLocaleAndSize$handle() {
        return PyUnicode_DecodeLocaleAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocaleAndSize$address() {
        return PyUnicode_DecodeLocaleAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocaleAndSize(MemorySegment str, long len, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLocaleAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLocaleAndSize", str, len, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, len, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLocale$descriptor() {
        return PyUnicode_DecodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLocale$handle() {
        return PyUnicode_DecodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocale$address() {
        return PyUnicode_DecodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocale(MemorySegment str, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLocale", str, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeLocale$descriptor() {
        return PyUnicode_EncodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_EncodeLocale$handle() {
        return PyUnicode_EncodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeLocale$address() {
        return PyUnicode_EncodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeLocale(MemorySegment unicode, MemorySegment errors) {
        var mh$ = PyUnicode_EncodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeLocale", unicode, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FSConverter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FSConverter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyUnicode_FSConverter$descriptor() {
        return PyUnicode_FSConverter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static MethodHandle PyUnicode_FSConverter$handle() {
        return PyUnicode_FSConverter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static MemorySegment PyUnicode_FSConverter$address() {
        return PyUnicode_FSConverter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static int PyUnicode_FSConverter(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicode_FSConverter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FSConverter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FSDecoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FSDecoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyUnicode_FSDecoder$descriptor() {
        return PyUnicode_FSDecoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static MethodHandle PyUnicode_FSDecoder$handle() {
        return PyUnicode_FSDecoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static MemorySegment PyUnicode_FSDecoder$address() {
        return PyUnicode_FSDecoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static int PyUnicode_FSDecoder(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicode_FSDecoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FSDecoder", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeFSDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeFSDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeFSDefault$descriptor() {
        return PyUnicode_DecodeFSDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MethodHandle PyUnicode_DecodeFSDefault$handle() {
        return PyUnicode_DecodeFSDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefault$address() {
        return PyUnicode_DecodeFSDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefault(MemorySegment s) {
        var mh$ = PyUnicode_DecodeFSDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeFSDefault", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeFSDefaultAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeFSDefaultAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeFSDefaultAndSize$descriptor() {
        return PyUnicode_DecodeFSDefaultAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_DecodeFSDefaultAndSize$handle() {
        return PyUnicode_DecodeFSDefaultAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefaultAndSize$address() {
        return PyUnicode_DecodeFSDefaultAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefaultAndSize(MemorySegment s, long size) {
        var mh$ = PyUnicode_DecodeFSDefaultAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeFSDefaultAndSize", s, size);
            }
            return (MemorySegment)mh$.invokeExact(s, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeFSDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeFSDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeFSDefault$descriptor() {
        return PyUnicode_EncodeFSDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_EncodeFSDefault$handle() {
        return PyUnicode_EncodeFSDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_EncodeFSDefault$address() {
        return PyUnicode_EncodeFSDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_EncodeFSDefault(MemorySegment unicode) {
        var mh$ = PyUnicode_EncodeFSDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeFSDefault", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Concat$descriptor() {
        return PyUnicode_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Concat$handle() {
        return PyUnicode_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Concat$address() {
        return PyUnicode_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Concat(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Concat", left, right);
            }
            return (MemorySegment)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Append$descriptor() {
        return PyUnicode_Append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Append$handle() {
        return PyUnicode_Append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Append$address() {
        return PyUnicode_Append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static void PyUnicode_Append(MemorySegment pleft, MemorySegment right) {
        var mh$ = PyUnicode_Append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Append", pleft, right);
            }
            mh$.invokeExact(pleft, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AppendAndDel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AppendAndDel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_AppendAndDel$descriptor() {
        return PyUnicode_AppendAndDel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_AppendAndDel$handle() {
        return PyUnicode_AppendAndDel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_AppendAndDel$address() {
        return PyUnicode_AppendAndDel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static void PyUnicode_AppendAndDel(MemorySegment pleft, MemorySegment right) {
        var mh$ = PyUnicode_AppendAndDel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AppendAndDel", pleft, right);
            }
            mh$.invokeExact(pleft, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static FunctionDescriptor PyUnicode_Split$descriptor() {
        return PyUnicode_Split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MethodHandle PyUnicode_Split$handle() {
        return PyUnicode_Split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_Split$address() {
        return PyUnicode_Split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_Split(MemorySegment s, MemorySegment sep, long maxsplit) {
        var mh$ = PyUnicode_Split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Split", s, sep, maxsplit);
            }
            return (MemorySegment)mh$.invokeExact(s, sep, maxsplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Splitlines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Splitlines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static FunctionDescriptor PyUnicode_Splitlines$descriptor() {
        return PyUnicode_Splitlines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MethodHandle PyUnicode_Splitlines$handle() {
        return PyUnicode_Splitlines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MemorySegment PyUnicode_Splitlines$address() {
        return PyUnicode_Splitlines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MemorySegment PyUnicode_Splitlines(MemorySegment s, int keepends) {
        var mh$ = PyUnicode_Splitlines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Splitlines", s, keepends);
            }
            return (MemorySegment)mh$.invokeExact(s, keepends);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Partition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Partition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static FunctionDescriptor PyUnicode_Partition$descriptor() {
        return PyUnicode_Partition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MethodHandle PyUnicode_Partition$handle() {
        return PyUnicode_Partition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_Partition$address() {
        return PyUnicode_Partition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_Partition(MemorySegment s, MemorySegment sep) {
        var mh$ = PyUnicode_Partition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Partition", s, sep);
            }
            return (MemorySegment)mh$.invokeExact(s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RPartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RPartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static FunctionDescriptor PyUnicode_RPartition$descriptor() {
        return PyUnicode_RPartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MethodHandle PyUnicode_RPartition$handle() {
        return PyUnicode_RPartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_RPartition$address() {
        return PyUnicode_RPartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_RPartition(MemorySegment s, MemorySegment sep) {
        var mh$ = PyUnicode_RPartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RPartition", s, sep);
            }
            return (MemorySegment)mh$.invokeExact(s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RSplit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RSplit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static FunctionDescriptor PyUnicode_RSplit$descriptor() {
        return PyUnicode_RSplit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MethodHandle PyUnicode_RSplit$handle() {
        return PyUnicode_RSplit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_RSplit$address() {
        return PyUnicode_RSplit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_RSplit(MemorySegment s, MemorySegment sep, long maxsplit) {
        var mh$ = PyUnicode_RSplit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RSplit", s, sep, maxsplit);
            }
            return (MemorySegment)mh$.invokeExact(s, sep, maxsplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_Translate$descriptor() {
        return PyUnicode_Translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_Translate$handle() {
        return PyUnicode_Translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Translate$address() {
        return PyUnicode_Translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Translate(MemorySegment str, MemorySegment table, MemorySegment errors) {
        var mh$ = PyUnicode_Translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Translate", str, table, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, table, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static FunctionDescriptor PyUnicode_Join$descriptor() {
        return PyUnicode_Join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MethodHandle PyUnicode_Join$handle() {
        return PyUnicode_Join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MemorySegment PyUnicode_Join$address() {
        return PyUnicode_Join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MemorySegment PyUnicode_Join(MemorySegment separator, MemorySegment seq) {
        var mh$ = PyUnicode_Join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Join", separator, seq);
            }
            return (MemorySegment)mh$.invokeExact(separator, seq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Tailmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Tailmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_Tailmatch$descriptor() {
        return PyUnicode_Tailmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_Tailmatch$handle() {
        return PyUnicode_Tailmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_Tailmatch$address() {
        return PyUnicode_Tailmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_Tailmatch(MemorySegment str, MemorySegment substr, long start, long end, int direction) {
        var mh$ = PyUnicode_Tailmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Tailmatch", str, substr, start, end, direction);
            }
            return (long)mh$.invokeExact(str, substr, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_Find$descriptor() {
        return PyUnicode_Find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_Find$handle() {
        return PyUnicode_Find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_Find$address() {
        return PyUnicode_Find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_Find(MemorySegment str, MemorySegment substr, long start, long end, int direction) {
        var mh$ = PyUnicode_Find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Find", str, substr, start, end, direction);
            }
            return (long)mh$.invokeExact(str, substr, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FindChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FindChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_FindChar$descriptor() {
        return PyUnicode_FindChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_FindChar$handle() {
        return PyUnicode_FindChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_FindChar$address() {
        return PyUnicode_FindChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_FindChar(MemorySegment str, int ch, long start, long end, int direction) {
        var mh$ = PyUnicode_FindChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FindChar", str, ch, start, end, direction);
            }
            return (long)mh$.invokeExact(str, ch, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor PyUnicode_Count$descriptor() {
        return PyUnicode_Count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle PyUnicode_Count$handle() {
        return PyUnicode_Count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Count$address() {
        return PyUnicode_Count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static long PyUnicode_Count(MemorySegment str, MemorySegment substr, long start, long end) {
        var mh$ = PyUnicode_Count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Count", str, substr, start, end);
            }
            return (long)mh$.invokeExact(str, substr, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static FunctionDescriptor PyUnicode_Replace$descriptor() {
        return PyUnicode_Replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MethodHandle PyUnicode_Replace$handle() {
        return PyUnicode_Replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MemorySegment PyUnicode_Replace$address() {
        return PyUnicode_Replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MemorySegment PyUnicode_Replace(MemorySegment str, MemorySegment substr, MemorySegment replstr, long maxcount) {
        var mh$ = PyUnicode_Replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Replace", str, substr, replstr, maxcount);
            }
            return (MemorySegment)mh$.invokeExact(str, substr, replstr, maxcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Compare$descriptor() {
        return PyUnicode_Compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Compare$handle() {
        return PyUnicode_Compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Compare$address() {
        return PyUnicode_Compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static int PyUnicode_Compare(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_Compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Compare", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_CompareWithASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_CompareWithASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_CompareWithASCIIString$descriptor() {
        return PyUnicode_CompareWithASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MethodHandle PyUnicode_CompareWithASCIIString$handle() {
        return PyUnicode_CompareWithASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MemorySegment PyUnicode_CompareWithASCIIString$address() {
        return PyUnicode_CompareWithASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static int PyUnicode_CompareWithASCIIString(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_CompareWithASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_CompareWithASCIIString", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EqualToUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EqualToUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_EqualToUTF8(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyUnicode_EqualToUTF8$descriptor() {
        return PyUnicode_EqualToUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_EqualToUTF8(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyUnicode_EqualToUTF8$handle() {
        return PyUnicode_EqualToUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_EqualToUTF8(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyUnicode_EqualToUTF8$address() {
        return PyUnicode_EqualToUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_EqualToUTF8(PyObject *, const char *)
     * }
     */
    public static int PyUnicode_EqualToUTF8(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicode_EqualToUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EqualToUTF8", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EqualToUTF8AndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EqualToUTF8AndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_EqualToUTF8AndSize(PyObject *, const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicode_EqualToUTF8AndSize$descriptor() {
        return PyUnicode_EqualToUTF8AndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_EqualToUTF8AndSize(PyObject *, const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicode_EqualToUTF8AndSize$handle() {
        return PyUnicode_EqualToUTF8AndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_EqualToUTF8AndSize(PyObject *, const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicode_EqualToUTF8AndSize$address() {
        return PyUnicode_EqualToUTF8AndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_EqualToUTF8AndSize(PyObject *, const char *, Py_ssize_t)
     * }
     */
    public static int PyUnicode_EqualToUTF8AndSize(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = PyUnicode_EqualToUTF8AndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EqualToUTF8AndSize", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RichCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RichCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static FunctionDescriptor PyUnicode_RichCompare$descriptor() {
        return PyUnicode_RichCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MethodHandle PyUnicode_RichCompare$handle() {
        return PyUnicode_RichCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MemorySegment PyUnicode_RichCompare$address() {
        return PyUnicode_RichCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MemorySegment PyUnicode_RichCompare(MemorySegment left, MemorySegment right, int op) {
        var mh$ = PyUnicode_RichCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RichCompare", left, right, op);
            }
            return (MemorySegment)mh$.invokeExact(left, right, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static FunctionDescriptor PyUnicode_Format$descriptor() {
        return PyUnicode_Format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MethodHandle PyUnicode_Format$handle() {
        return PyUnicode_Format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MemorySegment PyUnicode_Format$address() {
        return PyUnicode_Format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MemorySegment PyUnicode_Format(MemorySegment format, MemorySegment args) {
        var mh$ = PyUnicode_Format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Format", format, args);
            }
            return (MemorySegment)mh$.invokeExact(format, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static FunctionDescriptor PyUnicode_Contains$descriptor() {
        return PyUnicode_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static MethodHandle PyUnicode_Contains$handle() {
        return PyUnicode_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static MemorySegment PyUnicode_Contains$address() {
        return PyUnicode_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static int PyUnicode_Contains(MemorySegment container, MemorySegment element) {
        var mh$ = PyUnicode_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Contains", container, element);
            }
            return (int)mh$.invokeExact(container, element);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_IsIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_IsIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static FunctionDescriptor PyUnicode_IsIdentifier$descriptor() {
        return PyUnicode_IsIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static MethodHandle PyUnicode_IsIdentifier$handle() {
        return PyUnicode_IsIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static MemorySegment PyUnicode_IsIdentifier$address() {
        return PyUnicode_IsIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static int PyUnicode_IsIdentifier(MemorySegment s) {
        var mh$ = PyUnicode_IsIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_IsIdentifier", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef wchar_t PY_UNICODE_TYPE
     * }
     */
    public static final OfInt PY_UNICODE_TYPE = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef wchar_t Py_UNICODE
     * }
     */
    public static final OfInt Py_UNICODE = Python_h.C_INT;
    private static final int PyUnicode_1BYTE_KIND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PyUnicode_Kind.PyUnicode_1BYTE_KIND = 1
     * }
     */
    public static int PyUnicode_1BYTE_KIND() {
        return PyUnicode_1BYTE_KIND;
    }
    private static final int PyUnicode_2BYTE_KIND = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PyUnicode_Kind.PyUnicode_2BYTE_KIND = 2
     * }
     */
    public static int PyUnicode_2BYTE_KIND() {
        return PyUnicode_2BYTE_KIND;
    }
    private static final int PyUnicode_4BYTE_KIND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PyUnicode_Kind.PyUnicode_4BYTE_KIND = 4
     * }
     */
    public static int PyUnicode_4BYTE_KIND() {
        return PyUnicode_4BYTE_KIND;
    }

    private static class PyUnicode_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
     * }
     */
    public static FunctionDescriptor PyUnicode_New$descriptor() {
        return PyUnicode_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
     * }
     */
    public static MethodHandle PyUnicode_New$handle() {
        return PyUnicode_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
     * }
     */
    public static MemorySegment PyUnicode_New$address() {
        return PyUnicode_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
     * }
     */
    public static MemorySegment PyUnicode_New(long size, int maxchar) {
        var mh$ = PyUnicode_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_New", size, maxchar);
            }
            return (MemorySegment)mh$.invokeExact(size, maxchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_CopyCharacters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_CopyCharacters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static FunctionDescriptor PyUnicode_CopyCharacters$descriptor() {
        return PyUnicode_CopyCharacters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static MethodHandle PyUnicode_CopyCharacters$handle() {
        return PyUnicode_CopyCharacters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static MemorySegment PyUnicode_CopyCharacters$address() {
        return PyUnicode_CopyCharacters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static long PyUnicode_CopyCharacters(MemorySegment to, long to_start, MemorySegment from, long from_start, long how_many) {
        var mh$ = PyUnicode_CopyCharacters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_CopyCharacters", to, to_start, from, from_start, how_many);
            }
            return (long)mh$.invokeExact(to, to_start, from, from_start, how_many);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static FunctionDescriptor PyUnicode_Fill$descriptor() {
        return PyUnicode_Fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static MethodHandle PyUnicode_Fill$handle() {
        return PyUnicode_Fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static MemorySegment PyUnicode_Fill$address() {
        return PyUnicode_Fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static long PyUnicode_Fill(MemorySegment unicode, long start, long length, int fill_char) {
        var mh$ = PyUnicode_Fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Fill", unicode, start, length, fill_char);
            }
            return (long)mh$.invokeExact(unicode, start, length, fill_char);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromKindAndData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromKindAndData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromKindAndData$descriptor() {
        return PyUnicode_FromKindAndData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromKindAndData$handle() {
        return PyUnicode_FromKindAndData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromKindAndData$address() {
        return PyUnicode_FromKindAndData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromKindAndData(int kind, MemorySegment buffer, long size) {
        var mh$ = PyUnicode_FromKindAndData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromKindAndData", kind, buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(kind, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Init(_PyUnicodeWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_Init$descriptor() {
        return _PyUnicodeWriter_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Init(_PyUnicodeWriter *writer)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_Init$handle() {
        return _PyUnicodeWriter_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Init(_PyUnicodeWriter *writer)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_Init$address() {
        return _PyUnicodeWriter_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Init(_PyUnicodeWriter *writer)
     * }
     */
    public static void _PyUnicodeWriter_Init(MemorySegment writer) {
        var mh$ = _PyUnicodeWriter_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_Init", writer);
            }
            mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_PrepareInternal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_PrepareInternal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer, Py_ssize_t length, Py_UCS4 maxchar)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_PrepareInternal$descriptor() {
        return _PyUnicodeWriter_PrepareInternal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer, Py_ssize_t length, Py_UCS4 maxchar)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_PrepareInternal$handle() {
        return _PyUnicodeWriter_PrepareInternal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer, Py_ssize_t length, Py_UCS4 maxchar)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_PrepareInternal$address() {
        return _PyUnicodeWriter_PrepareInternal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer, Py_ssize_t length, Py_UCS4 maxchar)
     * }
     */
    public static int _PyUnicodeWriter_PrepareInternal(MemorySegment writer, long length, int maxchar) {
        var mh$ = _PyUnicodeWriter_PrepareInternal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_PrepareInternal", writer, length, maxchar);
            }
            return (int)mh$.invokeExact(writer, length, maxchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_PrepareKindInternal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_PrepareKindInternal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer, int kind)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_PrepareKindInternal$descriptor() {
        return _PyUnicodeWriter_PrepareKindInternal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer, int kind)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_PrepareKindInternal$handle() {
        return _PyUnicodeWriter_PrepareKindInternal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer, int kind)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_PrepareKindInternal$address() {
        return _PyUnicodeWriter_PrepareKindInternal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer, int kind)
     * }
     */
    public static int _PyUnicodeWriter_PrepareKindInternal(MemorySegment writer, int kind) {
        var mh$ = _PyUnicodeWriter_PrepareKindInternal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_PrepareKindInternal", writer, kind);
            }
            return (int)mh$.invokeExact(writer, kind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer, Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteChar$descriptor() {
        return _PyUnicodeWriter_WriteChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer, Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteChar$handle() {
        return _PyUnicodeWriter_WriteChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer, Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteChar$address() {
        return _PyUnicodeWriter_WriteChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer, Py_UCS4 ch)
     * }
     */
    public static int _PyUnicodeWriter_WriteChar(MemorySegment writer, int ch) {
        var mh$ = _PyUnicodeWriter_WriteChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteChar", writer, ch);
            }
            return (int)mh$.invokeExact(writer, ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteStr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteStr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteStr$descriptor() {
        return _PyUnicodeWriter_WriteStr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteStr$handle() {
        return _PyUnicodeWriter_WriteStr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteStr$address() {
        return _PyUnicodeWriter_WriteStr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
     * }
     */
    public static int _PyUnicodeWriter_WriteStr(MemorySegment writer, MemorySegment str) {
        var mh$ = _PyUnicodeWriter_WriteStr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteStr", writer, str);
            }
            return (int)mh$.invokeExact(writer, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteSubstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteSubstring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer, PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteSubstring$descriptor() {
        return _PyUnicodeWriter_WriteSubstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer, PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteSubstring$handle() {
        return _PyUnicodeWriter_WriteSubstring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer, PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteSubstring$address() {
        return _PyUnicodeWriter_WriteSubstring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer, PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static int _PyUnicodeWriter_WriteSubstring(MemorySegment writer, MemorySegment str, long start, long end) {
        var mh$ = _PyUnicodeWriter_WriteSubstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteSubstring", writer, str, start, end);
            }
            return (int)mh$.invokeExact(writer, str, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteASCIIString$descriptor() {
        return _PyUnicodeWriter_WriteASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteASCIIString$handle() {
        return _PyUnicodeWriter_WriteASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteASCIIString$address() {
        return _PyUnicodeWriter_WriteASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static int _PyUnicodeWriter_WriteASCIIString(MemorySegment writer, MemorySegment str, long len) {
        var mh$ = _PyUnicodeWriter_WriteASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteASCIIString", writer, str, len);
            }
            return (int)mh$.invokeExact(writer, str, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteLatin1String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteLatin1String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteLatin1String$descriptor() {
        return _PyUnicodeWriter_WriteLatin1String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteLatin1String$handle() {
        return _PyUnicodeWriter_WriteLatin1String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteLatin1String$address() {
        return _PyUnicodeWriter_WriteLatin1String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static int _PyUnicodeWriter_WriteLatin1String(MemorySegment writer, MemorySegment str, long len) {
        var mh$ = _PyUnicodeWriter_WriteLatin1String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteLatin1String", writer, str, len);
            }
            return (int)mh$.invokeExact(writer, str, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_Finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_Finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_Finish$descriptor() {
        return _PyUnicodeWriter_Finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_Finish$handle() {
        return _PyUnicodeWriter_Finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_Finish$address() {
        return _PyUnicodeWriter_Finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_Finish(MemorySegment writer) {
        var mh$ = _PyUnicodeWriter_Finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_Finish", writer);
            }
            return (MemorySegment)mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_Dealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_Dealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_Dealloc$descriptor() {
        return _PyUnicodeWriter_Dealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_Dealloc$handle() {
        return _PyUnicodeWriter_Dealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_Dealloc$address() {
        return _PyUnicodeWriter_Dealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer)
     * }
     */
    public static void _PyUnicodeWriter_Dealloc(MemorySegment writer) {
        var mh$ = _PyUnicodeWriter_Dealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_Dealloc", writer);
            }
            mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8$descriptor() {
        return PyUnicode_AsUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8$handle() {
        return PyUnicode_AsUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8$address() {
        return PyUnicode_AsUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsLowercase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsLowercase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLowercase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsLowercase$descriptor() {
        return _PyUnicode_IsLowercase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLowercase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsLowercase$handle() {
        return _PyUnicode_IsLowercase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLowercase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsLowercase$address() {
        return _PyUnicode_IsLowercase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsLowercase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsLowercase(int ch) {
        var mh$ = _PyUnicode_IsLowercase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsLowercase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsUppercase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsUppercase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsUppercase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsUppercase$descriptor() {
        return _PyUnicode_IsUppercase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsUppercase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsUppercase$handle() {
        return _PyUnicode_IsUppercase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsUppercase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsUppercase$address() {
        return _PyUnicode_IsUppercase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsUppercase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsUppercase(int ch) {
        var mh$ = _PyUnicode_IsUppercase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsUppercase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsTitlecase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsTitlecase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsTitlecase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsTitlecase$descriptor() {
        return _PyUnicode_IsTitlecase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsTitlecase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsTitlecase$handle() {
        return _PyUnicode_IsTitlecase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsTitlecase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsTitlecase$address() {
        return _PyUnicode_IsTitlecase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsTitlecase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsTitlecase(int ch) {
        var mh$ = _PyUnicode_IsTitlecase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsTitlecase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsWhitespace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsWhitespace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsWhitespace(const Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsWhitespace$descriptor() {
        return _PyUnicode_IsWhitespace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsWhitespace(const Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsWhitespace$handle() {
        return _PyUnicode_IsWhitespace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsWhitespace(const Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsWhitespace$address() {
        return _PyUnicode_IsWhitespace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsWhitespace(const Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsWhitespace(int ch) {
        var mh$ = _PyUnicode_IsWhitespace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsWhitespace", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsLinebreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsLinebreak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLinebreak(const Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsLinebreak$descriptor() {
        return _PyUnicode_IsLinebreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLinebreak(const Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsLinebreak$handle() {
        return _PyUnicode_IsLinebreak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLinebreak(const Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsLinebreak$address() {
        return _PyUnicode_IsLinebreak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsLinebreak(const Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsLinebreak(int ch) {
        var mh$ = _PyUnicode_IsLinebreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsLinebreak", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToLowercase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToLowercase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToLowercase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToLowercase$descriptor() {
        return _PyUnicode_ToLowercase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToLowercase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToLowercase$handle() {
        return _PyUnicode_ToLowercase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToLowercase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToLowercase$address() {
        return _PyUnicode_ToLowercase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToLowercase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToLowercase(int ch) {
        var mh$ = _PyUnicode_ToLowercase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToLowercase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToUppercase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToUppercase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToUppercase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToUppercase$descriptor() {
        return _PyUnicode_ToUppercase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToUppercase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToUppercase$handle() {
        return _PyUnicode_ToUppercase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToUppercase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToUppercase$address() {
        return _PyUnicode_ToUppercase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToUppercase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToUppercase(int ch) {
        var mh$ = _PyUnicode_ToUppercase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToUppercase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToTitlecase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToTitlecase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToTitlecase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToTitlecase$descriptor() {
        return _PyUnicode_ToTitlecase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToTitlecase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToTitlecase$handle() {
        return _PyUnicode_ToTitlecase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToTitlecase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToTitlecase$address() {
        return _PyUnicode_ToTitlecase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToTitlecase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToTitlecase(int ch) {
        var mh$ = _PyUnicode_ToTitlecase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToTitlecase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToDecimalDigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToDecimalDigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToDecimalDigit$descriptor() {
        return _PyUnicode_ToDecimalDigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToDecimalDigit$handle() {
        return _PyUnicode_ToDecimalDigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToDecimalDigit$address() {
        return _PyUnicode_ToDecimalDigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_ToDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToDecimalDigit(int ch) {
        var mh$ = _PyUnicode_ToDecimalDigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToDecimalDigit", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToDigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToDigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDigit(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToDigit$descriptor() {
        return _PyUnicode_ToDigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDigit(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToDigit$handle() {
        return _PyUnicode_ToDigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDigit(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToDigit$address() {
        return _PyUnicode_ToDigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_ToDigit(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToDigit(int ch) {
        var mh$ = _PyUnicode_ToDigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToDigit", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToNumeric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToNumeric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _PyUnicode_ToNumeric(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToNumeric$descriptor() {
        return _PyUnicode_ToNumeric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _PyUnicode_ToNumeric(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToNumeric$handle() {
        return _PyUnicode_ToNumeric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _PyUnicode_ToNumeric(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToNumeric$address() {
        return _PyUnicode_ToNumeric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _PyUnicode_ToNumeric(Py_UCS4 ch)
     * }
     */
    public static double _PyUnicode_ToNumeric(int ch) {
        var mh$ = _PyUnicode_ToNumeric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToNumeric", ch);
            }
            return (double)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsDecimalDigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsDecimalDigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsDecimalDigit$descriptor() {
        return _PyUnicode_IsDecimalDigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsDecimalDigit$handle() {
        return _PyUnicode_IsDecimalDigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsDecimalDigit$address() {
        return _PyUnicode_IsDecimalDigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsDecimalDigit(int ch) {
        var mh$ = _PyUnicode_IsDecimalDigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsDecimalDigit", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsDigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsDigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDigit(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsDigit$descriptor() {
        return _PyUnicode_IsDigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDigit(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsDigit$handle() {
        return _PyUnicode_IsDigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDigit(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsDigit$address() {
        return _PyUnicode_IsDigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsDigit(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsDigit(int ch) {
        var mh$ = _PyUnicode_IsDigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsDigit", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsNumeric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsNumeric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsNumeric(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsNumeric$descriptor() {
        return _PyUnicode_IsNumeric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsNumeric(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsNumeric$handle() {
        return _PyUnicode_IsNumeric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsNumeric(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsNumeric$address() {
        return _PyUnicode_IsNumeric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsNumeric(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsNumeric(int ch) {
        var mh$ = _PyUnicode_IsNumeric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsNumeric", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsPrintable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsPrintable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsPrintable(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsPrintable$descriptor() {
        return _PyUnicode_IsPrintable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsPrintable(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsPrintable$handle() {
        return _PyUnicode_IsPrintable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsPrintable(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsPrintable$address() {
        return _PyUnicode_IsPrintable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsPrintable(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsPrintable(int ch) {
        var mh$ = _PyUnicode_IsPrintable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsPrintable", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsAlpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsAlpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsAlpha(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsAlpha$descriptor() {
        return _PyUnicode_IsAlpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsAlpha(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsAlpha$handle() {
        return _PyUnicode_IsAlpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsAlpha(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsAlpha$address() {
        return _PyUnicode_IsAlpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsAlpha(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsAlpha(int ch) {
        var mh$ = _PyUnicode_IsAlpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsAlpha", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_ascii_whitespace$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_CHAR);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_ascii_whitespace").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ascii_whitespace[]
     * }
     */
    public static SequenceLayout _Py_ascii_whitespace$layout() {
        return _Py_ascii_whitespace$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ascii_whitespace[]
     * }
     */
    public static long[] _Py_ascii_whitespace$dimensions() {
        return _Py_ascii_whitespace$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ascii_whitespace[]
     * }
     */
    public static MemorySegment _Py_ascii_whitespace() {
        return _Py_ascii_whitespace$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ascii_whitespace[]
     * }
     */
    public static void _Py_ascii_whitespace(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_ascii_whitespace$constants.SEGMENT, 0L, _Py_ascii_whitespace$constants.LAYOUT.byteSize());
    }

    private static class _PyUnicode_FromId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_FromId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromId(_Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyUnicode_FromId$descriptor() {
        return _PyUnicode_FromId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromId(_Py_Identifier *)
     * }
     */
    public static MethodHandle _PyUnicode_FromId$handle() {
        return _PyUnicode_FromId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromId(_Py_Identifier *)
     * }
     */
    public static MemorySegment _PyUnicode_FromId$address() {
        return _PyUnicode_FromId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromId(_Py_Identifier *)
     * }
     */
    public static MemorySegment _PyUnicode_FromId(MemorySegment x0) {
        var mh$ = _PyUnicode_FromId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_FromId", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetNone$descriptor() {
        return PyErr_SetNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetNone$handle() {
        return PyErr_SetNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetNone$address() {
        return PyErr_SetNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static void PyErr_SetNone(MemorySegment x0) {
        var mh$ = PyErr_SetNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetNone", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetObject$descriptor() {
        return PyErr_SetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetObject$handle() {
        return PyErr_SetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetObject$address() {
        return PyErr_SetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static void PyErr_SetObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyErr_SetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetObject", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static FunctionDescriptor PyErr_SetString$descriptor() {
        return PyErr_SetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static MethodHandle PyErr_SetString$handle() {
        return PyErr_SetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static MemorySegment PyErr_SetString$address() {
        return PyErr_SetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static void PyErr_SetString(MemorySegment exception, MemorySegment string) {
        var mh$ = PyErr_SetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetString", exception, string);
            }
            mh$.invokeExact(exception, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Occurred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Occurred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static FunctionDescriptor PyErr_Occurred$descriptor() {
        return PyErr_Occurred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static MethodHandle PyErr_Occurred$handle() {
        return PyErr_Occurred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static MemorySegment PyErr_Occurred$address() {
        return PyErr_Occurred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static MemorySegment PyErr_Occurred() {
        var mh$ = PyErr_Occurred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Occurred");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static FunctionDescriptor PyErr_Clear$descriptor() {
        return PyErr_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static MethodHandle PyErr_Clear$handle() {
        return PyErr_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static MemorySegment PyErr_Clear$address() {
        return PyErr_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static void PyErr_Clear() {
        var mh$ = PyErr_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Clear");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Fetch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Fetch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor PyErr_Fetch$descriptor() {
        return PyErr_Fetch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle PyErr_Fetch$handle() {
        return PyErr_Fetch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment PyErr_Fetch$address() {
        return PyErr_Fetch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void PyErr_Fetch(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_Fetch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Fetch", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Restore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Restore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_Restore$descriptor() {
        return PyErr_Restore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_Restore$handle() {
        return PyErr_Restore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_Restore$address() {
        return PyErr_Restore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void PyErr_Restore(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_Restore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Restore", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GetRaisedException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GetRaisedException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetRaisedException()
     * }
     */
    public static FunctionDescriptor PyErr_GetRaisedException$descriptor() {
        return PyErr_GetRaisedException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetRaisedException()
     * }
     */
    public static MethodHandle PyErr_GetRaisedException$handle() {
        return PyErr_GetRaisedException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetRaisedException()
     * }
     */
    public static MemorySegment PyErr_GetRaisedException$address() {
        return PyErr_GetRaisedException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_GetRaisedException()
     * }
     */
    public static MemorySegment PyErr_GetRaisedException() {
        var mh$ = PyErr_GetRaisedException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GetRaisedException");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetRaisedException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetRaisedException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetRaisedException(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetRaisedException$descriptor() {
        return PyErr_SetRaisedException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetRaisedException(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetRaisedException$handle() {
        return PyErr_SetRaisedException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetRaisedException(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetRaisedException$address() {
        return PyErr_SetRaisedException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetRaisedException(PyObject *)
     * }
     */
    public static void PyErr_SetRaisedException(MemorySegment x0) {
        var mh$ = PyErr_SetRaisedException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetRaisedException", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GetHandledException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GetHandledException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static FunctionDescriptor PyErr_GetHandledException$descriptor() {
        return PyErr_GetHandledException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static MethodHandle PyErr_GetHandledException$handle() {
        return PyErr_GetHandledException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static MemorySegment PyErr_GetHandledException$address() {
        return PyErr_GetHandledException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static MemorySegment PyErr_GetHandledException() {
        var mh$ = PyErr_GetHandledException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GetHandledException");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetHandledException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetHandledException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetHandledException$descriptor() {
        return PyErr_SetHandledException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetHandledException$handle() {
        return PyErr_SetHandledException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetHandledException$address() {
        return PyErr_SetHandledException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static void PyErr_SetHandledException(MemorySegment x0) {
        var mh$ = PyErr_SetHandledException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetHandledException", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GetExcInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GetExcInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor PyErr_GetExcInfo$descriptor() {
        return PyErr_GetExcInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle PyErr_GetExcInfo$handle() {
        return PyErr_GetExcInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment PyErr_GetExcInfo$address() {
        return PyErr_GetExcInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void PyErr_GetExcInfo(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_GetExcInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GetExcInfo", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetExcInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetExcInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetExcInfo$descriptor() {
        return PyErr_SetExcInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetExcInfo$handle() {
        return PyErr_SetExcInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetExcInfo$address() {
        return PyErr_SetExcInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void PyErr_SetExcInfo(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_SetExcInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetExcInfo", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FatalError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FatalError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static FunctionDescriptor Py_FatalError$descriptor() {
        return Py_FatalError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static MethodHandle Py_FatalError$handle() {
        return Py_FatalError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static MemorySegment Py_FatalError$address() {
        return Py_FatalError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static void Py_FatalError(MemorySegment message) {
        var mh$ = Py_FatalError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FatalError", message);
            }
            mh$.invokeExact(message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GivenExceptionMatches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GivenExceptionMatches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_GivenExceptionMatches$descriptor() {
        return PyErr_GivenExceptionMatches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_GivenExceptionMatches$handle() {
        return PyErr_GivenExceptionMatches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_GivenExceptionMatches$address() {
        return PyErr_GivenExceptionMatches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static int PyErr_GivenExceptionMatches(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyErr_GivenExceptionMatches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GivenExceptionMatches", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_ExceptionMatches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ExceptionMatches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_ExceptionMatches$descriptor() {
        return PyErr_ExceptionMatches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static MethodHandle PyErr_ExceptionMatches$handle() {
        return PyErr_ExceptionMatches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static MemorySegment PyErr_ExceptionMatches$address() {
        return PyErr_ExceptionMatches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static int PyErr_ExceptionMatches(MemorySegment x0) {
        var mh$ = PyErr_ExceptionMatches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_ExceptionMatches", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NormalizeException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NormalizeException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor PyErr_NormalizeException$descriptor() {
        return PyErr_NormalizeException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle PyErr_NormalizeException$handle() {
        return PyErr_NormalizeException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment PyErr_NormalizeException$address() {
        return PyErr_NormalizeException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void PyErr_NormalizeException(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_NormalizeException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NormalizeException", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetTraceback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetTraceback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetTraceback$descriptor() {
        return PyException_SetTraceback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetTraceback$handle() {
        return PyException_SetTraceback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetTraceback$address() {
        return PyException_SetTraceback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static int PyException_SetTraceback(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetTraceback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetTraceback", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

