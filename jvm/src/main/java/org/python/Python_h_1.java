// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h_1 extends Python_h_2 {

    Python_h_1() {
        // Should not be called directly
    }

    private static class PyException_GetTraceback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetTraceback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetTraceback$descriptor() {
        return PyException_GetTraceback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetTraceback$handle() {
        return PyException_GetTraceback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetTraceback$address() {
        return PyException_GetTraceback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetTraceback(MemorySegment x0) {
        var mh$ = PyException_GetTraceback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetTraceback", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetCause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetCause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetCause$descriptor() {
        return PyException_GetCause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetCause$handle() {
        return PyException_GetCause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetCause$address() {
        return PyException_GetCause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetCause(MemorySegment x0) {
        var mh$ = PyException_GetCause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetCause", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetCause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetCause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetCause$descriptor() {
        return PyException_SetCause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetCause$handle() {
        return PyException_SetCause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetCause$address() {
        return PyException_SetCause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static void PyException_SetCause(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetCause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetCause", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetContext$descriptor() {
        return PyException_GetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetContext$handle() {
        return PyException_GetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetContext$address() {
        return PyException_GetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetContext(MemorySegment x0) {
        var mh$ = PyException_GetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetContext$descriptor() {
        return PyException_SetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetContext$handle() {
        return PyException_SetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetContext$address() {
        return PyException_SetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static void PyException_SetContext(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetContext", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetArgs(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetArgs$descriptor() {
        return PyException_GetArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetArgs(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetArgs$handle() {
        return PyException_GetArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetArgs(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetArgs$address() {
        return PyException_GetArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetArgs(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetArgs(MemorySegment x0) {
        var mh$ = PyException_GetArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetArgs", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyException_SetArgs(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetArgs$descriptor() {
        return PyException_SetArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyException_SetArgs(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetArgs$handle() {
        return PyException_SetArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyException_SetArgs(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetArgs$address() {
        return PyException_SetArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyException_SetArgs(PyObject *, PyObject *)
     * }
     */
    public static void PyException_SetArgs(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetArgs", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyExceptionClass_Name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyExceptionClass_Name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static FunctionDescriptor PyExceptionClass_Name$descriptor() {
        return PyExceptionClass_Name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static MethodHandle PyExceptionClass_Name$handle() {
        return PyExceptionClass_Name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static MemorySegment PyExceptionClass_Name$address() {
        return PyExceptionClass_Name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static MemorySegment PyExceptionClass_Name(MemorySegment x0) {
        var mh$ = PyExceptionClass_Name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyExceptionClass_Name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyExc_BaseException$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BaseException").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static AddressLayout PyExc_BaseException$layout() {
        return PyExc_BaseException$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static MemorySegment PyExc_BaseException$segment() {
        return PyExc_BaseException$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static MemorySegment PyExc_BaseException() {
        return PyExc_BaseException$constants.SEGMENT.get(PyExc_BaseException$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static void PyExc_BaseException(MemorySegment varValue) {
        PyExc_BaseException$constants.SEGMENT.set(PyExc_BaseException$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_Exception$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_Exception").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static AddressLayout PyExc_Exception$layout() {
        return PyExc_Exception$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static MemorySegment PyExc_Exception$segment() {
        return PyExc_Exception$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static MemorySegment PyExc_Exception() {
        return PyExc_Exception$constants.SEGMENT.get(PyExc_Exception$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static void PyExc_Exception(MemorySegment varValue) {
        PyExc_Exception$constants.SEGMENT.set(PyExc_Exception$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BaseExceptionGroup$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BaseExceptionGroup").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static AddressLayout PyExc_BaseExceptionGroup$layout() {
        return PyExc_BaseExceptionGroup$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static MemorySegment PyExc_BaseExceptionGroup$segment() {
        return PyExc_BaseExceptionGroup$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static MemorySegment PyExc_BaseExceptionGroup() {
        return PyExc_BaseExceptionGroup$constants.SEGMENT.get(PyExc_BaseExceptionGroup$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static void PyExc_BaseExceptionGroup(MemorySegment varValue) {
        PyExc_BaseExceptionGroup$constants.SEGMENT.set(PyExc_BaseExceptionGroup$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_StopAsyncIteration$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_StopAsyncIteration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static AddressLayout PyExc_StopAsyncIteration$layout() {
        return PyExc_StopAsyncIteration$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static MemorySegment PyExc_StopAsyncIteration$segment() {
        return PyExc_StopAsyncIteration$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static MemorySegment PyExc_StopAsyncIteration() {
        return PyExc_StopAsyncIteration$constants.SEGMENT.get(PyExc_StopAsyncIteration$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static void PyExc_StopAsyncIteration(MemorySegment varValue) {
        PyExc_StopAsyncIteration$constants.SEGMENT.set(PyExc_StopAsyncIteration$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_StopIteration$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_StopIteration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static AddressLayout PyExc_StopIteration$layout() {
        return PyExc_StopIteration$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static MemorySegment PyExc_StopIteration$segment() {
        return PyExc_StopIteration$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static MemorySegment PyExc_StopIteration() {
        return PyExc_StopIteration$constants.SEGMENT.get(PyExc_StopIteration$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static void PyExc_StopIteration(MemorySegment varValue) {
        PyExc_StopIteration$constants.SEGMENT.set(PyExc_StopIteration$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_GeneratorExit$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_GeneratorExit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static AddressLayout PyExc_GeneratorExit$layout() {
        return PyExc_GeneratorExit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static MemorySegment PyExc_GeneratorExit$segment() {
        return PyExc_GeneratorExit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static MemorySegment PyExc_GeneratorExit() {
        return PyExc_GeneratorExit$constants.SEGMENT.get(PyExc_GeneratorExit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static void PyExc_GeneratorExit(MemorySegment varValue) {
        PyExc_GeneratorExit$constants.SEGMENT.set(PyExc_GeneratorExit$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ArithmeticError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ArithmeticError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static AddressLayout PyExc_ArithmeticError$layout() {
        return PyExc_ArithmeticError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static MemorySegment PyExc_ArithmeticError$segment() {
        return PyExc_ArithmeticError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static MemorySegment PyExc_ArithmeticError() {
        return PyExc_ArithmeticError$constants.SEGMENT.get(PyExc_ArithmeticError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static void PyExc_ArithmeticError(MemorySegment varValue) {
        PyExc_ArithmeticError$constants.SEGMENT.set(PyExc_ArithmeticError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_LookupError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_LookupError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static AddressLayout PyExc_LookupError$layout() {
        return PyExc_LookupError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static MemorySegment PyExc_LookupError$segment() {
        return PyExc_LookupError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static MemorySegment PyExc_LookupError() {
        return PyExc_LookupError$constants.SEGMENT.get(PyExc_LookupError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static void PyExc_LookupError(MemorySegment varValue) {
        PyExc_LookupError$constants.SEGMENT.set(PyExc_LookupError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_AssertionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_AssertionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static AddressLayout PyExc_AssertionError$layout() {
        return PyExc_AssertionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static MemorySegment PyExc_AssertionError$segment() {
        return PyExc_AssertionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static MemorySegment PyExc_AssertionError() {
        return PyExc_AssertionError$constants.SEGMENT.get(PyExc_AssertionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static void PyExc_AssertionError(MemorySegment varValue) {
        PyExc_AssertionError$constants.SEGMENT.set(PyExc_AssertionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_AttributeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_AttributeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static AddressLayout PyExc_AttributeError$layout() {
        return PyExc_AttributeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static MemorySegment PyExc_AttributeError$segment() {
        return PyExc_AttributeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static MemorySegment PyExc_AttributeError() {
        return PyExc_AttributeError$constants.SEGMENT.get(PyExc_AttributeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static void PyExc_AttributeError(MemorySegment varValue) {
        PyExc_AttributeError$constants.SEGMENT.set(PyExc_AttributeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BufferError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BufferError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static AddressLayout PyExc_BufferError$layout() {
        return PyExc_BufferError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static MemorySegment PyExc_BufferError$segment() {
        return PyExc_BufferError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static MemorySegment PyExc_BufferError() {
        return PyExc_BufferError$constants.SEGMENT.get(PyExc_BufferError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static void PyExc_BufferError(MemorySegment varValue) {
        PyExc_BufferError$constants.SEGMENT.set(PyExc_BufferError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_EOFError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_EOFError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static AddressLayout PyExc_EOFError$layout() {
        return PyExc_EOFError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static MemorySegment PyExc_EOFError$segment() {
        return PyExc_EOFError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static MemorySegment PyExc_EOFError() {
        return PyExc_EOFError$constants.SEGMENT.get(PyExc_EOFError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static void PyExc_EOFError(MemorySegment varValue) {
        PyExc_EOFError$constants.SEGMENT.set(PyExc_EOFError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FloatingPointError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FloatingPointError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static AddressLayout PyExc_FloatingPointError$layout() {
        return PyExc_FloatingPointError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static MemorySegment PyExc_FloatingPointError$segment() {
        return PyExc_FloatingPointError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static MemorySegment PyExc_FloatingPointError() {
        return PyExc_FloatingPointError$constants.SEGMENT.get(PyExc_FloatingPointError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static void PyExc_FloatingPointError(MemorySegment varValue) {
        PyExc_FloatingPointError$constants.SEGMENT.set(PyExc_FloatingPointError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_OSError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_OSError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static AddressLayout PyExc_OSError$layout() {
        return PyExc_OSError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static MemorySegment PyExc_OSError$segment() {
        return PyExc_OSError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static MemorySegment PyExc_OSError() {
        return PyExc_OSError$constants.SEGMENT.get(PyExc_OSError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static void PyExc_OSError(MemorySegment varValue) {
        PyExc_OSError$constants.SEGMENT.set(PyExc_OSError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ImportError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ImportError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static AddressLayout PyExc_ImportError$layout() {
        return PyExc_ImportError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static MemorySegment PyExc_ImportError$segment() {
        return PyExc_ImportError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static MemorySegment PyExc_ImportError() {
        return PyExc_ImportError$constants.SEGMENT.get(PyExc_ImportError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static void PyExc_ImportError(MemorySegment varValue) {
        PyExc_ImportError$constants.SEGMENT.set(PyExc_ImportError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ModuleNotFoundError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ModuleNotFoundError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static AddressLayout PyExc_ModuleNotFoundError$layout() {
        return PyExc_ModuleNotFoundError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static MemorySegment PyExc_ModuleNotFoundError$segment() {
        return PyExc_ModuleNotFoundError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static MemorySegment PyExc_ModuleNotFoundError() {
        return PyExc_ModuleNotFoundError$constants.SEGMENT.get(PyExc_ModuleNotFoundError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static void PyExc_ModuleNotFoundError(MemorySegment varValue) {
        PyExc_ModuleNotFoundError$constants.SEGMENT.set(PyExc_ModuleNotFoundError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IndexError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IndexError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static AddressLayout PyExc_IndexError$layout() {
        return PyExc_IndexError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static MemorySegment PyExc_IndexError$segment() {
        return PyExc_IndexError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static MemorySegment PyExc_IndexError() {
        return PyExc_IndexError$constants.SEGMENT.get(PyExc_IndexError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static void PyExc_IndexError(MemorySegment varValue) {
        PyExc_IndexError$constants.SEGMENT.set(PyExc_IndexError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_KeyError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_KeyError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static AddressLayout PyExc_KeyError$layout() {
        return PyExc_KeyError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static MemorySegment PyExc_KeyError$segment() {
        return PyExc_KeyError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static MemorySegment PyExc_KeyError() {
        return PyExc_KeyError$constants.SEGMENT.get(PyExc_KeyError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static void PyExc_KeyError(MemorySegment varValue) {
        PyExc_KeyError$constants.SEGMENT.set(PyExc_KeyError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_KeyboardInterrupt$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_KeyboardInterrupt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static AddressLayout PyExc_KeyboardInterrupt$layout() {
        return PyExc_KeyboardInterrupt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static MemorySegment PyExc_KeyboardInterrupt$segment() {
        return PyExc_KeyboardInterrupt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static MemorySegment PyExc_KeyboardInterrupt() {
        return PyExc_KeyboardInterrupt$constants.SEGMENT.get(PyExc_KeyboardInterrupt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static void PyExc_KeyboardInterrupt(MemorySegment varValue) {
        PyExc_KeyboardInterrupt$constants.SEGMENT.set(PyExc_KeyboardInterrupt$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_MemoryError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_MemoryError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static AddressLayout PyExc_MemoryError$layout() {
        return PyExc_MemoryError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static MemorySegment PyExc_MemoryError$segment() {
        return PyExc_MemoryError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static MemorySegment PyExc_MemoryError() {
        return PyExc_MemoryError$constants.SEGMENT.get(PyExc_MemoryError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static void PyExc_MemoryError(MemorySegment varValue) {
        PyExc_MemoryError$constants.SEGMENT.set(PyExc_MemoryError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_NameError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_NameError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static AddressLayout PyExc_NameError$layout() {
        return PyExc_NameError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static MemorySegment PyExc_NameError$segment() {
        return PyExc_NameError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static MemorySegment PyExc_NameError() {
        return PyExc_NameError$constants.SEGMENT.get(PyExc_NameError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static void PyExc_NameError(MemorySegment varValue) {
        PyExc_NameError$constants.SEGMENT.set(PyExc_NameError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_OverflowError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_OverflowError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static AddressLayout PyExc_OverflowError$layout() {
        return PyExc_OverflowError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static MemorySegment PyExc_OverflowError$segment() {
        return PyExc_OverflowError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static MemorySegment PyExc_OverflowError() {
        return PyExc_OverflowError$constants.SEGMENT.get(PyExc_OverflowError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static void PyExc_OverflowError(MemorySegment varValue) {
        PyExc_OverflowError$constants.SEGMENT.set(PyExc_OverflowError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_RuntimeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_RuntimeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static AddressLayout PyExc_RuntimeError$layout() {
        return PyExc_RuntimeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static MemorySegment PyExc_RuntimeError$segment() {
        return PyExc_RuntimeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static MemorySegment PyExc_RuntimeError() {
        return PyExc_RuntimeError$constants.SEGMENT.get(PyExc_RuntimeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static void PyExc_RuntimeError(MemorySegment varValue) {
        PyExc_RuntimeError$constants.SEGMENT.set(PyExc_RuntimeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_RecursionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_RecursionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static AddressLayout PyExc_RecursionError$layout() {
        return PyExc_RecursionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static MemorySegment PyExc_RecursionError$segment() {
        return PyExc_RecursionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static MemorySegment PyExc_RecursionError() {
        return PyExc_RecursionError$constants.SEGMENT.get(PyExc_RecursionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static void PyExc_RecursionError(MemorySegment varValue) {
        PyExc_RecursionError$constants.SEGMENT.set(PyExc_RecursionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_NotImplementedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_NotImplementedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static AddressLayout PyExc_NotImplementedError$layout() {
        return PyExc_NotImplementedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static MemorySegment PyExc_NotImplementedError$segment() {
        return PyExc_NotImplementedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static MemorySegment PyExc_NotImplementedError() {
        return PyExc_NotImplementedError$constants.SEGMENT.get(PyExc_NotImplementedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static void PyExc_NotImplementedError(MemorySegment varValue) {
        PyExc_NotImplementedError$constants.SEGMENT.set(PyExc_NotImplementedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SyntaxError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SyntaxError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static AddressLayout PyExc_SyntaxError$layout() {
        return PyExc_SyntaxError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static MemorySegment PyExc_SyntaxError$segment() {
        return PyExc_SyntaxError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static MemorySegment PyExc_SyntaxError() {
        return PyExc_SyntaxError$constants.SEGMENT.get(PyExc_SyntaxError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static void PyExc_SyntaxError(MemorySegment varValue) {
        PyExc_SyntaxError$constants.SEGMENT.set(PyExc_SyntaxError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IndentationError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IndentationError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static AddressLayout PyExc_IndentationError$layout() {
        return PyExc_IndentationError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static MemorySegment PyExc_IndentationError$segment() {
        return PyExc_IndentationError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static MemorySegment PyExc_IndentationError() {
        return PyExc_IndentationError$constants.SEGMENT.get(PyExc_IndentationError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static void PyExc_IndentationError(MemorySegment varValue) {
        PyExc_IndentationError$constants.SEGMENT.set(PyExc_IndentationError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_TabError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_TabError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static AddressLayout PyExc_TabError$layout() {
        return PyExc_TabError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static MemorySegment PyExc_TabError$segment() {
        return PyExc_TabError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static MemorySegment PyExc_TabError() {
        return PyExc_TabError$constants.SEGMENT.get(PyExc_TabError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static void PyExc_TabError(MemorySegment varValue) {
        PyExc_TabError$constants.SEGMENT.set(PyExc_TabError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ReferenceError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ReferenceError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static AddressLayout PyExc_ReferenceError$layout() {
        return PyExc_ReferenceError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static MemorySegment PyExc_ReferenceError$segment() {
        return PyExc_ReferenceError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static MemorySegment PyExc_ReferenceError() {
        return PyExc_ReferenceError$constants.SEGMENT.get(PyExc_ReferenceError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static void PyExc_ReferenceError(MemorySegment varValue) {
        PyExc_ReferenceError$constants.SEGMENT.set(PyExc_ReferenceError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SystemError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SystemError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static AddressLayout PyExc_SystemError$layout() {
        return PyExc_SystemError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static MemorySegment PyExc_SystemError$segment() {
        return PyExc_SystemError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static MemorySegment PyExc_SystemError() {
        return PyExc_SystemError$constants.SEGMENT.get(PyExc_SystemError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static void PyExc_SystemError(MemorySegment varValue) {
        PyExc_SystemError$constants.SEGMENT.set(PyExc_SystemError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SystemExit$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SystemExit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static AddressLayout PyExc_SystemExit$layout() {
        return PyExc_SystemExit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static MemorySegment PyExc_SystemExit$segment() {
        return PyExc_SystemExit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static MemorySegment PyExc_SystemExit() {
        return PyExc_SystemExit$constants.SEGMENT.get(PyExc_SystemExit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static void PyExc_SystemExit(MemorySegment varValue) {
        PyExc_SystemExit$constants.SEGMENT.set(PyExc_SystemExit$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_TypeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_TypeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static AddressLayout PyExc_TypeError$layout() {
        return PyExc_TypeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static MemorySegment PyExc_TypeError$segment() {
        return PyExc_TypeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static MemorySegment PyExc_TypeError() {
        return PyExc_TypeError$constants.SEGMENT.get(PyExc_TypeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static void PyExc_TypeError(MemorySegment varValue) {
        PyExc_TypeError$constants.SEGMENT.set(PyExc_TypeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnboundLocalError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnboundLocalError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static AddressLayout PyExc_UnboundLocalError$layout() {
        return PyExc_UnboundLocalError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static MemorySegment PyExc_UnboundLocalError$segment() {
        return PyExc_UnboundLocalError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static MemorySegment PyExc_UnboundLocalError() {
        return PyExc_UnboundLocalError$constants.SEGMENT.get(PyExc_UnboundLocalError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static void PyExc_UnboundLocalError(MemorySegment varValue) {
        PyExc_UnboundLocalError$constants.SEGMENT.set(PyExc_UnboundLocalError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static AddressLayout PyExc_UnicodeError$layout() {
        return PyExc_UnicodeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeError$segment() {
        return PyExc_UnicodeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeError() {
        return PyExc_UnicodeError$constants.SEGMENT.get(PyExc_UnicodeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static void PyExc_UnicodeError(MemorySegment varValue) {
        PyExc_UnicodeError$constants.SEGMENT.set(PyExc_UnicodeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeEncodeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeEncodeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static AddressLayout PyExc_UnicodeEncodeError$layout() {
        return PyExc_UnicodeEncodeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeEncodeError$segment() {
        return PyExc_UnicodeEncodeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeEncodeError() {
        return PyExc_UnicodeEncodeError$constants.SEGMENT.get(PyExc_UnicodeEncodeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static void PyExc_UnicodeEncodeError(MemorySegment varValue) {
        PyExc_UnicodeEncodeError$constants.SEGMENT.set(PyExc_UnicodeEncodeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeDecodeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeDecodeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static AddressLayout PyExc_UnicodeDecodeError$layout() {
        return PyExc_UnicodeDecodeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeDecodeError$segment() {
        return PyExc_UnicodeDecodeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeDecodeError() {
        return PyExc_UnicodeDecodeError$constants.SEGMENT.get(PyExc_UnicodeDecodeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static void PyExc_UnicodeDecodeError(MemorySegment varValue) {
        PyExc_UnicodeDecodeError$constants.SEGMENT.set(PyExc_UnicodeDecodeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeTranslateError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeTranslateError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static AddressLayout PyExc_UnicodeTranslateError$layout() {
        return PyExc_UnicodeTranslateError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static MemorySegment PyExc_UnicodeTranslateError$segment() {
        return PyExc_UnicodeTranslateError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static MemorySegment PyExc_UnicodeTranslateError() {
        return PyExc_UnicodeTranslateError$constants.SEGMENT.get(PyExc_UnicodeTranslateError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static void PyExc_UnicodeTranslateError(MemorySegment varValue) {
        PyExc_UnicodeTranslateError$constants.SEGMENT.set(PyExc_UnicodeTranslateError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ValueError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ValueError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static AddressLayout PyExc_ValueError$layout() {
        return PyExc_ValueError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static MemorySegment PyExc_ValueError$segment() {
        return PyExc_ValueError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static MemorySegment PyExc_ValueError() {
        return PyExc_ValueError$constants.SEGMENT.get(PyExc_ValueError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static void PyExc_ValueError(MemorySegment varValue) {
        PyExc_ValueError$constants.SEGMENT.set(PyExc_ValueError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ZeroDivisionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ZeroDivisionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static AddressLayout PyExc_ZeroDivisionError$layout() {
        return PyExc_ZeroDivisionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static MemorySegment PyExc_ZeroDivisionError$segment() {
        return PyExc_ZeroDivisionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static MemorySegment PyExc_ZeroDivisionError() {
        return PyExc_ZeroDivisionError$constants.SEGMENT.get(PyExc_ZeroDivisionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static void PyExc_ZeroDivisionError(MemorySegment varValue) {
        PyExc_ZeroDivisionError$constants.SEGMENT.set(PyExc_ZeroDivisionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BlockingIOError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BlockingIOError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static AddressLayout PyExc_BlockingIOError$layout() {
        return PyExc_BlockingIOError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static MemorySegment PyExc_BlockingIOError$segment() {
        return PyExc_BlockingIOError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static MemorySegment PyExc_BlockingIOError() {
        return PyExc_BlockingIOError$constants.SEGMENT.get(PyExc_BlockingIOError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static void PyExc_BlockingIOError(MemorySegment varValue) {
        PyExc_BlockingIOError$constants.SEGMENT.set(PyExc_BlockingIOError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BrokenPipeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BrokenPipeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static AddressLayout PyExc_BrokenPipeError$layout() {
        return PyExc_BrokenPipeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static MemorySegment PyExc_BrokenPipeError$segment() {
        return PyExc_BrokenPipeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static MemorySegment PyExc_BrokenPipeError() {
        return PyExc_BrokenPipeError$constants.SEGMENT.get(PyExc_BrokenPipeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static void PyExc_BrokenPipeError(MemorySegment varValue) {
        PyExc_BrokenPipeError$constants.SEGMENT.set(PyExc_BrokenPipeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ChildProcessError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ChildProcessError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static AddressLayout PyExc_ChildProcessError$layout() {
        return PyExc_ChildProcessError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static MemorySegment PyExc_ChildProcessError$segment() {
        return PyExc_ChildProcessError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static MemorySegment PyExc_ChildProcessError() {
        return PyExc_ChildProcessError$constants.SEGMENT.get(PyExc_ChildProcessError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static void PyExc_ChildProcessError(MemorySegment varValue) {
        PyExc_ChildProcessError$constants.SEGMENT.set(PyExc_ChildProcessError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static AddressLayout PyExc_ConnectionError$layout() {
        return PyExc_ConnectionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static MemorySegment PyExc_ConnectionError$segment() {
        return PyExc_ConnectionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static MemorySegment PyExc_ConnectionError() {
        return PyExc_ConnectionError$constants.SEGMENT.get(PyExc_ConnectionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static void PyExc_ConnectionError(MemorySegment varValue) {
        PyExc_ConnectionError$constants.SEGMENT.set(PyExc_ConnectionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionAbortedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionAbortedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static AddressLayout PyExc_ConnectionAbortedError$layout() {
        return PyExc_ConnectionAbortedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static MemorySegment PyExc_ConnectionAbortedError$segment() {
        return PyExc_ConnectionAbortedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static MemorySegment PyExc_ConnectionAbortedError() {
        return PyExc_ConnectionAbortedError$constants.SEGMENT.get(PyExc_ConnectionAbortedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static void PyExc_ConnectionAbortedError(MemorySegment varValue) {
        PyExc_ConnectionAbortedError$constants.SEGMENT.set(PyExc_ConnectionAbortedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionRefusedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionRefusedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static AddressLayout PyExc_ConnectionRefusedError$layout() {
        return PyExc_ConnectionRefusedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static MemorySegment PyExc_ConnectionRefusedError$segment() {
        return PyExc_ConnectionRefusedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static MemorySegment PyExc_ConnectionRefusedError() {
        return PyExc_ConnectionRefusedError$constants.SEGMENT.get(PyExc_ConnectionRefusedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static void PyExc_ConnectionRefusedError(MemorySegment varValue) {
        PyExc_ConnectionRefusedError$constants.SEGMENT.set(PyExc_ConnectionRefusedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionResetError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionResetError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static AddressLayout PyExc_ConnectionResetError$layout() {
        return PyExc_ConnectionResetError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static MemorySegment PyExc_ConnectionResetError$segment() {
        return PyExc_ConnectionResetError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static MemorySegment PyExc_ConnectionResetError() {
        return PyExc_ConnectionResetError$constants.SEGMENT.get(PyExc_ConnectionResetError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static void PyExc_ConnectionResetError(MemorySegment varValue) {
        PyExc_ConnectionResetError$constants.SEGMENT.set(PyExc_ConnectionResetError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FileExistsError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FileExistsError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static AddressLayout PyExc_FileExistsError$layout() {
        return PyExc_FileExistsError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static MemorySegment PyExc_FileExistsError$segment() {
        return PyExc_FileExistsError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static MemorySegment PyExc_FileExistsError() {
        return PyExc_FileExistsError$constants.SEGMENT.get(PyExc_FileExistsError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static void PyExc_FileExistsError(MemorySegment varValue) {
        PyExc_FileExistsError$constants.SEGMENT.set(PyExc_FileExistsError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FileNotFoundError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FileNotFoundError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static AddressLayout PyExc_FileNotFoundError$layout() {
        return PyExc_FileNotFoundError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static MemorySegment PyExc_FileNotFoundError$segment() {
        return PyExc_FileNotFoundError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static MemorySegment PyExc_FileNotFoundError() {
        return PyExc_FileNotFoundError$constants.SEGMENT.get(PyExc_FileNotFoundError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static void PyExc_FileNotFoundError(MemorySegment varValue) {
        PyExc_FileNotFoundError$constants.SEGMENT.set(PyExc_FileNotFoundError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_InterruptedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_InterruptedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static AddressLayout PyExc_InterruptedError$layout() {
        return PyExc_InterruptedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static MemorySegment PyExc_InterruptedError$segment() {
        return PyExc_InterruptedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static MemorySegment PyExc_InterruptedError() {
        return PyExc_InterruptedError$constants.SEGMENT.get(PyExc_InterruptedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static void PyExc_InterruptedError(MemorySegment varValue) {
        PyExc_InterruptedError$constants.SEGMENT.set(PyExc_InterruptedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IsADirectoryError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IsADirectoryError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static AddressLayout PyExc_IsADirectoryError$layout() {
        return PyExc_IsADirectoryError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static MemorySegment PyExc_IsADirectoryError$segment() {
        return PyExc_IsADirectoryError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static MemorySegment PyExc_IsADirectoryError() {
        return PyExc_IsADirectoryError$constants.SEGMENT.get(PyExc_IsADirectoryError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static void PyExc_IsADirectoryError(MemorySegment varValue) {
        PyExc_IsADirectoryError$constants.SEGMENT.set(PyExc_IsADirectoryError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_NotADirectoryError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_NotADirectoryError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static AddressLayout PyExc_NotADirectoryError$layout() {
        return PyExc_NotADirectoryError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static MemorySegment PyExc_NotADirectoryError$segment() {
        return PyExc_NotADirectoryError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static MemorySegment PyExc_NotADirectoryError() {
        return PyExc_NotADirectoryError$constants.SEGMENT.get(PyExc_NotADirectoryError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static void PyExc_NotADirectoryError(MemorySegment varValue) {
        PyExc_NotADirectoryError$constants.SEGMENT.set(PyExc_NotADirectoryError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_PermissionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_PermissionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static AddressLayout PyExc_PermissionError$layout() {
        return PyExc_PermissionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static MemorySegment PyExc_PermissionError$segment() {
        return PyExc_PermissionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static MemorySegment PyExc_PermissionError() {
        return PyExc_PermissionError$constants.SEGMENT.get(PyExc_PermissionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static void PyExc_PermissionError(MemorySegment varValue) {
        PyExc_PermissionError$constants.SEGMENT.set(PyExc_PermissionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ProcessLookupError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ProcessLookupError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static AddressLayout PyExc_ProcessLookupError$layout() {
        return PyExc_ProcessLookupError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static MemorySegment PyExc_ProcessLookupError$segment() {
        return PyExc_ProcessLookupError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static MemorySegment PyExc_ProcessLookupError() {
        return PyExc_ProcessLookupError$constants.SEGMENT.get(PyExc_ProcessLookupError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static void PyExc_ProcessLookupError(MemorySegment varValue) {
        PyExc_ProcessLookupError$constants.SEGMENT.set(PyExc_ProcessLookupError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_TimeoutError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_TimeoutError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static AddressLayout PyExc_TimeoutError$layout() {
        return PyExc_TimeoutError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static MemorySegment PyExc_TimeoutError$segment() {
        return PyExc_TimeoutError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static MemorySegment PyExc_TimeoutError() {
        return PyExc_TimeoutError$constants.SEGMENT.get(PyExc_TimeoutError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static void PyExc_TimeoutError(MemorySegment varValue) {
        PyExc_TimeoutError$constants.SEGMENT.set(PyExc_TimeoutError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_EnvironmentError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_EnvironmentError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static AddressLayout PyExc_EnvironmentError$layout() {
        return PyExc_EnvironmentError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static MemorySegment PyExc_EnvironmentError$segment() {
        return PyExc_EnvironmentError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static MemorySegment PyExc_EnvironmentError() {
        return PyExc_EnvironmentError$constants.SEGMENT.get(PyExc_EnvironmentError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static void PyExc_EnvironmentError(MemorySegment varValue) {
        PyExc_EnvironmentError$constants.SEGMENT.set(PyExc_EnvironmentError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IOError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IOError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static AddressLayout PyExc_IOError$layout() {
        return PyExc_IOError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static MemorySegment PyExc_IOError$segment() {
        return PyExc_IOError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static MemorySegment PyExc_IOError() {
        return PyExc_IOError$constants.SEGMENT.get(PyExc_IOError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static void PyExc_IOError(MemorySegment varValue) {
        PyExc_IOError$constants.SEGMENT.set(PyExc_IOError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_Warning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_Warning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static AddressLayout PyExc_Warning$layout() {
        return PyExc_Warning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static MemorySegment PyExc_Warning$segment() {
        return PyExc_Warning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static MemorySegment PyExc_Warning() {
        return PyExc_Warning$constants.SEGMENT.get(PyExc_Warning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static void PyExc_Warning(MemorySegment varValue) {
        PyExc_Warning$constants.SEGMENT.set(PyExc_Warning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UserWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UserWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static AddressLayout PyExc_UserWarning$layout() {
        return PyExc_UserWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static MemorySegment PyExc_UserWarning$segment() {
        return PyExc_UserWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static MemorySegment PyExc_UserWarning() {
        return PyExc_UserWarning$constants.SEGMENT.get(PyExc_UserWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static void PyExc_UserWarning(MemorySegment varValue) {
        PyExc_UserWarning$constants.SEGMENT.set(PyExc_UserWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_DeprecationWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_DeprecationWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static AddressLayout PyExc_DeprecationWarning$layout() {
        return PyExc_DeprecationWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static MemorySegment PyExc_DeprecationWarning$segment() {
        return PyExc_DeprecationWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static MemorySegment PyExc_DeprecationWarning() {
        return PyExc_DeprecationWarning$constants.SEGMENT.get(PyExc_DeprecationWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static void PyExc_DeprecationWarning(MemorySegment varValue) {
        PyExc_DeprecationWarning$constants.SEGMENT.set(PyExc_DeprecationWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_PendingDeprecationWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_PendingDeprecationWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static AddressLayout PyExc_PendingDeprecationWarning$layout() {
        return PyExc_PendingDeprecationWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static MemorySegment PyExc_PendingDeprecationWarning$segment() {
        return PyExc_PendingDeprecationWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static MemorySegment PyExc_PendingDeprecationWarning() {
        return PyExc_PendingDeprecationWarning$constants.SEGMENT.get(PyExc_PendingDeprecationWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static void PyExc_PendingDeprecationWarning(MemorySegment varValue) {
        PyExc_PendingDeprecationWarning$constants.SEGMENT.set(PyExc_PendingDeprecationWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SyntaxWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SyntaxWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static AddressLayout PyExc_SyntaxWarning$layout() {
        return PyExc_SyntaxWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static MemorySegment PyExc_SyntaxWarning$segment() {
        return PyExc_SyntaxWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static MemorySegment PyExc_SyntaxWarning() {
        return PyExc_SyntaxWarning$constants.SEGMENT.get(PyExc_SyntaxWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static void PyExc_SyntaxWarning(MemorySegment varValue) {
        PyExc_SyntaxWarning$constants.SEGMENT.set(PyExc_SyntaxWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_RuntimeWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_RuntimeWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static AddressLayout PyExc_RuntimeWarning$layout() {
        return PyExc_RuntimeWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static MemorySegment PyExc_RuntimeWarning$segment() {
        return PyExc_RuntimeWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static MemorySegment PyExc_RuntimeWarning() {
        return PyExc_RuntimeWarning$constants.SEGMENT.get(PyExc_RuntimeWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static void PyExc_RuntimeWarning(MemorySegment varValue) {
        PyExc_RuntimeWarning$constants.SEGMENT.set(PyExc_RuntimeWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FutureWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FutureWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static AddressLayout PyExc_FutureWarning$layout() {
        return PyExc_FutureWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static MemorySegment PyExc_FutureWarning$segment() {
        return PyExc_FutureWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static MemorySegment PyExc_FutureWarning() {
        return PyExc_FutureWarning$constants.SEGMENT.get(PyExc_FutureWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static void PyExc_FutureWarning(MemorySegment varValue) {
        PyExc_FutureWarning$constants.SEGMENT.set(PyExc_FutureWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ImportWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ImportWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static AddressLayout PyExc_ImportWarning$layout() {
        return PyExc_ImportWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static MemorySegment PyExc_ImportWarning$segment() {
        return PyExc_ImportWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static MemorySegment PyExc_ImportWarning() {
        return PyExc_ImportWarning$constants.SEGMENT.get(PyExc_ImportWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static void PyExc_ImportWarning(MemorySegment varValue) {
        PyExc_ImportWarning$constants.SEGMENT.set(PyExc_ImportWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static AddressLayout PyExc_UnicodeWarning$layout() {
        return PyExc_UnicodeWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static MemorySegment PyExc_UnicodeWarning$segment() {
        return PyExc_UnicodeWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static MemorySegment PyExc_UnicodeWarning() {
        return PyExc_UnicodeWarning$constants.SEGMENT.get(PyExc_UnicodeWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static void PyExc_UnicodeWarning(MemorySegment varValue) {
        PyExc_UnicodeWarning$constants.SEGMENT.set(PyExc_UnicodeWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BytesWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BytesWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static AddressLayout PyExc_BytesWarning$layout() {
        return PyExc_BytesWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static MemorySegment PyExc_BytesWarning$segment() {
        return PyExc_BytesWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static MemorySegment PyExc_BytesWarning() {
        return PyExc_BytesWarning$constants.SEGMENT.get(PyExc_BytesWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static void PyExc_BytesWarning(MemorySegment varValue) {
        PyExc_BytesWarning$constants.SEGMENT.set(PyExc_BytesWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_EncodingWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_EncodingWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static AddressLayout PyExc_EncodingWarning$layout() {
        return PyExc_EncodingWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static MemorySegment PyExc_EncodingWarning$segment() {
        return PyExc_EncodingWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static MemorySegment PyExc_EncodingWarning() {
        return PyExc_EncodingWarning$constants.SEGMENT.get(PyExc_EncodingWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static void PyExc_EncodingWarning(MemorySegment varValue) {
        PyExc_EncodingWarning$constants.SEGMENT.set(PyExc_EncodingWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ResourceWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ResourceWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static AddressLayout PyExc_ResourceWarning$layout() {
        return PyExc_ResourceWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static MemorySegment PyExc_ResourceWarning$segment() {
        return PyExc_ResourceWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static MemorySegment PyExc_ResourceWarning() {
        return PyExc_ResourceWarning$constants.SEGMENT.get(PyExc_ResourceWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static void PyExc_ResourceWarning(MemorySegment varValue) {
        PyExc_ResourceWarning$constants.SEGMENT.set(PyExc_ResourceWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyErr_BadArgument {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_BadArgument");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static FunctionDescriptor PyErr_BadArgument$descriptor() {
        return PyErr_BadArgument.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static MethodHandle PyErr_BadArgument$handle() {
        return PyErr_BadArgument.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static MemorySegment PyErr_BadArgument$address() {
        return PyErr_BadArgument.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static int PyErr_BadArgument() {
        var mh$ = PyErr_BadArgument.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_BadArgument");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NoMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NoMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static FunctionDescriptor PyErr_NoMemory$descriptor() {
        return PyErr_NoMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static MethodHandle PyErr_NoMemory$handle() {
        return PyErr_NoMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static MemorySegment PyErr_NoMemory$address() {
        return PyErr_NoMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static MemorySegment PyErr_NoMemory() {
        var mh$ = PyErr_NoMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NoMemory");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrno$descriptor() {
        return PyErr_SetFromErrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetFromErrno$handle() {
        return PyErr_SetFromErrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrno$address() {
        return PyErr_SetFromErrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrno(MemorySegment x0) {
        var mh$ = PyErr_SetFromErrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrno", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrnoWithFilenameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrnoWithFilenameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrnoWithFilenameObject$descriptor() {
        return PyErr_SetFromErrnoWithFilenameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetFromErrnoWithFilenameObject$handle() {
        return PyErr_SetFromErrnoWithFilenameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObject$address() {
        return PyErr_SetFromErrnoWithFilenameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyErr_SetFromErrnoWithFilenameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrnoWithFilenameObject", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrnoWithFilenameObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrnoWithFilenameObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrnoWithFilenameObjects$descriptor() {
        return PyErr_SetFromErrnoWithFilenameObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetFromErrnoWithFilenameObjects$handle() {
        return PyErr_SetFromErrnoWithFilenameObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObjects$address() {
        return PyErr_SetFromErrnoWithFilenameObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObjects(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_SetFromErrnoWithFilenameObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrnoWithFilenameObjects", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrnoWithFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrnoWithFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrnoWithFilename$descriptor() {
        return PyErr_SetFromErrnoWithFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static MethodHandle PyErr_SetFromErrnoWithFilename$handle() {
        return PyErr_SetFromErrnoWithFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilename$address() {
        return PyErr_SetFromErrnoWithFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilename(MemorySegment exc, MemorySegment filename) {
        var mh$ = PyErr_SetFromErrnoWithFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrnoWithFilename", exc, filename);
            }
            return (MemorySegment)mh$.invokeExact(exc, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyErr_Format(PyObject *exception, const char *format, ...)
     * }
     */
    public static class PyErr_Format {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Format");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_Format(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyErr_Format(PyObject *exception, const char *format, ...)
         * }
         */
        public static PyErr_Format makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_Format(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment exception, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_Format", exception, format, x2);
                }
                return (MemorySegment) spreader.invokeExact(exception, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyErr_FormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_FormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static FunctionDescriptor PyErr_FormatV$descriptor() {
        return PyErr_FormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static MethodHandle PyErr_FormatV$handle() {
        return PyErr_FormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyErr_FormatV$address() {
        return PyErr_FormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyErr_FormatV(MemorySegment exception, MemorySegment format, MemorySegment vargs) {
        var mh$ = PyErr_FormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_FormatV", exception, format, vargs);
            }
            return (MemorySegment)mh$.invokeExact(exception, format, vargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetImportErrorSubclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetImportErrorSubclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetImportErrorSubclass$descriptor() {
        return PyErr_SetImportErrorSubclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetImportErrorSubclass$handle() {
        return PyErr_SetImportErrorSubclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportErrorSubclass$address() {
        return PyErr_SetImportErrorSubclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportErrorSubclass(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyErr_SetImportErrorSubclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetImportErrorSubclass", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetImportError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetImportError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetImportError$descriptor() {
        return PyErr_SetImportError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetImportError$handle() {
        return PyErr_SetImportError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportError$address() {
        return PyErr_SetImportError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportError(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_SetImportError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetImportError", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_BadInternalCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_BadInternalCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static FunctionDescriptor PyErr_BadInternalCall$descriptor() {
        return PyErr_BadInternalCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static MethodHandle PyErr_BadInternalCall$handle() {
        return PyErr_BadInternalCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static MemorySegment PyErr_BadInternalCall$address() {
        return PyErr_BadInternalCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static void PyErr_BadInternalCall() {
        var mh$ = PyErr_BadInternalCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_BadInternalCall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_BadInternalCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_BadInternalCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static FunctionDescriptor _PyErr_BadInternalCall$descriptor() {
        return _PyErr_BadInternalCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static MethodHandle _PyErr_BadInternalCall$handle() {
        return _PyErr_BadInternalCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static MemorySegment _PyErr_BadInternalCall$address() {
        return _PyErr_BadInternalCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static void _PyErr_BadInternalCall(MemorySegment filename, int lineno) {
        var mh$ = _PyErr_BadInternalCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_BadInternalCall", filename, lineno);
            }
            mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NewException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NewException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyErr_NewException$descriptor() {
        return PyErr_NewException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static MethodHandle PyErr_NewException$handle() {
        return PyErr_NewException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewException$address() {
        return PyErr_NewException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewException(MemorySegment name, MemorySegment base, MemorySegment dict) {
        var mh$ = PyErr_NewException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NewException", name, base, dict);
            }
            return (MemorySegment)mh$.invokeExact(name, base, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NewExceptionWithDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NewExceptionWithDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyErr_NewExceptionWithDoc$descriptor() {
        return PyErr_NewExceptionWithDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static MethodHandle PyErr_NewExceptionWithDoc$handle() {
        return PyErr_NewExceptionWithDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewExceptionWithDoc$address() {
        return PyErr_NewExceptionWithDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewExceptionWithDoc(MemorySegment name, MemorySegment doc, MemorySegment base, MemorySegment dict) {
        var mh$ = PyErr_NewExceptionWithDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NewExceptionWithDoc", name, doc, base, dict);
            }
            return (MemorySegment)mh$.invokeExact(name, doc, base, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_WriteUnraisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WriteUnraisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_WriteUnraisable$descriptor() {
        return PyErr_WriteUnraisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static MethodHandle PyErr_WriteUnraisable$handle() {
        return PyErr_WriteUnraisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static MemorySegment PyErr_WriteUnraisable$address() {
        return PyErr_WriteUnraisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static void PyErr_WriteUnraisable(MemorySegment x0) {
        var mh$ = PyErr_WriteUnraisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WriteUnraisable", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_CheckSignals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_CheckSignals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static FunctionDescriptor PyErr_CheckSignals$descriptor() {
        return PyErr_CheckSignals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static MethodHandle PyErr_CheckSignals$handle() {
        return PyErr_CheckSignals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static MemorySegment PyErr_CheckSignals$address() {
        return PyErr_CheckSignals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static int PyErr_CheckSignals() {
        var mh$ = PyErr_CheckSignals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_CheckSignals");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetInterrupt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetInterrupt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static FunctionDescriptor PyErr_SetInterrupt$descriptor() {
        return PyErr_SetInterrupt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static MethodHandle PyErr_SetInterrupt$handle() {
        return PyErr_SetInterrupt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static MemorySegment PyErr_SetInterrupt$address() {
        return PyErr_SetInterrupt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static void PyErr_SetInterrupt() {
        var mh$ = PyErr_SetInterrupt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetInterrupt");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetInterruptEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetInterruptEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static FunctionDescriptor PyErr_SetInterruptEx$descriptor() {
        return PyErr_SetInterruptEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static MethodHandle PyErr_SetInterruptEx$handle() {
        return PyErr_SetInterruptEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static MemorySegment PyErr_SetInterruptEx$address() {
        return PyErr_SetInterruptEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static int PyErr_SetInterruptEx(int signum) {
        var mh$ = PyErr_SetInterruptEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetInterruptEx", signum);
            }
            return (int)mh$.invokeExact(signum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SyntaxLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SyntaxLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static FunctionDescriptor PyErr_SyntaxLocation$descriptor() {
        return PyErr_SyntaxLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static MethodHandle PyErr_SyntaxLocation$handle() {
        return PyErr_SyntaxLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_SyntaxLocation$address() {
        return PyErr_SyntaxLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static void PyErr_SyntaxLocation(MemorySegment filename, int lineno) {
        var mh$ = PyErr_SyntaxLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SyntaxLocation", filename, lineno);
            }
            mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SyntaxLocationEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SyntaxLocationEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static FunctionDescriptor PyErr_SyntaxLocationEx$descriptor() {
        return PyErr_SyntaxLocationEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static MethodHandle PyErr_SyntaxLocationEx$handle() {
        return PyErr_SyntaxLocationEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static MemorySegment PyErr_SyntaxLocationEx$address() {
        return PyErr_SyntaxLocationEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static void PyErr_SyntaxLocationEx(MemorySegment filename, int lineno, int col_offset) {
        var mh$ = PyErr_SyntaxLocationEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SyntaxLocationEx", filename, lineno, col_offset);
            }
            mh$.invokeExact(filename, lineno, col_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_ProgramText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ProgramText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static FunctionDescriptor PyErr_ProgramText$descriptor() {
        return PyErr_ProgramText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static MethodHandle PyErr_ProgramText$handle() {
        return PyErr_ProgramText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramText$address() {
        return PyErr_ProgramText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramText(MemorySegment filename, int lineno) {
        var mh$ = PyErr_ProgramText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_ProgramText", filename, lineno);
            }
            return (MemorySegment)mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_Create$descriptor() {
        return PyUnicodeDecodeError_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_Create$handle() {
        return PyUnicodeDecodeError_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_Create$address() {
        return PyUnicodeDecodeError_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_Create(MemorySegment encoding, MemorySegment object, long length, long start, long end, MemorySegment reason) {
        var mh$ = PyUnicodeDecodeError_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_Create", encoding, object, length, start, end, reason);
            }
            return (MemorySegment)mh$.invokeExact(encoding, object, length, start, end, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetEncoding$descriptor() {
        return PyUnicodeEncodeError_GetEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetEncoding$handle() {
        return PyUnicodeEncodeError_GetEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetEncoding$address() {
        return PyUnicodeEncodeError_GetEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetEncoding(MemorySegment x0) {
        var mh$ = PyUnicodeEncodeError_GetEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetEncoding", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetEncoding$descriptor() {
        return PyUnicodeDecodeError_GetEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetEncoding$handle() {
        return PyUnicodeDecodeError_GetEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetEncoding$address() {
        return PyUnicodeDecodeError_GetEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetEncoding(MemorySegment x0) {
        var mh$ = PyUnicodeDecodeError_GetEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetEncoding", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetObject$descriptor() {
        return PyUnicodeEncodeError_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetObject$handle() {
        return PyUnicodeEncodeError_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetObject$address() {
        return PyUnicodeEncodeError_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetObject(MemorySegment x0) {
        var mh$ = PyUnicodeEncodeError_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetObject$descriptor() {
        return PyUnicodeDecodeError_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetObject$handle() {
        return PyUnicodeDecodeError_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetObject$address() {
        return PyUnicodeDecodeError_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetObject(MemorySegment x0) {
        var mh$ = PyUnicodeDecodeError_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetObject$descriptor() {
        return PyUnicodeTranslateError_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetObject$handle() {
        return PyUnicodeTranslateError_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetObject$address() {
        return PyUnicodeTranslateError_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetObject(MemorySegment x0) {
        var mh$ = PyUnicodeTranslateError_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetStart$descriptor() {
        return PyUnicodeEncodeError_GetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetStart$handle() {
        return PyUnicodeEncodeError_GetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetStart$address() {
        return PyUnicodeEncodeError_GetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeEncodeError_GetStart(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeEncodeError_GetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetStart$descriptor() {
        return PyUnicodeDecodeError_GetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetStart$handle() {
        return PyUnicodeDecodeError_GetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetStart$address() {
        return PyUnicodeDecodeError_GetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeDecodeError_GetStart(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeDecodeError_GetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetStart$descriptor() {
        return PyUnicodeTranslateError_GetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetStart$handle() {
        return PyUnicodeTranslateError_GetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetStart$address() {
        return PyUnicodeTranslateError_GetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeTranslateError_GetStart(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeTranslateError_GetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_SetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_SetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_SetStart$descriptor() {
        return PyUnicodeEncodeError_SetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_SetStart$handle() {
        return PyUnicodeEncodeError_SetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_SetStart$address() {
        return PyUnicodeEncodeError_SetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeEncodeError_SetStart(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeEncodeError_SetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_SetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_SetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_SetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_SetStart$descriptor() {
        return PyUnicodeDecodeError_SetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_SetStart$handle() {
        return PyUnicodeDecodeError_SetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_SetStart$address() {
        return PyUnicodeDecodeError_SetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeDecodeError_SetStart(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeDecodeError_SetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_SetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_SetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_SetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_SetStart$descriptor() {
        return PyUnicodeTranslateError_SetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_SetStart$handle() {
        return PyUnicodeTranslateError_SetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_SetStart$address() {
        return PyUnicodeTranslateError_SetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeTranslateError_SetStart(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeTranslateError_SetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_SetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetEnd$descriptor() {
        return PyUnicodeEncodeError_GetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetEnd$handle() {
        return PyUnicodeEncodeError_GetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetEnd$address() {
        return PyUnicodeEncodeError_GetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeEncodeError_GetEnd(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeEncodeError_GetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetEnd$descriptor() {
        return PyUnicodeDecodeError_GetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetEnd$handle() {
        return PyUnicodeDecodeError_GetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetEnd$address() {
        return PyUnicodeDecodeError_GetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeDecodeError_GetEnd(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeDecodeError_GetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetEnd$descriptor() {
        return PyUnicodeTranslateError_GetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetEnd$handle() {
        return PyUnicodeTranslateError_GetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetEnd$address() {
        return PyUnicodeTranslateError_GetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeTranslateError_GetEnd(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeTranslateError_GetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_SetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_SetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_SetEnd$descriptor() {
        return PyUnicodeEncodeError_SetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_SetEnd$handle() {
        return PyUnicodeEncodeError_SetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_SetEnd$address() {
        return PyUnicodeEncodeError_SetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeEncodeError_SetEnd(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeEncodeError_SetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_SetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_SetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_SetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_SetEnd$descriptor() {
        return PyUnicodeDecodeError_SetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_SetEnd$handle() {
        return PyUnicodeDecodeError_SetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_SetEnd$address() {
        return PyUnicodeDecodeError_SetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeDecodeError_SetEnd(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeDecodeError_SetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_SetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_SetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_SetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_SetEnd$descriptor() {
        return PyUnicodeTranslateError_SetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_SetEnd$handle() {
        return PyUnicodeTranslateError_SetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_SetEnd$address() {
        return PyUnicodeTranslateError_SetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeTranslateError_SetEnd(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeTranslateError_SetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_SetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetReason$descriptor() {
        return PyUnicodeEncodeError_GetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetReason$handle() {
        return PyUnicodeEncodeError_GetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetReason$address() {
        return PyUnicodeEncodeError_GetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetReason(MemorySegment x0) {
        var mh$ = PyUnicodeEncodeError_GetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetReason", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetReason$descriptor() {
        return PyUnicodeDecodeError_GetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetReason$handle() {
        return PyUnicodeDecodeError_GetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetReason$address() {
        return PyUnicodeDecodeError_GetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetReason(MemorySegment x0) {
        var mh$ = PyUnicodeDecodeError_GetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetReason", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetReason$descriptor() {
        return PyUnicodeTranslateError_GetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetReason$handle() {
        return PyUnicodeTranslateError_GetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetReason$address() {
        return PyUnicodeTranslateError_GetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetReason(MemorySegment x0) {
        var mh$ = PyUnicodeTranslateError_GetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetReason", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_SetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_SetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_SetReason$descriptor() {
        return PyUnicodeEncodeError_SetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_SetReason$handle() {
        return PyUnicodeEncodeError_SetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_SetReason$address() {
        return PyUnicodeEncodeError_SetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static int PyUnicodeEncodeError_SetReason(MemorySegment exc, MemorySegment reason) {
        var mh$ = PyUnicodeEncodeError_SetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_SetReason", exc, reason);
            }
            return (int)mh$.invokeExact(exc, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_SetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_SetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_SetReason$descriptor() {
        return PyUnicodeDecodeError_SetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_SetReason$handle() {
        return PyUnicodeDecodeError_SetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_SetReason$address() {
        return PyUnicodeDecodeError_SetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static int PyUnicodeDecodeError_SetReason(MemorySegment exc, MemorySegment reason) {
        var mh$ = PyUnicodeDecodeError_SetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_SetReason", exc, reason);
            }
            return (int)mh$.invokeExact(exc, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_SetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_SetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_SetReason$descriptor() {
        return PyUnicodeTranslateError_SetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_SetReason$handle() {
        return PyUnicodeTranslateError_SetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_SetReason$address() {
        return PyUnicodeTranslateError_SetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static int PyUnicodeTranslateError_SetReason(MemorySegment exc, MemorySegment reason) {
        var mh$ = PyUnicodeTranslateError_SetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_SetReason", exc, reason);
            }
            return (int)mh$.invokeExact(exc, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyOS_snprintf(char *str, size_t size, const char *format, ...)
     * }
     */
    public static class PyOS_snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyOS_snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyOS_snprintf(char *str, size_t size, const char *format, ...)
         * }
         */
        public static PyOS_snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyOS_snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment str, long size, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyOS_snprintf", str, size, format, x3);
                }
                return (int) spreader.invokeExact(str, size, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyOS_vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static FunctionDescriptor PyOS_vsnprintf$descriptor() {
        return PyOS_vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static MethodHandle PyOS_vsnprintf$handle() {
        return PyOS_vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static MemorySegment PyOS_vsnprintf$address() {
        return PyOS_vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static int PyOS_vsnprintf(MemorySegment str, long size, MemorySegment format, MemorySegment va) {
        var mh$ = PyOS_vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_vsnprintf", str, size, format, va);
            }
            return (int)mh$.invokeExact(str, size, format, va);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_ChainExceptions1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_ChainExceptions1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyErr_ChainExceptions1(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyErr_ChainExceptions1$descriptor() {
        return _PyErr_ChainExceptions1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyErr_ChainExceptions1(PyObject *)
     * }
     */
    public static MethodHandle _PyErr_ChainExceptions1$handle() {
        return _PyErr_ChainExceptions1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyErr_ChainExceptions1(PyObject *)
     * }
     */
    public static MemorySegment _PyErr_ChainExceptions1$address() {
        return _PyErr_ChainExceptions1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyErr_ChainExceptions1(PyObject *)
     * }
     */
    public static void _PyErr_ChainExceptions1(MemorySegment x0) {
        var mh$ = _PyErr_ChainExceptions1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_ChainExceptions1", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Exc_PrepReraiseStar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Exc_PrepReraiseStar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_Exc_PrepReraiseStar(PyObject *orig, PyObject *excs)
     * }
     */
    public static FunctionDescriptor PyUnstable_Exc_PrepReraiseStar$descriptor() {
        return PyUnstable_Exc_PrepReraiseStar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_Exc_PrepReraiseStar(PyObject *orig, PyObject *excs)
     * }
     */
    public static MethodHandle PyUnstable_Exc_PrepReraiseStar$handle() {
        return PyUnstable_Exc_PrepReraiseStar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_Exc_PrepReraiseStar(PyObject *orig, PyObject *excs)
     * }
     */
    public static MemorySegment PyUnstable_Exc_PrepReraiseStar$address() {
        return PyUnstable_Exc_PrepReraiseStar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnstable_Exc_PrepReraiseStar(PyObject *orig, PyObject *excs)
     * }
     */
    public static MemorySegment PyUnstable_Exc_PrepReraiseStar(MemorySegment orig, MemorySegment excs) {
        var mh$ = PyUnstable_Exc_PrepReraiseStar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Exc_PrepReraiseStar", orig, excs);
            }
            return (MemorySegment)mh$.invokeExact(orig, excs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySignal_SetWakeupFd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySignal_SetWakeupFd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySignal_SetWakeupFd(int fd)
     * }
     */
    public static FunctionDescriptor PySignal_SetWakeupFd$descriptor() {
        return PySignal_SetWakeupFd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySignal_SetWakeupFd(int fd)
     * }
     */
    public static MethodHandle PySignal_SetWakeupFd$handle() {
        return PySignal_SetWakeupFd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySignal_SetWakeupFd(int fd)
     * }
     */
    public static MemorySegment PySignal_SetWakeupFd$address() {
        return PySignal_SetWakeupFd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySignal_SetWakeupFd(int fd)
     * }
     */
    public static int PySignal_SetWakeupFd(int fd) {
        var mh$ = PySignal_SetWakeupFd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySignal_SetWakeupFd", fd);
            }
            return (int)mh$.invokeExact(fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SyntaxLocationObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SyntaxLocationObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)
     * }
     */
    public static FunctionDescriptor PyErr_SyntaxLocationObject$descriptor() {
        return PyErr_SyntaxLocationObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)
     * }
     */
    public static MethodHandle PyErr_SyntaxLocationObject$handle() {
        return PyErr_SyntaxLocationObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)
     * }
     */
    public static MemorySegment PyErr_SyntaxLocationObject$address() {
        return PyErr_SyntaxLocationObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)
     * }
     */
    public static void PyErr_SyntaxLocationObject(MemorySegment filename, int lineno, int col_offset) {
        var mh$ = PyErr_SyntaxLocationObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SyntaxLocationObject", filename, lineno, col_offset);
            }
            mh$.invokeExact(filename, lineno, col_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_RangedSyntaxLocationObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_RangedSyntaxLocationObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_RangedSyntaxLocationObject(PyObject *filename, int lineno, int col_offset, int end_lineno, int end_col_offset)
     * }
     */
    public static FunctionDescriptor PyErr_RangedSyntaxLocationObject$descriptor() {
        return PyErr_RangedSyntaxLocationObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_RangedSyntaxLocationObject(PyObject *filename, int lineno, int col_offset, int end_lineno, int end_col_offset)
     * }
     */
    public static MethodHandle PyErr_RangedSyntaxLocationObject$handle() {
        return PyErr_RangedSyntaxLocationObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_RangedSyntaxLocationObject(PyObject *filename, int lineno, int col_offset, int end_lineno, int end_col_offset)
     * }
     */
    public static MemorySegment PyErr_RangedSyntaxLocationObject$address() {
        return PyErr_RangedSyntaxLocationObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_RangedSyntaxLocationObject(PyObject *filename, int lineno, int col_offset, int end_lineno, int end_col_offset)
     * }
     */
    public static void PyErr_RangedSyntaxLocationObject(MemorySegment filename, int lineno, int col_offset, int end_lineno, int end_col_offset) {
        var mh$ = PyErr_RangedSyntaxLocationObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_RangedSyntaxLocationObject", filename, lineno, col_offset, end_lineno, end_col_offset);
            }
            mh$.invokeExact(filename, lineno, col_offset, end_lineno, end_col_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_ProgramTextObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ProgramTextObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramTextObject(PyObject *filename, int lineno)
     * }
     */
    public static FunctionDescriptor PyErr_ProgramTextObject$descriptor() {
        return PyErr_ProgramTextObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramTextObject(PyObject *filename, int lineno)
     * }
     */
    public static MethodHandle PyErr_ProgramTextObject$handle() {
        return PyErr_ProgramTextObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramTextObject(PyObject *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramTextObject$address() {
        return PyErr_ProgramTextObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramTextObject(PyObject *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramTextObject(MemorySegment filename, int lineno) {
        var mh$ = PyErr_ProgramTextObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_ProgramTextObject", filename, lineno);
            }
            return (MemorySegment)mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_FatalErrorFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_FatalErrorFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_FatalErrorFunc(const char *func, const char *message)
     * }
     */
    public static FunctionDescriptor _Py_FatalErrorFunc$descriptor() {
        return _Py_FatalErrorFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_FatalErrorFunc(const char *func, const char *message)
     * }
     */
    public static MethodHandle _Py_FatalErrorFunc$handle() {
        return _Py_FatalErrorFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_FatalErrorFunc(const char *func, const char *message)
     * }
     */
    public static MemorySegment _Py_FatalErrorFunc$address() {
        return _Py_FatalErrorFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_FatalErrorFunc(const char *func, const char *message)
     * }
     */
    public static void _Py_FatalErrorFunc(MemorySegment func, MemorySegment message) {
        var mh$ = _Py_FatalErrorFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_FatalErrorFunc", func, message);
            }
            mh$.invokeExact(func, message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PyErr_FormatUnraisable(const char *, ...)
     * }
     */
    public static class PyErr_FormatUnraisable {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_FormatUnraisable");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_FormatUnraisable(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PyErr_FormatUnraisable(const char *, ...)
         * }
         */
        public static PyErr_FormatUnraisable makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_FormatUnraisable(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_FormatUnraisable", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyExc_PythonFinalizationError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_PythonFinalizationError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PythonFinalizationError
     * }
     */
    public static AddressLayout PyExc_PythonFinalizationError$layout() {
        return PyExc_PythonFinalizationError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PythonFinalizationError
     * }
     */
    public static MemorySegment PyExc_PythonFinalizationError$segment() {
        return PyExc_PythonFinalizationError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PythonFinalizationError
     * }
     */
    public static MemorySegment PyExc_PythonFinalizationError() {
        return PyExc_PythonFinalizationError$constants.SEGMENT.get(PyExc_PythonFinalizationError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PythonFinalizationError
     * }
     */
    public static void PyExc_PythonFinalizationError(MemorySegment varValue) {
        PyExc_PythonFinalizationError$constants.SEGMENT.set(PyExc_PythonFinalizationError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyLong_FromLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static FunctionDescriptor PyLong_FromLong$descriptor() {
        return PyLong_FromLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static MethodHandle PyLong_FromLong$handle() {
        return PyLong_FromLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static MemorySegment PyLong_FromLong$address() {
        return PyLong_FromLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static MemorySegment PyLong_FromLong(long x0) {
        var mh$ = PyLong_FromLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromUnsignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromUnsignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static FunctionDescriptor PyLong_FromUnsignedLong$descriptor() {
        return PyLong_FromUnsignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static MethodHandle PyLong_FromUnsignedLong$handle() {
        return PyLong_FromUnsignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLong$address() {
        return PyLong_FromUnsignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLong(long x0) {
        var mh$ = PyLong_FromUnsignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromUnsignedLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromSize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromSize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static FunctionDescriptor PyLong_FromSize_t$descriptor() {
        return PyLong_FromSize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static MethodHandle PyLong_FromSize_t$handle() {
        return PyLong_FromSize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static MemorySegment PyLong_FromSize_t$address() {
        return PyLong_FromSize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static MemorySegment PyLong_FromSize_t(long x0) {
        var mh$ = PyLong_FromSize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromSize_t", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromSsize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromSsize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyLong_FromSsize_t$descriptor() {
        return PyLong_FromSsize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static MethodHandle PyLong_FromSsize_t$handle() {
        return PyLong_FromSsize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static MemorySegment PyLong_FromSsize_t$address() {
        return PyLong_FromSsize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static MemorySegment PyLong_FromSsize_t(long x0) {
        var mh$ = PyLong_FromSsize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromSsize_t", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static FunctionDescriptor PyLong_FromDouble$descriptor() {
        return PyLong_FromDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static MethodHandle PyLong_FromDouble$handle() {
        return PyLong_FromDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static MemorySegment PyLong_FromDouble$address() {
        return PyLong_FromDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static MemorySegment PyLong_FromDouble(double x0) {
        var mh$ = PyLong_FromDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromDouble", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLong$descriptor() {
        return PyLong_AsLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsLong$handle() {
        return PyLong_AsLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsLong$address() {
        return PyLong_AsLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static long PyLong_AsLong(MemorySegment x0) {
        var mh$ = PyLong_AsLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLongAndOverflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLongAndOverflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLongAndOverflow$descriptor() {
        return PyLong_AsLongAndOverflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MethodHandle PyLong_AsLongAndOverflow$handle() {
        return PyLong_AsLongAndOverflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MemorySegment PyLong_AsLongAndOverflow$address() {
        return PyLong_AsLongAndOverflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static long PyLong_AsLongAndOverflow(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyLong_AsLongAndOverflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLongAndOverflow", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsSsize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsSsize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsSsize_t$descriptor() {
        return PyLong_AsSsize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsSsize_t$handle() {
        return PyLong_AsSsize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsSsize_t$address() {
        return PyLong_AsSsize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static long PyLong_AsSsize_t(MemorySegment x0) {
        var mh$ = PyLong_AsSsize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsSsize_t", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsSize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsSize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsSize_t$descriptor() {
        return PyLong_AsSize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsSize_t$handle() {
        return PyLong_AsSize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsSize_t$address() {
        return PyLong_AsSize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static long PyLong_AsSize_t(MemorySegment x0) {
        var mh$ = PyLong_AsSize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsSize_t", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLong$descriptor() {
        return PyLong_AsUnsignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLong$handle() {
        return PyLong_AsUnsignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLong$address() {
        return PyLong_AsUnsignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLong(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLongMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLongMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLongMask$descriptor() {
        return PyLong_AsUnsignedLongMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLongMask$handle() {
        return PyLong_AsUnsignedLongMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLongMask$address() {
        return PyLong_AsUnsignedLongMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLongMask(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLongMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLongMask", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyLong_AsInt(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsInt$descriptor() {
        return PyLong_AsInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyLong_AsInt(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsInt$handle() {
        return PyLong_AsInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyLong_AsInt(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsInt$address() {
        return PyLong_AsInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyLong_AsInt(PyObject *)
     * }
     */
    public static int PyLong_AsInt(MemorySegment x0) {
        var mh$ = PyLong_AsInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsInt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static FunctionDescriptor PyLong_GetInfo$descriptor() {
        return PyLong_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static MethodHandle PyLong_GetInfo$handle() {
        return PyLong_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static MemorySegment PyLong_GetInfo$address() {
        return PyLong_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static MemorySegment PyLong_GetInfo() {
        var mh$ = PyLong_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_GetInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsDouble$descriptor() {
        return PyLong_AsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsDouble$handle() {
        return PyLong_AsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsDouble$address() {
        return PyLong_AsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static double PyLong_AsDouble(MemorySegment x0) {
        var mh$ = PyLong_AsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsDouble", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromVoidPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromVoidPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static FunctionDescriptor PyLong_FromVoidPtr$descriptor() {
        return PyLong_FromVoidPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static MethodHandle PyLong_FromVoidPtr$handle() {
        return PyLong_FromVoidPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static MemorySegment PyLong_FromVoidPtr$address() {
        return PyLong_FromVoidPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static MemorySegment PyLong_FromVoidPtr(MemorySegment x0) {
        var mh$ = PyLong_FromVoidPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromVoidPtr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsVoidPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsVoidPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsVoidPtr$descriptor() {
        return PyLong_AsVoidPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsVoidPtr$handle() {
        return PyLong_AsVoidPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsVoidPtr$address() {
        return PyLong_AsVoidPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsVoidPtr(MemorySegment x0) {
        var mh$ = PyLong_AsVoidPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsVoidPtr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static FunctionDescriptor PyLong_FromLongLong$descriptor() {
        return PyLong_FromLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static MethodHandle PyLong_FromLongLong$handle() {
        return PyLong_FromLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static MemorySegment PyLong_FromLongLong$address() {
        return PyLong_FromLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static MemorySegment PyLong_FromLongLong(long x0) {
        var mh$ = PyLong_FromLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromLongLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromUnsignedLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromUnsignedLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static FunctionDescriptor PyLong_FromUnsignedLongLong$descriptor() {
        return PyLong_FromUnsignedLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static MethodHandle PyLong_FromUnsignedLongLong$handle() {
        return PyLong_FromUnsignedLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLongLong$address() {
        return PyLong_FromUnsignedLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLongLong(long x0) {
        var mh$ = PyLong_FromUnsignedLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromUnsignedLongLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLongLong$descriptor() {
        return PyLong_AsLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsLongLong$handle() {
        return PyLong_AsLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsLongLong$address() {
        return PyLong_AsLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static long PyLong_AsLongLong(MemorySegment x0) {
        var mh$ = PyLong_AsLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLongLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLongLong$descriptor() {
        return PyLong_AsUnsignedLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLongLong$handle() {
        return PyLong_AsUnsignedLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLongLong$address() {
        return PyLong_AsUnsignedLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLongLong(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLongLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLongLongMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLongLongMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLongLongMask$descriptor() {
        return PyLong_AsUnsignedLongLongMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLongLongMask$handle() {
        return PyLong_AsUnsignedLongLongMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLongLongMask$address() {
        return PyLong_AsUnsignedLongLongMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLongLongMask(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLongLongMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLongLongMask", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLongLongAndOverflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLongLongAndOverflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLongLongAndOverflow$descriptor() {
        return PyLong_AsLongLongAndOverflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MethodHandle PyLong_AsLongLongAndOverflow$handle() {
        return PyLong_AsLongLongAndOverflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MemorySegment PyLong_AsLongLongAndOverflow$address() {
        return PyLong_AsLongLongAndOverflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static long PyLong_AsLongLongAndOverflow(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyLong_AsLongLongAndOverflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLongLongAndOverflow", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static FunctionDescriptor PyLong_FromString$descriptor() {
        return PyLong_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static MethodHandle PyLong_FromString$handle() {
        return PyLong_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static MemorySegment PyLong_FromString$address() {
        return PyLong_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static MemorySegment PyLong_FromString(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyLong_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromString", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static FunctionDescriptor PyOS_strtoul$descriptor() {
        return PyOS_strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static MethodHandle PyOS_strtoul$handle() {
        return PyOS_strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static MemorySegment PyOS_strtoul$address() {
        return PyOS_strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static long PyOS_strtoul(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyOS_strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_strtoul", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static FunctionDescriptor PyOS_strtol$descriptor() {
        return PyOS_strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static MethodHandle PyOS_strtol$handle() {
        return PyOS_strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static MemorySegment PyOS_strtol$address() {
        return PyOS_strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static long PyOS_strtol(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyOS_strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_strtol", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromUnicodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromUnicodeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnicodeObject(PyObject *u, int base)
     * }
     */
    public static FunctionDescriptor PyLong_FromUnicodeObject$descriptor() {
        return PyLong_FromUnicodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnicodeObject(PyObject *u, int base)
     * }
     */
    public static MethodHandle PyLong_FromUnicodeObject$handle() {
        return PyLong_FromUnicodeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnicodeObject(PyObject *u, int base)
     * }
     */
    public static MemorySegment PyLong_FromUnicodeObject$address() {
        return PyLong_FromUnicodeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnicodeObject(PyObject *u, int base)
     * }
     */
    public static MemorySegment PyLong_FromUnicodeObject(MemorySegment u, int base) {
        var mh$ = PyLong_FromUnicodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromUnicodeObject", u, base);
            }
            return (MemorySegment)mh$.invokeExact(u, base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsNativeBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsNativeBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsNativeBytes(PyObject *v, void *buffer, Py_ssize_t n_bytes, int flags)
     * }
     */
    public static FunctionDescriptor PyLong_AsNativeBytes$descriptor() {
        return PyLong_AsNativeBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsNativeBytes(PyObject *v, void *buffer, Py_ssize_t n_bytes, int flags)
     * }
     */
    public static MethodHandle PyLong_AsNativeBytes$handle() {
        return PyLong_AsNativeBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsNativeBytes(PyObject *v, void *buffer, Py_ssize_t n_bytes, int flags)
     * }
     */
    public static MemorySegment PyLong_AsNativeBytes$address() {
        return PyLong_AsNativeBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsNativeBytes(PyObject *v, void *buffer, Py_ssize_t n_bytes, int flags)
     * }
     */
    public static long PyLong_AsNativeBytes(MemorySegment v, MemorySegment buffer, long n_bytes, int flags) {
        var mh$ = PyLong_AsNativeBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsNativeBytes", v, buffer, n_bytes, flags);
            }
            return (long)mh$.invokeExact(v, buffer, n_bytes, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromNativeBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromNativeBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromNativeBytes(const void *buffer, size_t n_bytes, int flags)
     * }
     */
    public static FunctionDescriptor PyLong_FromNativeBytes$descriptor() {
        return PyLong_FromNativeBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromNativeBytes(const void *buffer, size_t n_bytes, int flags)
     * }
     */
    public static MethodHandle PyLong_FromNativeBytes$handle() {
        return PyLong_FromNativeBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromNativeBytes(const void *buffer, size_t n_bytes, int flags)
     * }
     */
    public static MemorySegment PyLong_FromNativeBytes$address() {
        return PyLong_FromNativeBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromNativeBytes(const void *buffer, size_t n_bytes, int flags)
     * }
     */
    public static MemorySegment PyLong_FromNativeBytes(MemorySegment buffer, long n_bytes, int flags) {
        var mh$ = PyLong_FromNativeBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromNativeBytes", buffer, n_bytes, flags);
            }
            return (MemorySegment)mh$.invokeExact(buffer, n_bytes, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromUnsignedNativeBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromUnsignedNativeBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedNativeBytes(const void *buffer, size_t n_bytes, int flags)
     * }
     */
    public static FunctionDescriptor PyLong_FromUnsignedNativeBytes$descriptor() {
        return PyLong_FromUnsignedNativeBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedNativeBytes(const void *buffer, size_t n_bytes, int flags)
     * }
     */
    public static MethodHandle PyLong_FromUnsignedNativeBytes$handle() {
        return PyLong_FromUnsignedNativeBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedNativeBytes(const void *buffer, size_t n_bytes, int flags)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedNativeBytes$address() {
        return PyLong_FromUnsignedNativeBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedNativeBytes(const void *buffer, size_t n_bytes, int flags)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedNativeBytes(MemorySegment buffer, long n_bytes, int flags) {
        var mh$ = PyLong_FromUnsignedNativeBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromUnsignedNativeBytes", buffer, n_bytes, flags);
            }
            return (MemorySegment)mh$.invokeExact(buffer, n_bytes, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Long_IsCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Long_IsCompact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_Long_IsCompact(const PyLongObject *op)
     * }
     */
    public static FunctionDescriptor PyUnstable_Long_IsCompact$descriptor() {
        return PyUnstable_Long_IsCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_Long_IsCompact(const PyLongObject *op)
     * }
     */
    public static MethodHandle PyUnstable_Long_IsCompact$handle() {
        return PyUnstable_Long_IsCompact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_Long_IsCompact(const PyLongObject *op)
     * }
     */
    public static MemorySegment PyUnstable_Long_IsCompact$address() {
        return PyUnstable_Long_IsCompact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_Long_IsCompact(const PyLongObject *op)
     * }
     */
    public static int PyUnstable_Long_IsCompact(MemorySegment op) {
        var mh$ = PyUnstable_Long_IsCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Long_IsCompact", op);
            }
            return (int)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Long_CompactValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Long_CompactValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Long_CompactValue(const PyLongObject *op)
     * }
     */
    public static FunctionDescriptor PyUnstable_Long_CompactValue$descriptor() {
        return PyUnstable_Long_CompactValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Long_CompactValue(const PyLongObject *op)
     * }
     */
    public static MethodHandle PyUnstable_Long_CompactValue$handle() {
        return PyUnstable_Long_CompactValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Long_CompactValue(const PyLongObject *op)
     * }
     */
    public static MemorySegment PyUnstable_Long_CompactValue$address() {
        return PyUnstable_Long_CompactValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Long_CompactValue(const PyLongObject *op)
     * }
     */
    public static long PyUnstable_Long_CompactValue(MemorySegment op) {
        var mh$ = PyUnstable_Long_CompactValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Long_CompactValue", op);
            }
            return (long)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_Sign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_Sign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_Sign(PyObject *v)
     * }
     */
    public static FunctionDescriptor _PyLong_Sign$descriptor() {
        return _PyLong_Sign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_Sign(PyObject *v)
     * }
     */
    public static MethodHandle _PyLong_Sign$handle() {
        return _PyLong_Sign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_Sign(PyObject *v)
     * }
     */
    public static MemorySegment _PyLong_Sign$address() {
        return _PyLong_Sign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_Sign(PyObject *v)
     * }
     */
    public static int _PyLong_Sign(MemorySegment v) {
        var mh$ = _PyLong_Sign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_Sign", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_NumBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_NumBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _PyLong_NumBits(PyObject *v)
     * }
     */
    public static FunctionDescriptor _PyLong_NumBits$descriptor() {
        return _PyLong_NumBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _PyLong_NumBits(PyObject *v)
     * }
     */
    public static MethodHandle _PyLong_NumBits$handle() {
        return _PyLong_NumBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _PyLong_NumBits(PyObject *v)
     * }
     */
    public static MemorySegment _PyLong_NumBits$address() {
        return _PyLong_NumBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _PyLong_NumBits(PyObject *v)
     * }
     */
    public static long _PyLong_NumBits(MemorySegment v) {
        var mh$ = _PyLong_NumBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_NumBits", v);
            }
            return (long)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_FromByteArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_FromByteArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromByteArray(const unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static FunctionDescriptor _PyLong_FromByteArray$descriptor() {
        return _PyLong_FromByteArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromByteArray(const unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static MethodHandle _PyLong_FromByteArray$handle() {
        return _PyLong_FromByteArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromByteArray(const unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static MemorySegment _PyLong_FromByteArray$address() {
        return _PyLong_FromByteArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_FromByteArray(const unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static MemorySegment _PyLong_FromByteArray(MemorySegment bytes, long n, int little_endian, int is_signed) {
        var mh$ = _PyLong_FromByteArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_FromByteArray", bytes, n, little_endian, is_signed);
            }
            return (MemorySegment)mh$.invokeExact(bytes, n, little_endian, is_signed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_AsByteArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_AsByteArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_AsByteArray(PyLongObject *v, unsigned char *bytes, size_t n, int little_endian, int is_signed, int with_exceptions)
     * }
     */
    public static FunctionDescriptor _PyLong_AsByteArray$descriptor() {
        return _PyLong_AsByteArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_AsByteArray(PyLongObject *v, unsigned char *bytes, size_t n, int little_endian, int is_signed, int with_exceptions)
     * }
     */
    public static MethodHandle _PyLong_AsByteArray$handle() {
        return _PyLong_AsByteArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_AsByteArray(PyLongObject *v, unsigned char *bytes, size_t n, int little_endian, int is_signed, int with_exceptions)
     * }
     */
    public static MemorySegment _PyLong_AsByteArray$address() {
        return _PyLong_AsByteArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_AsByteArray(PyLongObject *v, unsigned char *bytes, size_t n, int little_endian, int is_signed, int with_exceptions)
     * }
     */
    public static int _PyLong_AsByteArray(MemorySegment v, MemorySegment bytes, long n, int little_endian, int is_signed, int with_exceptions) {
        var mh$ = _PyLong_AsByteArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_AsByteArray", v, bytes, n, little_endian, is_signed, with_exceptions);
            }
            return (int)mh$.invokeExact(v, bytes, n, little_endian, is_signed, with_exceptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_GCD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_GCD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_GCD(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyLong_GCD$descriptor() {
        return _PyLong_GCD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_GCD(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyLong_GCD$handle() {
        return _PyLong_GCD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_GCD(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyLong_GCD$address() {
        return _PyLong_GCD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_GCD(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyLong_GCD(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyLong_GCD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_GCD", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t digit
     * }
     */
    public static final OfInt digit = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t sdigit
     * }
     */
    public static final OfInt sdigit = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t twodigits
     * }
     */
    public static final OfLong twodigits = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t stwodigits
     * }
     */
    public static final OfLong stwodigits = Python_h.C_LONG_LONG;

    private static class _PyLong_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyLongObject *_PyLong_New(Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyLong_New$descriptor() {
        return _PyLong_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyLongObject *_PyLong_New(Py_ssize_t)
     * }
     */
    public static MethodHandle _PyLong_New$handle() {
        return _PyLong_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyLongObject *_PyLong_New(Py_ssize_t)
     * }
     */
    public static MemorySegment _PyLong_New$address() {
        return _PyLong_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyLongObject *_PyLong_New(Py_ssize_t)
     * }
     */
    public static MemorySegment _PyLong_New(long x0) {
        var mh$ = _PyLong_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Copy(PyLongObject *src)
     * }
     */
    public static FunctionDescriptor _PyLong_Copy$descriptor() {
        return _PyLong_Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Copy(PyLongObject *src)
     * }
     */
    public static MethodHandle _PyLong_Copy$handle() {
        return _PyLong_Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Copy(PyLongObject *src)
     * }
     */
    public static MemorySegment _PyLong_Copy$address() {
        return _PyLong_Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_Copy(PyLongObject *src)
     * }
     */
    public static MemorySegment _PyLong_Copy(MemorySegment src) {
        var mh$ = _PyLong_Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_Copy", src);
            }
            return (MemorySegment)mh$.invokeExact(src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_FromDigits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_FromDigits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyLongObject *_PyLong_FromDigits(int negative, Py_ssize_t digit_count, digit *digits)
     * }
     */
    public static FunctionDescriptor _PyLong_FromDigits$descriptor() {
        return _PyLong_FromDigits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyLongObject *_PyLong_FromDigits(int negative, Py_ssize_t digit_count, digit *digits)
     * }
     */
    public static MethodHandle _PyLong_FromDigits$handle() {
        return _PyLong_FromDigits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyLongObject *_PyLong_FromDigits(int negative, Py_ssize_t digit_count, digit *digits)
     * }
     */
    public static MemorySegment _PyLong_FromDigits$address() {
        return _PyLong_FromDigits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyLongObject *_PyLong_FromDigits(int negative, Py_ssize_t digit_count, digit *digits)
     * }
     */
    public static MemorySegment _PyLong_FromDigits(int negative, long digit_count, MemorySegment digits) {
        var mh$ = _PyLong_FromDigits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_FromDigits", negative, digit_count, digits);
            }
            return (MemorySegment)mh$.invokeExact(negative, digit_count, digits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_FalseStruct$constants {
        public static final GroupLayout LAYOUT = _longobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_FalseStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_FalseStruct
     * }
     */
    public static GroupLayout _Py_FalseStruct$layout() {
        return _Py_FalseStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_FalseStruct
     * }
     */
    public static MemorySegment _Py_FalseStruct() {
        return _Py_FalseStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_FalseStruct
     * }
     */
    public static void _Py_FalseStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_FalseStruct$constants.SEGMENT, 0L, _Py_FalseStruct$constants.LAYOUT.byteSize());
    }

    private static class _Py_TrueStruct$constants {
        public static final GroupLayout LAYOUT = _longobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_TrueStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_TrueStruct
     * }
     */
    public static GroupLayout _Py_TrueStruct$layout() {
        return _Py_TrueStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_TrueStruct
     * }
     */
    public static MemorySegment _Py_TrueStruct() {
        return _Py_TrueStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_TrueStruct
     * }
     */
    public static void _Py_TrueStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_TrueStruct$constants.SEGMENT, 0L, _Py_TrueStruct$constants.LAYOUT.byteSize());
    }

    private static class Py_IsTrue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsTrue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsTrue$descriptor() {
        return Py_IsTrue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsTrue$handle() {
        return Py_IsTrue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsTrue$address() {
        return Py_IsTrue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static int Py_IsTrue(MemorySegment x) {
        var mh$ = Py_IsTrue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsTrue", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IsFalse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsFalse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsFalse$descriptor() {
        return Py_IsFalse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsFalse$handle() {
        return Py_IsFalse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsFalse$address() {
        return Py_IsFalse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static int Py_IsFalse(MemorySegment x) {
        var mh$ = Py_IsFalse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsFalse", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBool_FromLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBool_FromLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static FunctionDescriptor PyBool_FromLong$descriptor() {
        return PyBool_FromLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static MethodHandle PyBool_FromLong$handle() {
        return PyBool_FromLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static MemorySegment PyBool_FromLong$address() {
        return PyBool_FromLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static MemorySegment PyBool_FromLong(long x0) {
        var mh$ = PyBool_FromLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBool_FromLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFloat_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFloat_Type
     * }
     */
    public static GroupLayout PyFloat_Type$layout() {
        return PyFloat_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFloat_Type
     * }
     */
    public static MemorySegment PyFloat_Type() {
        return PyFloat_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFloat_Type
     * }
     */
    public static void PyFloat_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFloat_Type$constants.SEGMENT, 0L, PyFloat_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFloat_GetMax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_GetMax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static FunctionDescriptor PyFloat_GetMax$descriptor() {
        return PyFloat_GetMax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static MethodHandle PyFloat_GetMax$handle() {
        return PyFloat_GetMax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static MemorySegment PyFloat_GetMax$address() {
        return PyFloat_GetMax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static double PyFloat_GetMax() {
        var mh$ = PyFloat_GetMax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_GetMax");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_GetMin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_GetMin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static FunctionDescriptor PyFloat_GetMin$descriptor() {
        return PyFloat_GetMin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static MethodHandle PyFloat_GetMin$handle() {
        return PyFloat_GetMin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static MemorySegment PyFloat_GetMin$address() {
        return PyFloat_GetMin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static double PyFloat_GetMin() {
        var mh$ = PyFloat_GetMin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_GetMin");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static FunctionDescriptor PyFloat_GetInfo$descriptor() {
        return PyFloat_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static MethodHandle PyFloat_GetInfo$handle() {
        return PyFloat_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static MemorySegment PyFloat_GetInfo$address() {
        return PyFloat_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static MemorySegment PyFloat_GetInfo() {
        var mh$ = PyFloat_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_GetInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFloat_FromString$descriptor() {
        return PyFloat_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static MethodHandle PyFloat_FromString$handle() {
        return PyFloat_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static MemorySegment PyFloat_FromString$address() {
        return PyFloat_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static MemorySegment PyFloat_FromString(MemorySegment x0) {
        var mh$ = PyFloat_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_FromString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_FromDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_FromDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static FunctionDescriptor PyFloat_FromDouble$descriptor() {
        return PyFloat_FromDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static MethodHandle PyFloat_FromDouble$handle() {
        return PyFloat_FromDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static MemorySegment PyFloat_FromDouble$address() {
        return PyFloat_FromDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static MemorySegment PyFloat_FromDouble(double x0) {
        var mh$ = PyFloat_FromDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_FromDouble", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_AsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_AsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFloat_AsDouble$descriptor() {
        return PyFloat_AsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static MethodHandle PyFloat_AsDouble$handle() {
        return PyFloat_AsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static MemorySegment PyFloat_AsDouble$address() {
        return PyFloat_AsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static double PyFloat_AsDouble(MemorySegment x0) {
        var mh$ = PyFloat_AsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_AsDouble", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Pack2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Pack2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFloat_Pack2(double x, char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Pack2$descriptor() {
        return PyFloat_Pack2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFloat_Pack2(double x, char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Pack2$handle() {
        return PyFloat_Pack2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFloat_Pack2(double x, char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Pack2$address() {
        return PyFloat_Pack2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFloat_Pack2(double x, char *p, int le)
     * }
     */
    public static int PyFloat_Pack2(double x, MemorySegment p, int le) {
        var mh$ = PyFloat_Pack2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Pack2", x, p, le);
            }
            return (int)mh$.invokeExact(x, p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Pack4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Pack4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFloat_Pack4(double x, char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Pack4$descriptor() {
        return PyFloat_Pack4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFloat_Pack4(double x, char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Pack4$handle() {
        return PyFloat_Pack4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFloat_Pack4(double x, char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Pack4$address() {
        return PyFloat_Pack4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFloat_Pack4(double x, char *p, int le)
     * }
     */
    public static int PyFloat_Pack4(double x, MemorySegment p, int le) {
        var mh$ = PyFloat_Pack4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Pack4", x, p, le);
            }
            return (int)mh$.invokeExact(x, p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Pack8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Pack8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFloat_Pack8(double x, char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Pack8$descriptor() {
        return PyFloat_Pack8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFloat_Pack8(double x, char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Pack8$handle() {
        return PyFloat_Pack8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFloat_Pack8(double x, char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Pack8$address() {
        return PyFloat_Pack8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFloat_Pack8(double x, char *p, int le)
     * }
     */
    public static int PyFloat_Pack8(double x, MemorySegment p, int le) {
        var mh$ = PyFloat_Pack8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Pack8", x, p, le);
            }
            return (int)mh$.invokeExact(x, p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Unpack2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Unpack2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_Unpack2(const char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Unpack2$descriptor() {
        return PyFloat_Unpack2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_Unpack2(const char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Unpack2$handle() {
        return PyFloat_Unpack2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_Unpack2(const char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Unpack2$address() {
        return PyFloat_Unpack2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_Unpack2(const char *p, int le)
     * }
     */
    public static double PyFloat_Unpack2(MemorySegment p, int le) {
        var mh$ = PyFloat_Unpack2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Unpack2", p, le);
            }
            return (double)mh$.invokeExact(p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Unpack4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Unpack4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_Unpack4(const char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Unpack4$descriptor() {
        return PyFloat_Unpack4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_Unpack4(const char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Unpack4$handle() {
        return PyFloat_Unpack4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_Unpack4(const char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Unpack4$address() {
        return PyFloat_Unpack4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_Unpack4(const char *p, int le)
     * }
     */
    public static double PyFloat_Unpack4(MemorySegment p, int le) {
        var mh$ = PyFloat_Unpack4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Unpack4", p, le);
            }
            return (double)mh$.invokeExact(p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Unpack8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Unpack8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_Unpack8(const char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Unpack8$descriptor() {
        return PyFloat_Unpack8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_Unpack8(const char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Unpack8$handle() {
        return PyFloat_Unpack8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_Unpack8(const char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Unpack8$address() {
        return PyFloat_Unpack8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_Unpack8(const char *p, int le)
     * }
     */
    public static double PyFloat_Unpack8(MemorySegment p, int le) {
        var mh$ = PyFloat_Unpack8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Unpack8", p, le);
            }
            return (double)mh$.invokeExact(p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyComplex_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyComplex_Type
     * }
     */
    public static GroupLayout PyComplex_Type$layout() {
        return PyComplex_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyComplex_Type
     * }
     */
    public static MemorySegment PyComplex_Type() {
        return PyComplex_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyComplex_Type
     * }
     */
    public static void PyComplex_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyComplex_Type$constants.SEGMENT, 0L, PyComplex_Type$constants.LAYOUT.byteSize());
    }

    private static class PyComplex_FromDoubles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_FromDoubles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static FunctionDescriptor PyComplex_FromDoubles$descriptor() {
        return PyComplex_FromDoubles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static MethodHandle PyComplex_FromDoubles$handle() {
        return PyComplex_FromDoubles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static MemorySegment PyComplex_FromDoubles$address() {
        return PyComplex_FromDoubles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static MemorySegment PyComplex_FromDoubles(double real, double imag) {
        var mh$ = PyComplex_FromDoubles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_FromDoubles", real, imag);
            }
            return (MemorySegment)mh$.invokeExact(real, imag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_RealAsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_RealAsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyComplex_RealAsDouble$descriptor() {
        return PyComplex_RealAsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static MethodHandle PyComplex_RealAsDouble$handle() {
        return PyComplex_RealAsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_RealAsDouble$address() {
        return PyComplex_RealAsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static double PyComplex_RealAsDouble(MemorySegment op) {
        var mh$ = PyComplex_RealAsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_RealAsDouble", op);
            }
            return (double)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_ImagAsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_ImagAsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyComplex_ImagAsDouble$descriptor() {
        return PyComplex_ImagAsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static MethodHandle PyComplex_ImagAsDouble$handle() {
        return PyComplex_ImagAsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_ImagAsDouble$address() {
        return PyComplex_ImagAsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static double PyComplex_ImagAsDouble(MemorySegment op) {
        var mh$ = PyComplex_ImagAsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_ImagAsDouble", op);
            }
            return (double)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_sum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_sum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_sum(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_sum$descriptor() {
        return _Py_c_sum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_sum(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_sum$handle() {
        return _Py_c_sum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_sum(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_sum$address() {
        return _Py_c_sum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_sum(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_sum(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_sum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_sum", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_diff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_diff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_diff(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_diff$descriptor() {
        return _Py_c_diff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_diff(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_diff$handle() {
        return _Py_c_diff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_diff(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_diff$address() {
        return _Py_c_diff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_diff(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_diff(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_diff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_diff", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_neg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_neg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_neg(Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_neg$descriptor() {
        return _Py_c_neg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_neg(Py_complex)
     * }
     */
    public static MethodHandle _Py_c_neg$handle() {
        return _Py_c_neg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_neg(Py_complex)
     * }
     */
    public static MemorySegment _Py_c_neg$address() {
        return _Py_c_neg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_neg(Py_complex)
     * }
     */
    public static MemorySegment _Py_c_neg(SegmentAllocator allocator, MemorySegment x0) {
        var mh$ = _Py_c_neg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_neg", allocator, x0);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_prod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_prod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_prod(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_prod$descriptor() {
        return _Py_c_prod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_prod(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_prod$handle() {
        return _Py_c_prod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_prod(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_prod$address() {
        return _Py_c_prod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_prod(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_prod(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_prod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_prod", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_quot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_quot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_quot(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_quot$descriptor() {
        return _Py_c_quot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_quot(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_quot$handle() {
        return _Py_c_quot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_quot(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_quot$address() {
        return _Py_c_quot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_quot(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_quot(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_quot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_quot", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_pow(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_pow$descriptor() {
        return _Py_c_pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_pow(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_pow$handle() {
        return _Py_c_pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_pow(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_pow$address() {
        return _Py_c_pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_pow(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_pow(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_pow", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _Py_c_abs(Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_abs$descriptor() {
        return _Py_c_abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _Py_c_abs(Py_complex)
     * }
     */
    public static MethodHandle _Py_c_abs$handle() {
        return _Py_c_abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _Py_c_abs(Py_complex)
     * }
     */
    public static MemorySegment _Py_c_abs$address() {
        return _Py_c_abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _Py_c_abs(Py_complex)
     * }
     */
    public static double _Py_c_abs(MemorySegment x0) {
        var mh$ = _Py_c_abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_abs", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_FromCComplex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_FromCComplex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromCComplex(Py_complex)
     * }
     */
    public static FunctionDescriptor PyComplex_FromCComplex$descriptor() {
        return PyComplex_FromCComplex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromCComplex(Py_complex)
     * }
     */
    public static MethodHandle PyComplex_FromCComplex$handle() {
        return PyComplex_FromCComplex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromCComplex(Py_complex)
     * }
     */
    public static MemorySegment PyComplex_FromCComplex$address() {
        return PyComplex_FromCComplex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyComplex_FromCComplex(Py_complex)
     * }
     */
    public static MemorySegment PyComplex_FromCComplex(MemorySegment x0) {
        var mh$ = PyComplex_FromCComplex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_FromCComplex", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_AsCComplex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_AsCComplex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex PyComplex_AsCComplex(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyComplex_AsCComplex$descriptor() {
        return PyComplex_AsCComplex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex PyComplex_AsCComplex(PyObject *op)
     * }
     */
    public static MethodHandle PyComplex_AsCComplex$handle() {
        return PyComplex_AsCComplex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex PyComplex_AsCComplex(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_AsCComplex$address() {
        return PyComplex_AsCComplex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex PyComplex_AsCComplex(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_AsCComplex(SegmentAllocator allocator, MemorySegment op) {
        var mh$ = PyComplex_AsCComplex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_AsCComplex", allocator, op);
            }
            return (MemorySegment)mh$.invokeExact(allocator, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRange_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyRange_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRange_Type
     * }
     */
    public static GroupLayout PyRange_Type$layout() {
        return PyRange_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRange_Type
     * }
     */
    public static MemorySegment PyRange_Type() {
        return PyRange_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRange_Type
     * }
     */
    public static void PyRange_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyRange_Type$constants.SEGMENT, 0L, PyRange_Type$constants.LAYOUT.byteSize());
    }

    private static class PyRangeIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyRangeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRangeIter_Type
     * }
     */
    public static GroupLayout PyRangeIter_Type$layout() {
        return PyRangeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRangeIter_Type
     * }
     */
    public static MemorySegment PyRangeIter_Type() {
        return PyRangeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRangeIter_Type
     * }
     */
    public static void PyRangeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyRangeIter_Type$constants.SEGMENT, 0L, PyRangeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyLongRangeIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyLongRangeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLongRangeIter_Type
     * }
     */
    public static GroupLayout PyLongRangeIter_Type$layout() {
        return PyLongRangeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLongRangeIter_Type
     * }
     */
    public static MemorySegment PyLongRangeIter_Type() {
        return PyLongRangeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLongRangeIter_Type
     * }
     */
    public static void PyLongRangeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyLongRangeIter_Type$constants.SEGMENT, 0L, PyLongRangeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMemoryView_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMemoryView_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemoryView_Type
     * }
     */
    public static GroupLayout PyMemoryView_Type$layout() {
        return PyMemoryView_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemoryView_Type
     * }
     */
    public static MemorySegment PyMemoryView_Type() {
        return PyMemoryView_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemoryView_Type
     * }
     */
    public static void PyMemoryView_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMemoryView_Type$constants.SEGMENT, 0L, PyMemoryView_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMemoryView_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static FunctionDescriptor PyMemoryView_FromObject$descriptor() {
        return PyMemoryView_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static MethodHandle PyMemoryView_FromObject$handle() {
        return PyMemoryView_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static MemorySegment PyMemoryView_FromObject$address() {
        return PyMemoryView_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static MemorySegment PyMemoryView_FromObject(MemorySegment base) {
        var mh$ = PyMemoryView_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_FromObject", base);
            }
            return (MemorySegment)mh$.invokeExact(base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMemoryView_FromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_FromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static FunctionDescriptor PyMemoryView_FromMemory$descriptor() {
        return PyMemoryView_FromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static MethodHandle PyMemoryView_FromMemory$handle() {
        return PyMemoryView_FromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static MemorySegment PyMemoryView_FromMemory$address() {
        return PyMemoryView_FromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static MemorySegment PyMemoryView_FromMemory(MemorySegment mem, long size, int flags) {
        var mh$ = PyMemoryView_FromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_FromMemory", mem, size, flags);
            }
            return (MemorySegment)mh$.invokeExact(mem, size, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMemoryView_FromBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_FromBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static FunctionDescriptor PyMemoryView_FromBuffer$descriptor() {
        return PyMemoryView_FromBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static MethodHandle PyMemoryView_FromBuffer$handle() {
        return PyMemoryView_FromBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static MemorySegment PyMemoryView_FromBuffer$address() {
        return PyMemoryView_FromBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static MemorySegment PyMemoryView_FromBuffer(MemorySegment info) {
        var mh$ = PyMemoryView_FromBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_FromBuffer", info);
            }
            return (MemorySegment)mh$.invokeExact(info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMemoryView_GetContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_GetContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static FunctionDescriptor PyMemoryView_GetContiguous$descriptor() {
        return PyMemoryView_GetContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static MethodHandle PyMemoryView_GetContiguous$handle() {
        return PyMemoryView_GetContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static MemorySegment PyMemoryView_GetContiguous$address() {
        return PyMemoryView_GetContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static MemorySegment PyMemoryView_GetContiguous(MemorySegment base, int buffertype, byte order) {
        var mh$ = PyMemoryView_GetContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_GetContiguous", base, buffertype, order);
            }
            return (MemorySegment)mh$.invokeExact(base, buffertype, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyTuple_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTuple_Type
     * }
     */
    public static GroupLayout PyTuple_Type$layout() {
        return PyTuple_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTuple_Type
     * }
     */
    public static MemorySegment PyTuple_Type() {
        return PyTuple_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTuple_Type
     * }
     */
    public static void PyTuple_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyTuple_Type$constants.SEGMENT, 0L, PyTuple_Type$constants.LAYOUT.byteSize());
    }

    private static class PyTupleIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyTupleIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTupleIter_Type
     * }
     */
    public static GroupLayout PyTupleIter_Type$layout() {
        return PyTupleIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTupleIter_Type
     * }
     */
    public static MemorySegment PyTupleIter_Type() {
        return PyTupleIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTupleIter_Type
     * }
     */
    public static void PyTupleIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyTupleIter_Type$constants.SEGMENT, 0L, PyTupleIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyTuple_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyTuple_New$descriptor() {
        return PyTuple_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static MethodHandle PyTuple_New$handle() {
        return PyTuple_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyTuple_New$address() {
        return PyTuple_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyTuple_New(long size) {
        var mh$ = PyTuple_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_New", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyTuple_Size$descriptor() {
        return PyTuple_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static MethodHandle PyTuple_Size$handle() {
        return PyTuple_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static MemorySegment PyTuple_Size$address() {
        return PyTuple_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static long PyTuple_Size(MemorySegment x0) {
        var mh$ = PyTuple_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyTuple_GetItem$descriptor() {
        return PyTuple_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyTuple_GetItem$handle() {
        return PyTuple_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetItem$address() {
        return PyTuple_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetItem(MemorySegment x0, long x1) {
        var mh$ = PyTuple_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_GetItem", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyTuple_SetItem$descriptor() {
        return PyTuple_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyTuple_SetItem$handle() {
        return PyTuple_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyTuple_SetItem$address() {
        return PyTuple_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyTuple_SetItem(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyTuple_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_SetItem", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_GetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_GetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyTuple_GetSlice$descriptor() {
        return PyTuple_GetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MethodHandle PyTuple_GetSlice$handle() {
        return PyTuple_GetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetSlice$address() {
        return PyTuple_GetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetSlice(MemorySegment x0, long x1, long x2) {
        var mh$ = PyTuple_GetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_GetSlice", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyTuple_Pack(Py_ssize_t, ...)
     * }
     */
    public static class PyTuple_Pack {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_LONG
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_Pack");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyTuple_Pack(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyTuple_Pack(Py_ssize_t, ...)
         * }
         */
        public static PyTuple_Pack makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyTuple_Pack(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(long x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyTuple_Pack", x0, x1);
                }
                return (MemorySegment) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _PyTuple_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTuple_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTuple_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyTuple_Resize$descriptor() {
        return _PyTuple_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTuple_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyTuple_Resize$handle() {
        return _PyTuple_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTuple_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyTuple_Resize$address() {
        return _PyTuple_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTuple_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static int _PyTuple_Resize(MemorySegment x0, long x1) {
        var mh$ = _PyTuple_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTuple_Resize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyList_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyList_Type
     * }
     */
    public static GroupLayout PyList_Type$layout() {
        return PyList_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyList_Type
     * }
     */
    public static MemorySegment PyList_Type() {
        return PyList_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyList_Type
     * }
     */
    public static void PyList_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyList_Type$constants.SEGMENT, 0L, PyList_Type$constants.LAYOUT.byteSize());
    }

    private static class PyListIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyListIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListIter_Type
     * }
     */
    public static GroupLayout PyListIter_Type$layout() {
        return PyListIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListIter_Type
     * }
     */
    public static MemorySegment PyListIter_Type() {
        return PyListIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListIter_Type
     * }
     */
    public static void PyListIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyListIter_Type$constants.SEGMENT, 0L, PyListIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyListRevIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyListRevIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListRevIter_Type
     * }
     */
    public static GroupLayout PyListRevIter_Type$layout() {
        return PyListRevIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListRevIter_Type
     * }
     */
    public static MemorySegment PyListRevIter_Type() {
        return PyListRevIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListRevIter_Type
     * }
     */
    public static void PyListRevIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyListRevIter_Type$constants.SEGMENT, 0L, PyListRevIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyList_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyList_New$descriptor() {
        return PyList_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static MethodHandle PyList_New$handle() {
        return PyList_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyList_New$address() {
        return PyList_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyList_New(long size) {
        var mh$ = PyList_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_New", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Size$descriptor() {
        return PyList_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static MethodHandle PyList_Size$handle() {
        return PyList_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static MemorySegment PyList_Size$address() {
        return PyList_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static long PyList_Size(MemorySegment x0) {
        var mh$ = PyList_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyList_GetItem$descriptor() {
        return PyList_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyList_GetItem$handle() {
        return PyList_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetItem$address() {
        return PyList_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetItem(MemorySegment x0, long x1) {
        var mh$ = PyList_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_GetItem", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_GetItemRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_GetItemRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItemRef(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyList_GetItemRef$descriptor() {
        return PyList_GetItemRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItemRef(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyList_GetItemRef$handle() {
        return PyList_GetItemRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItemRef(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetItemRef$address() {
        return PyList_GetItemRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_GetItemRef(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetItemRef(MemorySegment x0, long x1) {
        var mh$ = PyList_GetItemRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_GetItemRef", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_SetItem$descriptor() {
        return PyList_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyList_SetItem$handle() {
        return PyList_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyList_SetItem$address() {
        return PyList_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyList_SetItem(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyList_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_SetItem", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Insert$descriptor() {
        return PyList_Insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyList_Insert$handle() {
        return PyList_Insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyList_Insert$address() {
        return PyList_Insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyList_Insert(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyList_Insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Insert", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Append$descriptor() {
        return PyList_Append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyList_Append$handle() {
        return PyList_Append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyList_Append$address() {
        return PyList_Append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static int PyList_Append(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyList_Append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Append", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_GetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_GetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyList_GetSlice$descriptor() {
        return PyList_GetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MethodHandle PyList_GetSlice$handle() {
        return PyList_GetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetSlice$address() {
        return PyList_GetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetSlice(MemorySegment x0, long x1, long x2) {
        var mh$ = PyList_GetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_GetSlice", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_SetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_SetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_SetSlice$descriptor() {
        return PyList_SetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyList_SetSlice$handle() {
        return PyList_SetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyList_SetSlice$address() {
        return PyList_SetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyList_SetSlice(MemorySegment x0, long x1, long x2, MemorySegment x3) {
        var mh$ = PyList_SetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_SetSlice", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Sort$descriptor() {
        return PyList_Sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static MethodHandle PyList_Sort$handle() {
        return PyList_Sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static MemorySegment PyList_Sort$address() {
        return PyList_Sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static int PyList_Sort(MemorySegment x0) {
        var mh$ = PyList_Sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Sort", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Reverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Reverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Reverse$descriptor() {
        return PyList_Reverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static MethodHandle PyList_Reverse$handle() {
        return PyList_Reverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static MemorySegment PyList_Reverse$address() {
        return PyList_Reverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static int PyList_Reverse(MemorySegment x0) {
        var mh$ = PyList_Reverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Reverse", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_AsTuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_AsTuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_AsTuple$descriptor() {
        return PyList_AsTuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static MethodHandle PyList_AsTuple$handle() {
        return PyList_AsTuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static MemorySegment PyList_AsTuple$address() {
        return PyList_AsTuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static MemorySegment PyList_AsTuple(MemorySegment x0) {
        var mh$ = PyList_AsTuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_AsTuple", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Extend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Extend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Extend(PyObject *self, PyObject *iterable)
     * }
     */
    public static FunctionDescriptor PyList_Extend$descriptor() {
        return PyList_Extend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Extend(PyObject *self, PyObject *iterable)
     * }
     */
    public static MethodHandle PyList_Extend$handle() {
        return PyList_Extend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Extend(PyObject *self, PyObject *iterable)
     * }
     */
    public static MemorySegment PyList_Extend$address() {
        return PyList_Extend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Extend(PyObject *self, PyObject *iterable)
     * }
     */
    public static int PyList_Extend(MemorySegment self, MemorySegment iterable) {
        var mh$ = PyList_Extend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Extend", self, iterable);
            }
            return (int)mh$.invokeExact(self, iterable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Clear(PyObject *self)
     * }
     */
    public static FunctionDescriptor PyList_Clear$descriptor() {
        return PyList_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Clear(PyObject *self)
     * }
     */
    public static MethodHandle PyList_Clear$handle() {
        return PyList_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Clear(PyObject *self)
     * }
     */
    public static MemorySegment PyList_Clear$address() {
        return PyList_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Clear(PyObject *self)
     * }
     */
    public static int PyList_Clear(MemorySegment self) {
        var mh$ = PyList_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Clear", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDict_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDict_Type
     * }
     */
    public static GroupLayout PyDict_Type$layout() {
        return PyDict_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDict_Type
     * }
     */
    public static MemorySegment PyDict_Type() {
        return PyDict_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDict_Type
     * }
     */
    public static void PyDict_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDict_Type$constants.SEGMENT, 0L, PyDict_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDict_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static FunctionDescriptor PyDict_New$descriptor() {
        return PyDict_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static MethodHandle PyDict_New$handle() {
        return PyDict_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static MemorySegment PyDict_New$address() {
        return PyDict_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static MemorySegment PyDict_New() {
        var mh$ = PyDict_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_GetItem$descriptor() {
        return PyDict_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_GetItem$handle() {
        return PyDict_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItem$address() {
        return PyDict_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItem(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItem", mp, key);
            }
            return (MemorySegment)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItemWithError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItemWithError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_GetItemWithError$descriptor() {
        return PyDict_GetItemWithError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_GetItemWithError$handle() {
        return PyDict_GetItemWithError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItemWithError$address() {
        return PyDict_GetItemWithError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItemWithError(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_GetItemWithError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItemWithError", mp, key);
            }
            return (MemorySegment)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static FunctionDescriptor PyDict_SetItem$descriptor() {
        return PyDict_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static MethodHandle PyDict_SetItem$handle() {
        return PyDict_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static MemorySegment PyDict_SetItem$address() {
        return PyDict_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static int PyDict_SetItem(MemorySegment mp, MemorySegment key, MemorySegment item) {
        var mh$ = PyDict_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_SetItem", mp, key, item);
            }
            return (int)mh$.invokeExact(mp, key, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_DelItem$descriptor() {
        return PyDict_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_DelItem$handle() {
        return PyDict_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_DelItem$address() {
        return PyDict_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static int PyDict_DelItem(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_DelItem", mp, key);
            }
            return (int)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Clear$descriptor() {
        return PyDict_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Clear$handle() {
        return PyDict_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Clear$address() {
        return PyDict_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static void PyDict_Clear(MemorySegment mp) {
        var mh$ = PyDict_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Clear", mp);
            }
            mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static FunctionDescriptor PyDict_Next$descriptor() {
        return PyDict_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static MethodHandle PyDict_Next$handle() {
        return PyDict_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static MemorySegment PyDict_Next$address() {
        return PyDict_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static int PyDict_Next(MemorySegment mp, MemorySegment pos, MemorySegment key, MemorySegment value) {
        var mh$ = PyDict_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Next", mp, pos, key, value);
            }
            return (int)mh$.invokeExact(mp, pos, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Keys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Keys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Keys$descriptor() {
        return PyDict_Keys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Keys$handle() {
        return PyDict_Keys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Keys$address() {
        return PyDict_Keys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Keys(MemorySegment mp) {
        var mh$ = PyDict_Keys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Keys", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Values$descriptor() {
        return PyDict_Values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Values$handle() {
        return PyDict_Values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Values$address() {
        return PyDict_Values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Values(MemorySegment mp) {
        var mh$ = PyDict_Values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Values", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Items$descriptor() {
        return PyDict_Items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Items$handle() {
        return PyDict_Items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Items$address() {
        return PyDict_Items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Items(MemorySegment mp) {
        var mh$ = PyDict_Items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Items", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Size$descriptor() {
        return PyDict_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Size$handle() {
        return PyDict_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Size$address() {
        return PyDict_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static long PyDict_Size(MemorySegment mp) {
        var mh$ = PyDict_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Size", mp);
            }
            return (long)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Copy$descriptor() {
        return PyDict_Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Copy$handle() {
        return PyDict_Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Copy$address() {
        return PyDict_Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Copy(MemorySegment mp) {
        var mh$ = PyDict_Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Copy", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_Contains$descriptor() {
        return PyDict_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_Contains$handle() {
        return PyDict_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_Contains$address() {
        return PyDict_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static int PyDict_Contains(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Contains", mp, key);
            }
            return (int)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static FunctionDescriptor PyDict_Update$descriptor() {
        return PyDict_Update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static MethodHandle PyDict_Update$handle() {
        return PyDict_Update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static MemorySegment PyDict_Update$address() {
        return PyDict_Update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static int PyDict_Update(MemorySegment mp, MemorySegment other) {
        var mh$ = PyDict_Update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Update", mp, other);
            }
            return (int)mh$.invokeExact(mp, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Merge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Merge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static FunctionDescriptor PyDict_Merge$descriptor() {
        return PyDict_Merge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static MethodHandle PyDict_Merge$handle() {
        return PyDict_Merge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static MemorySegment PyDict_Merge$address() {
        return PyDict_Merge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static int PyDict_Merge(MemorySegment mp, MemorySegment other, int override) {
        var mh$ = PyDict_Merge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Merge", mp, other, override);
            }
            return (int)mh$.invokeExact(mp, other, override);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_MergeFromSeq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_MergeFromSeq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static FunctionDescriptor PyDict_MergeFromSeq2$descriptor() {
        return PyDict_MergeFromSeq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static MethodHandle PyDict_MergeFromSeq2$handle() {
        return PyDict_MergeFromSeq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static MemorySegment PyDict_MergeFromSeq2$address() {
        return PyDict_MergeFromSeq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static int PyDict_MergeFromSeq2(MemorySegment d, MemorySegment seq2, int override) {
        var mh$ = PyDict_MergeFromSeq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_MergeFromSeq2", d, seq2, override);
            }
            return (int)mh$.invokeExact(d, seq2, override);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static FunctionDescriptor PyDict_GetItemString$descriptor() {
        return PyDict_GetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static MethodHandle PyDict_GetItemString$handle() {
        return PyDict_GetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static MemorySegment PyDict_GetItemString$address() {
        return PyDict_GetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static MemorySegment PyDict_GetItemString(MemorySegment dp, MemorySegment key) {
        var mh$ = PyDict_GetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItemString", dp, key);
            }
            return (MemorySegment)mh$.invokeExact(dp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_SetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_SetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static FunctionDescriptor PyDict_SetItemString$descriptor() {
        return PyDict_SetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static MethodHandle PyDict_SetItemString$handle() {
        return PyDict_SetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static MemorySegment PyDict_SetItemString$address() {
        return PyDict_SetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static int PyDict_SetItemString(MemorySegment dp, MemorySegment key, MemorySegment item) {
        var mh$ = PyDict_SetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_SetItemString", dp, key, item);
            }
            return (int)mh$.invokeExact(dp, key, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_DelItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_DelItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static FunctionDescriptor PyDict_DelItemString$descriptor() {
        return PyDict_DelItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static MethodHandle PyDict_DelItemString$handle() {
        return PyDict_DelItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static MemorySegment PyDict_DelItemString$address() {
        return PyDict_DelItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static int PyDict_DelItemString(MemorySegment dp, MemorySegment key) {
        var mh$ = PyDict_DelItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_DelItemString", dp, key);
            }
            return (int)mh$.invokeExact(dp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItemRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItemRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_GetItemRef(PyObject *mp, PyObject *key, PyObject **result)
     * }
     */
    public static FunctionDescriptor PyDict_GetItemRef$descriptor() {
        return PyDict_GetItemRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_GetItemRef(PyObject *mp, PyObject *key, PyObject **result)
     * }
     */
    public static MethodHandle PyDict_GetItemRef$handle() {
        return PyDict_GetItemRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_GetItemRef(PyObject *mp, PyObject *key, PyObject **result)
     * }
     */
    public static MemorySegment PyDict_GetItemRef$address() {
        return PyDict_GetItemRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_GetItemRef(PyObject *mp, PyObject *key, PyObject **result)
     * }
     */
    public static int PyDict_GetItemRef(MemorySegment mp, MemorySegment key, MemorySegment result) {
        var mh$ = PyDict_GetItemRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItemRef", mp, key, result);
            }
            return (int)mh$.invokeExact(mp, key, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItemStringRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItemStringRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_GetItemStringRef(PyObject *mp, const char *key, PyObject **result)
     * }
     */
    public static FunctionDescriptor PyDict_GetItemStringRef$descriptor() {
        return PyDict_GetItemStringRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_GetItemStringRef(PyObject *mp, const char *key, PyObject **result)
     * }
     */
    public static MethodHandle PyDict_GetItemStringRef$handle() {
        return PyDict_GetItemStringRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_GetItemStringRef(PyObject *mp, const char *key, PyObject **result)
     * }
     */
    public static MemorySegment PyDict_GetItemStringRef$address() {
        return PyDict_GetItemStringRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_GetItemStringRef(PyObject *mp, const char *key, PyObject **result)
     * }
     */
    public static int PyDict_GetItemStringRef(MemorySegment mp, MemorySegment key, MemorySegment result) {
        var mh$ = PyDict_GetItemStringRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItemStringRef", mp, key, result);
            }
            return (int)mh$.invokeExact(mp, key, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericGetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericGetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericGetDict$descriptor() {
        return PyObject_GenericGetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static MethodHandle PyObject_GenericGetDict$handle() {
        return PyObject_GenericGetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericGetDict$address() {
        return PyObject_GenericGetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericGetDict(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GenericGetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericGetDict", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDictKeys_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictKeys_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictKeys_Type
     * }
     */
    public static GroupLayout PyDictKeys_Type$layout() {
        return PyDictKeys_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictKeys_Type
     * }
     */
    public static MemorySegment PyDictKeys_Type() {
        return PyDictKeys_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictKeys_Type
     * }
     */
    public static void PyDictKeys_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictKeys_Type$constants.SEGMENT, 0L, PyDictKeys_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictValues_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictValues_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictValues_Type
     * }
     */
    public static GroupLayout PyDictValues_Type$layout() {
        return PyDictValues_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictValues_Type
     * }
     */
    public static MemorySegment PyDictValues_Type() {
        return PyDictValues_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictValues_Type
     * }
     */
    public static void PyDictValues_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictValues_Type$constants.SEGMENT, 0L, PyDictValues_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictItems_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictItems_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictItems_Type
     * }
     */
    public static GroupLayout PyDictItems_Type$layout() {
        return PyDictItems_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictItems_Type
     * }
     */
    public static MemorySegment PyDictItems_Type() {
        return PyDictItems_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictItems_Type
     * }
     */
    public static void PyDictItems_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictItems_Type$constants.SEGMENT, 0L, PyDictItems_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictIterKey_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictIterKey_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterKey_Type
     * }
     */
    public static GroupLayout PyDictIterKey_Type$layout() {
        return PyDictIterKey_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterKey_Type
     * }
     */
    public static MemorySegment PyDictIterKey_Type() {
        return PyDictIterKey_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterKey_Type
     * }
     */
    public static void PyDictIterKey_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictIterKey_Type$constants.SEGMENT, 0L, PyDictIterKey_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictIterValue_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictIterValue_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterValue_Type
     * }
     */
    public static GroupLayout PyDictIterValue_Type$layout() {
        return PyDictIterValue_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterValue_Type
     * }
     */
    public static MemorySegment PyDictIterValue_Type() {
        return PyDictIterValue_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterValue_Type
     * }
     */
    public static void PyDictIterValue_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictIterValue_Type$constants.SEGMENT, 0L, PyDictIterValue_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictIterItem_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictIterItem_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterItem_Type
     * }
     */
    public static GroupLayout PyDictIterItem_Type$layout() {
        return PyDictIterItem_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterItem_Type
     * }
     */
    public static MemorySegment PyDictIterItem_Type() {
        return PyDictIterItem_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterItem_Type
     * }
     */
    public static void PyDictIterItem_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictIterItem_Type$constants.SEGMENT, 0L, PyDictIterItem_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictRevIterKey_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictRevIterKey_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterKey_Type
     * }
     */
    public static GroupLayout PyDictRevIterKey_Type$layout() {
        return PyDictRevIterKey_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterKey_Type
     * }
     */
    public static MemorySegment PyDictRevIterKey_Type() {
        return PyDictRevIterKey_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterKey_Type
     * }
     */
    public static void PyDictRevIterKey_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictRevIterKey_Type$constants.SEGMENT, 0L, PyDictRevIterKey_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictRevIterItem_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictRevIterItem_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterItem_Type
     * }
     */
    public static GroupLayout PyDictRevIterItem_Type$layout() {
        return PyDictRevIterItem_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterItem_Type
     * }
     */
    public static MemorySegment PyDictRevIterItem_Type() {
        return PyDictRevIterItem_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterItem_Type
     * }
     */
    public static void PyDictRevIterItem_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictRevIterItem_Type$constants.SEGMENT, 0L, PyDictRevIterItem_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictRevIterValue_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictRevIterValue_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterValue_Type
     * }
     */
    public static GroupLayout PyDictRevIterValue_Type$layout() {
        return PyDictRevIterValue_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterValue_Type
     * }
     */
    public static MemorySegment PyDictRevIterValue_Type() {
        return PyDictRevIterValue_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterValue_Type
     * }
     */
    public static void PyDictRevIterValue_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictRevIterValue_Type$constants.SEGMENT, 0L, PyDictRevIterValue_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyDict_GetItem_KnownHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_GetItem_KnownHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static FunctionDescriptor _PyDict_GetItem_KnownHash$descriptor() {
        return _PyDict_GetItem_KnownHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static MethodHandle _PyDict_GetItem_KnownHash$handle() {
        return _PyDict_GetItem_KnownHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static MemorySegment _PyDict_GetItem_KnownHash$address() {
        return _PyDict_GetItem_KnownHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static MemorySegment _PyDict_GetItem_KnownHash(MemorySegment mp, MemorySegment key, long hash) {
        var mh$ = _PyDict_GetItem_KnownHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_GetItem_KnownHash", mp, key, hash);
            }
            return (MemorySegment)mh$.invokeExact(mp, key, hash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_GetItemStringWithError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_GetItemStringWithError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemStringWithError(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor _PyDict_GetItemStringWithError$descriptor() {
        return _PyDict_GetItemStringWithError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemStringWithError(PyObject *, const char *)
     * }
     */
    public static MethodHandle _PyDict_GetItemStringWithError$handle() {
        return _PyDict_GetItemStringWithError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemStringWithError(PyObject *, const char *)
     * }
     */
    public static MemorySegment _PyDict_GetItemStringWithError$address() {
        return _PyDict_GetItemStringWithError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemStringWithError(PyObject *, const char *)
     * }
     */
    public static MemorySegment _PyDict_GetItemStringWithError(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyDict_GetItemStringWithError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_GetItemStringWithError", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_SetDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_SetDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_SetDefault(PyObject *mp, PyObject *key, PyObject *defaultobj)
     * }
     */
    public static FunctionDescriptor PyDict_SetDefault$descriptor() {
        return PyDict_SetDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_SetDefault(PyObject *mp, PyObject *key, PyObject *defaultobj)
     * }
     */
    public static MethodHandle PyDict_SetDefault$handle() {
        return PyDict_SetDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_SetDefault(PyObject *mp, PyObject *key, PyObject *defaultobj)
     * }
     */
    public static MemorySegment PyDict_SetDefault$address() {
        return PyDict_SetDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_SetDefault(PyObject *mp, PyObject *key, PyObject *defaultobj)
     * }
     */
    public static MemorySegment PyDict_SetDefault(MemorySegment mp, MemorySegment key, MemorySegment defaultobj) {
        var mh$ = PyDict_SetDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_SetDefault", mp, key, defaultobj);
            }
            return (MemorySegment)mh$.invokeExact(mp, key, defaultobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_SetDefaultRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_SetDefaultRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_SetDefaultRef(PyObject *mp, PyObject *key, PyObject *default_value, PyObject **result)
     * }
     */
    public static FunctionDescriptor PyDict_SetDefaultRef$descriptor() {
        return PyDict_SetDefaultRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_SetDefaultRef(PyObject *mp, PyObject *key, PyObject *default_value, PyObject **result)
     * }
     */
    public static MethodHandle PyDict_SetDefaultRef$handle() {
        return PyDict_SetDefaultRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_SetDefaultRef(PyObject *mp, PyObject *key, PyObject *default_value, PyObject **result)
     * }
     */
    public static MemorySegment PyDict_SetDefaultRef$address() {
        return PyDict_SetDefaultRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_SetDefaultRef(PyObject *mp, PyObject *key, PyObject *default_value, PyObject **result)
     * }
     */
    public static int PyDict_SetDefaultRef(MemorySegment mp, MemorySegment key, MemorySegment default_value, MemorySegment result) {
        var mh$ = PyDict_SetDefaultRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_SetDefaultRef", mp, key, default_value, result);
            }
            return (int)mh$.invokeExact(mp, key, default_value, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_ContainsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_ContainsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_ContainsString(PyObject *mp, const char *key)
     * }
     */
    public static FunctionDescriptor PyDict_ContainsString$descriptor() {
        return PyDict_ContainsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_ContainsString(PyObject *mp, const char *key)
     * }
     */
    public static MethodHandle PyDict_ContainsString$handle() {
        return PyDict_ContainsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_ContainsString(PyObject *mp, const char *key)
     * }
     */
    public static MemorySegment PyDict_ContainsString$address() {
        return PyDict_ContainsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_ContainsString(PyObject *mp, const char *key)
     * }
     */
    public static int PyDict_ContainsString(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_ContainsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_ContainsString", mp, key);
            }
            return (int)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_NewPresized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_NewPresized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_NewPresized(Py_ssize_t minused)
     * }
     */
    public static FunctionDescriptor _PyDict_NewPresized$descriptor() {
        return _PyDict_NewPresized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_NewPresized(Py_ssize_t minused)
     * }
     */
    public static MethodHandle _PyDict_NewPresized$handle() {
        return _PyDict_NewPresized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_NewPresized(Py_ssize_t minused)
     * }
     */
    public static MemorySegment _PyDict_NewPresized$address() {
        return _PyDict_NewPresized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_NewPresized(Py_ssize_t minused)
     * }
     */
    public static MemorySegment _PyDict_NewPresized(long minused) {
        var mh$ = _PyDict_NewPresized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_NewPresized", minused);
            }
            return (MemorySegment)mh$.invokeExact(minused);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Pop(PyObject *dict, PyObject *key, PyObject **result)
     * }
     */
    public static FunctionDescriptor PyDict_Pop$descriptor() {
        return PyDict_Pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Pop(PyObject *dict, PyObject *key, PyObject **result)
     * }
     */
    public static MethodHandle PyDict_Pop$handle() {
        return PyDict_Pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Pop(PyObject *dict, PyObject *key, PyObject **result)
     * }
     */
    public static MemorySegment PyDict_Pop$address() {
        return PyDict_Pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Pop(PyObject *dict, PyObject *key, PyObject **result)
     * }
     */
    public static int PyDict_Pop(MemorySegment dict, MemorySegment key, MemorySegment result) {
        var mh$ = PyDict_Pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Pop", dict, key, result);
            }
            return (int)mh$.invokeExact(dict, key, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_PopString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_PopString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_PopString(PyObject *dict, const char *key, PyObject **result)
     * }
     */
    public static FunctionDescriptor PyDict_PopString$descriptor() {
        return PyDict_PopString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_PopString(PyObject *dict, const char *key, PyObject **result)
     * }
     */
    public static MethodHandle PyDict_PopString$handle() {
        return PyDict_PopString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_PopString(PyObject *dict, const char *key, PyObject **result)
     * }
     */
    public static MemorySegment PyDict_PopString$address() {
        return PyDict_PopString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_PopString(PyObject *dict, const char *key, PyObject **result)
     * }
     */
    public static int PyDict_PopString(MemorySegment dict, MemorySegment key, MemorySegment result) {
        var mh$ = PyDict_PopString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_PopString", dict, key, result);
            }
            return (int)mh$.invokeExact(dict, key, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_Pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_Pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_Pop(PyObject *dict, PyObject *key, PyObject *default_value)
     * }
     */
    public static FunctionDescriptor _PyDict_Pop$descriptor() {
        return _PyDict_Pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_Pop(PyObject *dict, PyObject *key, PyObject *default_value)
     * }
     */
    public static MethodHandle _PyDict_Pop$handle() {
        return _PyDict_Pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_Pop(PyObject *dict, PyObject *key, PyObject *default_value)
     * }
     */
    public static MemorySegment _PyDict_Pop$address() {
        return _PyDict_Pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_Pop(PyObject *dict, PyObject *key, PyObject *default_value)
     * }
     */
    public static MemorySegment _PyDict_Pop(MemorySegment dict, MemorySegment key, MemorySegment default_value) {
        var mh$ = _PyDict_Pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_Pop", dict, key, default_value);
            }
            return (MemorySegment)mh$.invokeExact(dict, key, default_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PyDict_EVENT_ADDED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyDict_EVENT_ADDED = 0
     * }
     */
    public static int PyDict_EVENT_ADDED() {
        return PyDict_EVENT_ADDED;
    }
    private static final int PyDict_EVENT_MODIFIED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyDict_EVENT_MODIFIED = 1
     * }
     */
    public static int PyDict_EVENT_MODIFIED() {
        return PyDict_EVENT_MODIFIED;
    }
    private static final int PyDict_EVENT_DELETED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyDict_EVENT_DELETED = 2
     * }
     */
    public static int PyDict_EVENT_DELETED() {
        return PyDict_EVENT_DELETED;
    }
    private static final int PyDict_EVENT_CLONED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyDict_EVENT_CLONED = 3
     * }
     */
    public static int PyDict_EVENT_CLONED() {
        return PyDict_EVENT_CLONED;
    }
    private static final int PyDict_EVENT_CLEARED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyDict_EVENT_CLEARED = 4
     * }
     */
    public static int PyDict_EVENT_CLEARED() {
        return PyDict_EVENT_CLEARED;
    }
    private static final int PyDict_EVENT_DEALLOCATED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyDict_EVENT_DEALLOCATED = 5
     * }
     */
    public static int PyDict_EVENT_DEALLOCATED() {
        return PyDict_EVENT_DEALLOCATED;
    }

    private static class PyDict_AddWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_AddWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_AddWatcher(PyDict_WatchCallback callback)
     * }
     */
    public static FunctionDescriptor PyDict_AddWatcher$descriptor() {
        return PyDict_AddWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_AddWatcher(PyDict_WatchCallback callback)
     * }
     */
    public static MethodHandle PyDict_AddWatcher$handle() {
        return PyDict_AddWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_AddWatcher(PyDict_WatchCallback callback)
     * }
     */
    public static MemorySegment PyDict_AddWatcher$address() {
        return PyDict_AddWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_AddWatcher(PyDict_WatchCallback callback)
     * }
     */
    public static int PyDict_AddWatcher(MemorySegment callback) {
        var mh$ = PyDict_AddWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_AddWatcher", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_ClearWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_ClearWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_ClearWatcher(int watcher_id)
     * }
     */
    public static FunctionDescriptor PyDict_ClearWatcher$descriptor() {
        return PyDict_ClearWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_ClearWatcher(int watcher_id)
     * }
     */
    public static MethodHandle PyDict_ClearWatcher$handle() {
        return PyDict_ClearWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_ClearWatcher(int watcher_id)
     * }
     */
    public static MemorySegment PyDict_ClearWatcher$address() {
        return PyDict_ClearWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_ClearWatcher(int watcher_id)
     * }
     */
    public static int PyDict_ClearWatcher(int watcher_id) {
        var mh$ = PyDict_ClearWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_ClearWatcher", watcher_id);
            }
            return (int)mh$.invokeExact(watcher_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Watch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Watch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Watch(int watcher_id, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyDict_Watch$descriptor() {
        return PyDict_Watch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Watch(int watcher_id, PyObject *dict)
     * }
     */
    public static MethodHandle PyDict_Watch$handle() {
        return PyDict_Watch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Watch(int watcher_id, PyObject *dict)
     * }
     */
    public static MemorySegment PyDict_Watch$address() {
        return PyDict_Watch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Watch(int watcher_id, PyObject *dict)
     * }
     */
    public static int PyDict_Watch(int watcher_id, MemorySegment dict) {
        var mh$ = PyDict_Watch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Watch", watcher_id, dict);
            }
            return (int)mh$.invokeExact(watcher_id, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Unwatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Unwatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Unwatch(int watcher_id, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyDict_Unwatch$descriptor() {
        return PyDict_Unwatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Unwatch(int watcher_id, PyObject *dict)
     * }
     */
    public static MethodHandle PyDict_Unwatch$handle() {
        return PyDict_Unwatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Unwatch(int watcher_id, PyObject *dict)
     * }
     */
    public static MemorySegment PyDict_Unwatch$address() {
        return PyDict_Unwatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Unwatch(int watcher_id, PyObject *dict)
     * }
     */
    public static int PyDict_Unwatch(int watcher_id, MemorySegment dict) {
        var mh$ = PyDict_Unwatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Unwatch", watcher_id, dict);
            }
            return (int)mh$.invokeExact(watcher_id, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyODict_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODict_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODict_Type
     * }
     */
    public static GroupLayout PyODict_Type$layout() {
        return PyODict_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODict_Type
     * }
     */
    public static MemorySegment PyODict_Type() {
        return PyODict_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODict_Type
     * }
     */
    public static void PyODict_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODict_Type$constants.SEGMENT, 0L, PyODict_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODictIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODictIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictIter_Type
     * }
     */
    public static GroupLayout PyODictIter_Type$layout() {
        return PyODictIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictIter_Type
     * }
     */
    public static MemorySegment PyODictIter_Type() {
        return PyODictIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictIter_Type
     * }
     */
    public static void PyODictIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODictIter_Type$constants.SEGMENT, 0L, PyODictIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODictKeys_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODictKeys_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictKeys_Type
     * }
     */
    public static GroupLayout PyODictKeys_Type$layout() {
        return PyODictKeys_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictKeys_Type
     * }
     */
    public static MemorySegment PyODictKeys_Type() {
        return PyODictKeys_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictKeys_Type
     * }
     */
    public static void PyODictKeys_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODictKeys_Type$constants.SEGMENT, 0L, PyODictKeys_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODictItems_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODictItems_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictItems_Type
     * }
     */
    public static GroupLayout PyODictItems_Type$layout() {
        return PyODictItems_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictItems_Type
     * }
     */
    public static MemorySegment PyODictItems_Type() {
        return PyODictItems_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictItems_Type
     * }
     */
    public static void PyODictItems_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODictItems_Type$constants.SEGMENT, 0L, PyODictItems_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODictValues_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODictValues_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictValues_Type
     * }
     */
    public static GroupLayout PyODictValues_Type$layout() {
        return PyODictValues_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictValues_Type
     * }
     */
    public static MemorySegment PyODictValues_Type() {
        return PyODictValues_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictValues_Type
     * }
     */
    public static void PyODictValues_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODictValues_Type$constants.SEGMENT, 0L, PyODictValues_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODict_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyODict_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyODict_New()
     * }
     */
    public static FunctionDescriptor PyODict_New$descriptor() {
        return PyODict_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyODict_New()
     * }
     */
    public static MethodHandle PyODict_New$handle() {
        return PyODict_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyODict_New()
     * }
     */
    public static MemorySegment PyODict_New$address() {
        return PyODict_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyODict_New()
     * }
     */
    public static MemorySegment PyODict_New() {
        var mh$ = PyODict_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyODict_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyODict_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyODict_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item)
     * }
     */
    public static FunctionDescriptor PyODict_SetItem$descriptor() {
        return PyODict_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item)
     * }
     */
    public static MethodHandle PyODict_SetItem$handle() {
        return PyODict_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item)
     * }
     */
    public static MemorySegment PyODict_SetItem$address() {
        return PyODict_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item)
     * }
     */
    public static int PyODict_SetItem(MemorySegment od, MemorySegment key, MemorySegment item) {
        var mh$ = PyODict_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyODict_SetItem", od, key, item);
            }
            return (int)mh$.invokeExact(od, key, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyODict_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyODict_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyODict_DelItem(PyObject *od, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyODict_DelItem$descriptor() {
        return PyODict_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyODict_DelItem(PyObject *od, PyObject *key)
     * }
     */
    public static MethodHandle PyODict_DelItem$handle() {
        return PyODict_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyODict_DelItem(PyObject *od, PyObject *key)
     * }
     */
    public static MemorySegment PyODict_DelItem$address() {
        return PyODict_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyODict_DelItem(PyObject *od, PyObject *key)
     * }
     */
    public static int PyODict_DelItem(MemorySegment od, MemorySegment key) {
        var mh$ = PyODict_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyODict_DelItem", od, key);
            }
            return (int)mh$.invokeExact(od, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEnum_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyEnum_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEnum_Type
     * }
     */
    public static GroupLayout PyEnum_Type$layout() {
        return PyEnum_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEnum_Type
     * }
     */
    public static MemorySegment PyEnum_Type() {
        return PyEnum_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEnum_Type
     * }
     */
    public static void PyEnum_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyEnum_Type$constants.SEGMENT, 0L, PyEnum_Type$constants.LAYOUT.byteSize());
    }

    private static class PyReversed_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyReversed_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyReversed_Type
     * }
     */
    public static GroupLayout PyReversed_Type$layout() {
        return PyReversed_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyReversed_Type
     * }
     */
    public static MemorySegment PyReversed_Type() {
        return PyReversed_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyReversed_Type
     * }
     */
    public static void PyReversed_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyReversed_Type$constants.SEGMENT, 0L, PyReversed_Type$constants.LAYOUT.byteSize());
    }

    private static class PySet_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySet_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySet_Type
     * }
     */
    public static GroupLayout PySet_Type$layout() {
        return PySet_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySet_Type
     * }
     */
    public static MemorySegment PySet_Type() {
        return PySet_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySet_Type
     * }
     */
    public static void PySet_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySet_Type$constants.SEGMENT, 0L, PySet_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFrozenSet_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFrozenSet_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrozenSet_Type
     * }
     */
    public static GroupLayout PyFrozenSet_Type$layout() {
        return PyFrozenSet_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrozenSet_Type
     * }
     */
    public static MemorySegment PyFrozenSet_Type() {
        return PyFrozenSet_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrozenSet_Type
     * }
     */
    public static void PyFrozenSet_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFrozenSet_Type$constants.SEGMENT, 0L, PyFrozenSet_Type$constants.LAYOUT.byteSize());
    }

    private static class PySetIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySetIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySetIter_Type
     * }
     */
    public static GroupLayout PySetIter_Type$layout() {
        return PySetIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySetIter_Type
     * }
     */
    public static MemorySegment PySetIter_Type() {
        return PySetIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySetIter_Type
     * }
     */
    public static void PySetIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySetIter_Type$constants.SEGMENT, 0L, PySetIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PySet_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PySet_New$descriptor() {
        return PySet_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static MethodHandle PySet_New$handle() {
        return PySet_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static MemorySegment PySet_New$address() {
        return PySet_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static MemorySegment PySet_New(MemorySegment x0) {
        var mh$ = PySet_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrozenSet_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrozenSet_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFrozenSet_New$descriptor() {
        return PyFrozenSet_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static MethodHandle PyFrozenSet_New$handle() {
        return PyFrozenSet_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static MemorySegment PyFrozenSet_New$address() {
        return PyFrozenSet_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static MemorySegment PyFrozenSet_New(MemorySegment x0) {
        var mh$ = PyFrozenSet_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrozenSet_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static FunctionDescriptor PySet_Add$descriptor() {
        return PySet_Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static MethodHandle PySet_Add$handle() {
        return PySet_Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static MemorySegment PySet_Add$address() {
        return PySet_Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static int PySet_Add(MemorySegment set, MemorySegment key) {
        var mh$ = PySet_Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Add", set, key);
            }
            return (int)mh$.invokeExact(set, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static FunctionDescriptor PySet_Clear$descriptor() {
        return PySet_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static MethodHandle PySet_Clear$handle() {
        return PySet_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static MemorySegment PySet_Clear$address() {
        return PySet_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static int PySet_Clear(MemorySegment set) {
        var mh$ = PySet_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Clear", set);
            }
            return (int)mh$.invokeExact(set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static FunctionDescriptor PySet_Contains$descriptor() {
        return PySet_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static MethodHandle PySet_Contains$handle() {
        return PySet_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static MemorySegment PySet_Contains$address() {
        return PySet_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static int PySet_Contains(MemorySegment anyset, MemorySegment key) {
        var mh$ = PySet_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Contains", anyset, key);
            }
            return (int)mh$.invokeExact(anyset, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Discard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Discard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static FunctionDescriptor PySet_Discard$descriptor() {
        return PySet_Discard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static MethodHandle PySet_Discard$handle() {
        return PySet_Discard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static MemorySegment PySet_Discard$address() {
        return PySet_Discard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static int PySet_Discard(MemorySegment set, MemorySegment key) {
        var mh$ = PySet_Discard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Discard", set, key);
            }
            return (int)mh$.invokeExact(set, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static FunctionDescriptor PySet_Pop$descriptor() {
        return PySet_Pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static MethodHandle PySet_Pop$handle() {
        return PySet_Pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static MemorySegment PySet_Pop$address() {
        return PySet_Pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static MemorySegment PySet_Pop(MemorySegment set) {
        var mh$ = PySet_Pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Pop", set);
            }
            return (MemorySegment)mh$.invokeExact(set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static FunctionDescriptor PySet_Size$descriptor() {
        return PySet_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static MethodHandle PySet_Size$handle() {
        return PySet_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static MemorySegment PySet_Size$address() {
        return PySet_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static long PySet_Size(MemorySegment anyset) {
        var mh$ = PySet_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Size", anyset);
            }
            return (long)mh$.invokeExact(anyset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCFunction_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCFunction_Type
     * }
     */
    public static GroupLayout PyCFunction_Type$layout() {
        return PyCFunction_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCFunction_Type
     * }
     */
    public static MemorySegment PyCFunction_Type() {
        return PyCFunction_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCFunction_Type
     * }
     */
    public static void PyCFunction_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCFunction_Type$constants.SEGMENT, 0L, PyCFunction_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCFunction_GetFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_GetFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_GetFunction$descriptor() {
        return PyCFunction_GetFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_GetFunction$handle() {
        return PyCFunction_GetFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetFunction$address() {
        return PyCFunction_GetFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetFunction(MemorySegment x0) {
        var mh$ = PyCFunction_GetFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_GetFunction", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_GetSelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_GetSelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_GetSelf$descriptor() {
        return PyCFunction_GetSelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_GetSelf$handle() {
        return PyCFunction_GetSelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetSelf$address() {
        return PyCFunction_GetSelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetSelf(MemorySegment x0) {
        var mh$ = PyCFunction_GetSelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_GetSelf", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_GetFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_GetFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_GetFlags$descriptor() {
        return PyCFunction_GetFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_GetFlags$handle() {
        return PyCFunction_GetFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetFlags$address() {
        return PyCFunction_GetFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static int PyCFunction_GetFlags(MemorySegment x0) {
        var mh$ = PyCFunction_GetFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_GetFlags", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_New$descriptor() {
        return PyCFunction_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_New$handle() {
        return PyCFunction_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_New$address() {
        return PyCFunction_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyCFunction_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_NewEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_NewEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_NewEx$descriptor() {
        return PyCFunction_NewEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_NewEx$handle() {
        return PyCFunction_NewEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_NewEx$address() {
        return PyCFunction_NewEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_NewEx(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyCFunction_NewEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_NewEx", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyCMethod_New$descriptor() {
        return PyCMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyCMethod_New$handle() {
        return PyCMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyCMethod_New$address() {
        return PyCMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyCMethod_New(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyCMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCMethod_New", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCMethod_Type
     * }
     */
    public static GroupLayout PyCMethod_Type$layout() {
        return PyCMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCMethod_Type
     * }
     */
    public static MemorySegment PyCMethod_Type() {
        return PyCMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCMethod_Type
     * }
     */
    public static void PyCMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCMethod_Type$constants.SEGMENT, 0L, PyCMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyModule_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyModule_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModule_Type
     * }
     */
    public static GroupLayout PyModule_Type$layout() {
        return PyModule_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModule_Type
     * }
     */
    public static MemorySegment PyModule_Type() {
        return PyModule_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModule_Type
     * }
     */
    public static void PyModule_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyModule_Type$constants.SEGMENT, 0L, PyModule_Type$constants.LAYOUT.byteSize());
    }

    private static class PyModule_NewObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_NewObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyModule_NewObject$descriptor() {
        return PyModule_NewObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static MethodHandle PyModule_NewObject$handle() {
        return PyModule_NewObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static MemorySegment PyModule_NewObject$address() {
        return PyModule_NewObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static MemorySegment PyModule_NewObject(MemorySegment name) {
        var mh$ = PyModule_NewObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_NewObject", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static FunctionDescriptor PyModule_New$descriptor() {
        return PyModule_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static MethodHandle PyModule_New$handle() {
        return PyModule_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static MemorySegment PyModule_New$address() {
        return PyModule_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static MemorySegment PyModule_New(MemorySegment name) {
        var mh$ = PyModule_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_New", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetDict$descriptor() {
        return PyModule_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetDict$handle() {
        return PyModule_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDict$address() {
        return PyModule_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDict(MemorySegment x0) {
        var mh$ = PyModule_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetDict", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetNameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetNameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetNameObject$descriptor() {
        return PyModule_GetNameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetNameObject$handle() {
        return PyModule_GetNameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetNameObject$address() {
        return PyModule_GetNameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetNameObject(MemorySegment x0) {
        var mh$ = PyModule_GetNameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetNameObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetName$descriptor() {
        return PyModule_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetName$handle() {
        return PyModule_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetName$address() {
        return PyModule_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetName(MemorySegment x0) {
        var mh$ = PyModule_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetFilename$descriptor() {
        return PyModule_GetFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetFilename$handle() {
        return PyModule_GetFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilename$address() {
        return PyModule_GetFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilename(MemorySegment x0) {
        var mh$ = PyModule_GetFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetFilename", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetFilenameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetFilenameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetFilenameObject$descriptor() {
        return PyModule_GetFilenameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetFilenameObject$handle() {
        return PyModule_GetFilenameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilenameObject$address() {
        return PyModule_GetFilenameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilenameObject(MemorySegment x0) {
        var mh$ = PyModule_GetFilenameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetFilenameObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetDef$descriptor() {
        return PyModule_GetDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetDef$handle() {
        return PyModule_GetDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDef$address() {
        return PyModule_GetDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDef(MemorySegment x0) {
        var mh$ = PyModule_GetDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetDef", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetState$descriptor() {
        return PyModule_GetState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetState$handle() {
        return PyModule_GetState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetState$address() {
        return PyModule_GetState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetState(MemorySegment x0) {
        var mh$ = PyModule_GetState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetState", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModuleDef_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModuleDef_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyModuleDef_Init$descriptor() {
        return PyModuleDef_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static MethodHandle PyModuleDef_Init$handle() {
        return PyModuleDef_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static MemorySegment PyModuleDef_Init$address() {
        return PyModuleDef_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static MemorySegment PyModuleDef_Init(MemorySegment x0) {
        var mh$ = PyModuleDef_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModuleDef_Init", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModuleDef_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyModuleDef_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModuleDef_Type
     * }
     */
    public static GroupLayout PyModuleDef_Type$layout() {
        return PyModuleDef_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModuleDef_Type
     * }
     */
    public static MemorySegment PyModuleDef_Type() {
        return PyModuleDef_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModuleDef_Type
     * }
     */
    public static void PyModuleDef_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyModuleDef_Type$constants.SEGMENT, 0L, PyModuleDef_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMonitoring_EnterScope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMonitoring_EnterScope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMonitoring_EnterScope(PyMonitoringState *state_array, uint64_t *version, const uint8_t *event_types, Py_ssize_t length)
     * }
     */
    public static FunctionDescriptor PyMonitoring_EnterScope$descriptor() {
        return PyMonitoring_EnterScope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMonitoring_EnterScope(PyMonitoringState *state_array, uint64_t *version, const uint8_t *event_types, Py_ssize_t length)
     * }
     */
    public static MethodHandle PyMonitoring_EnterScope$handle() {
        return PyMonitoring_EnterScope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMonitoring_EnterScope(PyMonitoringState *state_array, uint64_t *version, const uint8_t *event_types, Py_ssize_t length)
     * }
     */
    public static MemorySegment PyMonitoring_EnterScope$address() {
        return PyMonitoring_EnterScope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMonitoring_EnterScope(PyMonitoringState *state_array, uint64_t *version, const uint8_t *event_types, Py_ssize_t length)
     * }
     */
    public static int PyMonitoring_EnterScope(MemorySegment state_array, MemorySegment version, MemorySegment event_types, long length) {
        var mh$ = PyMonitoring_EnterScope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMonitoring_EnterScope", state_array, version, event_types, length);
            }
            return (int)mh$.invokeExact(state_array, version, event_types, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMonitoring_ExitScope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMonitoring_ExitScope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMonitoring_ExitScope()
     * }
     */
    public static FunctionDescriptor PyMonitoring_ExitScope$descriptor() {
        return PyMonitoring_ExitScope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMonitoring_ExitScope()
     * }
     */
    public static MethodHandle PyMonitoring_ExitScope$handle() {
        return PyMonitoring_ExitScope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMonitoring_ExitScope()
     * }
     */
    public static MemorySegment PyMonitoring_ExitScope$address() {
        return PyMonitoring_ExitScope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMonitoring_ExitScope()
     * }
     */
    public static int PyMonitoring_ExitScope() {
        var mh$ = PyMonitoring_ExitScope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMonitoring_ExitScope");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FirePyStartEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FirePyStartEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyStartEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FirePyStartEvent$descriptor() {
        return _PyMonitoring_FirePyStartEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyStartEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FirePyStartEvent$handle() {
        return _PyMonitoring_FirePyStartEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyStartEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FirePyStartEvent$address() {
        return _PyMonitoring_FirePyStartEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyStartEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static int _PyMonitoring_FirePyStartEvent(MemorySegment state, MemorySegment codelike, int offset) {
        var mh$ = _PyMonitoring_FirePyStartEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FirePyStartEvent", state, codelike, offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FirePyResumeEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FirePyResumeEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyResumeEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FirePyResumeEvent$descriptor() {
        return _PyMonitoring_FirePyResumeEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyResumeEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FirePyResumeEvent$handle() {
        return _PyMonitoring_FirePyResumeEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyResumeEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FirePyResumeEvent$address() {
        return _PyMonitoring_FirePyResumeEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyResumeEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static int _PyMonitoring_FirePyResumeEvent(MemorySegment state, MemorySegment codelike, int offset) {
        var mh$ = _PyMonitoring_FirePyResumeEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FirePyResumeEvent", state, codelike, offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FirePyReturnEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FirePyReturnEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyReturnEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FirePyReturnEvent$descriptor() {
        return _PyMonitoring_FirePyReturnEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyReturnEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static MethodHandle _PyMonitoring_FirePyReturnEvent$handle() {
        return _PyMonitoring_FirePyReturnEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyReturnEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static MemorySegment _PyMonitoring_FirePyReturnEvent$address() {
        return _PyMonitoring_FirePyReturnEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyReturnEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static int _PyMonitoring_FirePyReturnEvent(MemorySegment state, MemorySegment codelike, int offset, MemorySegment retval) {
        var mh$ = _PyMonitoring_FirePyReturnEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FirePyReturnEvent", state, codelike, offset, retval);
            }
            return (int)mh$.invokeExact(state, codelike, offset, retval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FirePyYieldEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FirePyYieldEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyYieldEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FirePyYieldEvent$descriptor() {
        return _PyMonitoring_FirePyYieldEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyYieldEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static MethodHandle _PyMonitoring_FirePyYieldEvent$handle() {
        return _PyMonitoring_FirePyYieldEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyYieldEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static MemorySegment _PyMonitoring_FirePyYieldEvent$address() {
        return _PyMonitoring_FirePyYieldEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyYieldEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static int _PyMonitoring_FirePyYieldEvent(MemorySegment state, MemorySegment codelike, int offset, MemorySegment retval) {
        var mh$ = _PyMonitoring_FirePyYieldEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FirePyYieldEvent", state, codelike, offset, retval);
            }
            return (int)mh$.invokeExact(state, codelike, offset, retval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireCallEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireCallEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireCallEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *callable, PyObject *arg0)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireCallEvent$descriptor() {
        return _PyMonitoring_FireCallEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireCallEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *callable, PyObject *arg0)
     * }
     */
    public static MethodHandle _PyMonitoring_FireCallEvent$handle() {
        return _PyMonitoring_FireCallEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireCallEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *callable, PyObject *arg0)
     * }
     */
    public static MemorySegment _PyMonitoring_FireCallEvent$address() {
        return _PyMonitoring_FireCallEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireCallEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *callable, PyObject *arg0)
     * }
     */
    public static int _PyMonitoring_FireCallEvent(MemorySegment state, MemorySegment codelike, int offset, MemorySegment callable, MemorySegment arg0) {
        var mh$ = _PyMonitoring_FireCallEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireCallEvent", state, codelike, offset, callable, arg0);
            }
            return (int)mh$.invokeExact(state, codelike, offset, callable, arg0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireLineEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireLineEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireLineEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, int lineno)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireLineEvent$descriptor() {
        return _PyMonitoring_FireLineEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireLineEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, int lineno)
     * }
     */
    public static MethodHandle _PyMonitoring_FireLineEvent$handle() {
        return _PyMonitoring_FireLineEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireLineEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, int lineno)
     * }
     */
    public static MemorySegment _PyMonitoring_FireLineEvent$address() {
        return _PyMonitoring_FireLineEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireLineEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, int lineno)
     * }
     */
    public static int _PyMonitoring_FireLineEvent(MemorySegment state, MemorySegment codelike, int offset, int lineno) {
        var mh$ = _PyMonitoring_FireLineEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireLineEvent", state, codelike, offset, lineno);
            }
            return (int)mh$.invokeExact(state, codelike, offset, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireJumpEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireJumpEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireJumpEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *target_offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireJumpEvent$descriptor() {
        return _PyMonitoring_FireJumpEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireJumpEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *target_offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FireJumpEvent$handle() {
        return _PyMonitoring_FireJumpEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireJumpEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *target_offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FireJumpEvent$address() {
        return _PyMonitoring_FireJumpEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireJumpEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *target_offset)
     * }
     */
    public static int _PyMonitoring_FireJumpEvent(MemorySegment state, MemorySegment codelike, int offset, MemorySegment target_offset) {
        var mh$ = _PyMonitoring_FireJumpEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireJumpEvent", state, codelike, offset, target_offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset, target_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireBranchEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireBranchEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireBranchEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *target_offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireBranchEvent$descriptor() {
        return _PyMonitoring_FireBranchEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireBranchEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *target_offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FireBranchEvent$handle() {
        return _PyMonitoring_FireBranchEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireBranchEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *target_offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FireBranchEvent$address() {
        return _PyMonitoring_FireBranchEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireBranchEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *target_offset)
     * }
     */
    public static int _PyMonitoring_FireBranchEvent(MemorySegment state, MemorySegment codelike, int offset, MemorySegment target_offset) {
        var mh$ = _PyMonitoring_FireBranchEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireBranchEvent", state, codelike, offset, target_offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset, target_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireCReturnEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireCReturnEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireCReturnEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireCReturnEvent$descriptor() {
        return _PyMonitoring_FireCReturnEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireCReturnEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static MethodHandle _PyMonitoring_FireCReturnEvent$handle() {
        return _PyMonitoring_FireCReturnEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireCReturnEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static MemorySegment _PyMonitoring_FireCReturnEvent$address() {
        return _PyMonitoring_FireCReturnEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireCReturnEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *retval)
     * }
     */
    public static int _PyMonitoring_FireCReturnEvent(MemorySegment state, MemorySegment codelike, int offset, MemorySegment retval) {
        var mh$ = _PyMonitoring_FireCReturnEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireCReturnEvent", state, codelike, offset, retval);
            }
            return (int)mh$.invokeExact(state, codelike, offset, retval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FirePyThrowEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FirePyThrowEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyThrowEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FirePyThrowEvent$descriptor() {
        return _PyMonitoring_FirePyThrowEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyThrowEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FirePyThrowEvent$handle() {
        return _PyMonitoring_FirePyThrowEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyThrowEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FirePyThrowEvent$address() {
        return _PyMonitoring_FirePyThrowEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyThrowEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static int _PyMonitoring_FirePyThrowEvent(MemorySegment state, MemorySegment codelike, int offset) {
        var mh$ = _PyMonitoring_FirePyThrowEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FirePyThrowEvent", state, codelike, offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireRaiseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireRaiseEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireRaiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireRaiseEvent$descriptor() {
        return _PyMonitoring_FireRaiseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireRaiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FireRaiseEvent$handle() {
        return _PyMonitoring_FireRaiseEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireRaiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FireRaiseEvent$address() {
        return _PyMonitoring_FireRaiseEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireRaiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static int _PyMonitoring_FireRaiseEvent(MemorySegment state, MemorySegment codelike, int offset) {
        var mh$ = _PyMonitoring_FireRaiseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireRaiseEvent", state, codelike, offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireReraiseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireReraiseEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireReraiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireReraiseEvent$descriptor() {
        return _PyMonitoring_FireReraiseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireReraiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FireReraiseEvent$handle() {
        return _PyMonitoring_FireReraiseEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireReraiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FireReraiseEvent$address() {
        return _PyMonitoring_FireReraiseEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireReraiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static int _PyMonitoring_FireReraiseEvent(MemorySegment state, MemorySegment codelike, int offset) {
        var mh$ = _PyMonitoring_FireReraiseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireReraiseEvent", state, codelike, offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireExceptionHandledEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireExceptionHandledEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireExceptionHandledEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireExceptionHandledEvent$descriptor() {
        return _PyMonitoring_FireExceptionHandledEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireExceptionHandledEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FireExceptionHandledEvent$handle() {
        return _PyMonitoring_FireExceptionHandledEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireExceptionHandledEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FireExceptionHandledEvent$address() {
        return _PyMonitoring_FireExceptionHandledEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireExceptionHandledEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static int _PyMonitoring_FireExceptionHandledEvent(MemorySegment state, MemorySegment codelike, int offset) {
        var mh$ = _PyMonitoring_FireExceptionHandledEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireExceptionHandledEvent", state, codelike, offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireCRaiseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireCRaiseEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireCRaiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireCRaiseEvent$descriptor() {
        return _PyMonitoring_FireCRaiseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireCRaiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FireCRaiseEvent$handle() {
        return _PyMonitoring_FireCRaiseEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireCRaiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FireCRaiseEvent$address() {
        return _PyMonitoring_FireCRaiseEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireCRaiseEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static int _PyMonitoring_FireCRaiseEvent(MemorySegment state, MemorySegment codelike, int offset) {
        var mh$ = _PyMonitoring_FireCRaiseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireCRaiseEvent", state, codelike, offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FirePyUnwindEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FirePyUnwindEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyUnwindEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FirePyUnwindEvent$descriptor() {
        return _PyMonitoring_FirePyUnwindEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyUnwindEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MethodHandle _PyMonitoring_FirePyUnwindEvent$handle() {
        return _PyMonitoring_FirePyUnwindEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyUnwindEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static MemorySegment _PyMonitoring_FirePyUnwindEvent$address() {
        return _PyMonitoring_FirePyUnwindEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FirePyUnwindEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset)
     * }
     */
    public static int _PyMonitoring_FirePyUnwindEvent(MemorySegment state, MemorySegment codelike, int offset) {
        var mh$ = _PyMonitoring_FirePyUnwindEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FirePyUnwindEvent", state, codelike, offset);
            }
            return (int)mh$.invokeExact(state, codelike, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMonitoring_FireStopIterationEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMonitoring_FireStopIterationEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *value)
     * }
     */
    public static FunctionDescriptor _PyMonitoring_FireStopIterationEvent$descriptor() {
        return _PyMonitoring_FireStopIterationEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *value)
     * }
     */
    public static MethodHandle _PyMonitoring_FireStopIterationEvent$handle() {
        return _PyMonitoring_FireStopIterationEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *value)
     * }
     */
    public static MemorySegment _PyMonitoring_FireStopIterationEvent$address() {
        return _PyMonitoring_FireStopIterationEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyMonitoring_FireStopIterationEvent(PyMonitoringState *state, PyObject *codelike, int32_t offset, PyObject *value)
     * }
     */
    public static int _PyMonitoring_FireStopIterationEvent(MemorySegment state, MemorySegment codelike, int offset, MemorySegment value) {
        var mh$ = _PyMonitoring_FireStopIterationEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMonitoring_FireStopIterationEvent", state, codelike, offset, value);
            }
            return (int)mh$.invokeExact(state, codelike, offset, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFunction_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFunction_Type
     * }
     */
    public static GroupLayout PyFunction_Type$layout() {
        return PyFunction_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFunction_Type
     * }
     */
    public static MemorySegment PyFunction_Type() {
        return PyFunction_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFunction_Type
     * }
     */
    public static void PyFunction_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFunction_Type$constants.SEGMENT, 0L, PyFunction_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFunction_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_New$descriptor() {
        return PyFunction_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_New$handle() {
        return PyFunction_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_New$address() {
        return PyFunction_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_NewWithQualName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_NewWithQualName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_NewWithQualName$descriptor() {
        return PyFunction_NewWithQualName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_NewWithQualName$handle() {
        return PyFunction_NewWithQualName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_NewWithQualName$address() {
        return PyFunction_NewWithQualName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_NewWithQualName(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyFunction_NewWithQualName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_NewWithQualName", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetCode(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetCode$descriptor() {
        return PyFunction_GetCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetCode(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetCode$handle() {
        return PyFunction_GetCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetCode(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetCode$address() {
        return PyFunction_GetCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetCode(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetCode(MemorySegment x0) {
        var mh$ = PyFunction_GetCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetCode", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetGlobals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetGlobals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetGlobals(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetGlobals$descriptor() {
        return PyFunction_GetGlobals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetGlobals(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetGlobals$handle() {
        return PyFunction_GetGlobals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetGlobals(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetGlobals$address() {
        return PyFunction_GetGlobals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetGlobals(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetGlobals(MemorySegment x0) {
        var mh$ = PyFunction_GetGlobals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetGlobals", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetModule(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetModule$descriptor() {
        return PyFunction_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetModule(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetModule$handle() {
        return PyFunction_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetModule(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetModule$address() {
        return PyFunction_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetModule(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetModule(MemorySegment x0) {
        var mh$ = PyFunction_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetDefaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetDefaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetDefaults(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetDefaults$descriptor() {
        return PyFunction_GetDefaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetDefaults(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetDefaults$handle() {
        return PyFunction_GetDefaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetDefaults(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetDefaults$address() {
        return PyFunction_GetDefaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetDefaults(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetDefaults(MemorySegment x0) {
        var mh$ = PyFunction_GetDefaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetDefaults", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_SetDefaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_SetDefaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_SetDefaults(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_SetDefaults$descriptor() {
        return PyFunction_SetDefaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_SetDefaults(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_SetDefaults$handle() {
        return PyFunction_SetDefaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_SetDefaults(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_SetDefaults$address() {
        return PyFunction_SetDefaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_SetDefaults(PyObject *, PyObject *)
     * }
     */
    public static int PyFunction_SetDefaults(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_SetDefaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_SetDefaults", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_SetVectorcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_SetVectorcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyFunction_SetVectorcall(PyFunctionObject *, vectorcallfunc)
     * }
     */
    public static FunctionDescriptor PyFunction_SetVectorcall$descriptor() {
        return PyFunction_SetVectorcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyFunction_SetVectorcall(PyFunctionObject *, vectorcallfunc)
     * }
     */
    public static MethodHandle PyFunction_SetVectorcall$handle() {
        return PyFunction_SetVectorcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyFunction_SetVectorcall(PyFunctionObject *, vectorcallfunc)
     * }
     */
    public static MemorySegment PyFunction_SetVectorcall$address() {
        return PyFunction_SetVectorcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyFunction_SetVectorcall(PyFunctionObject *, vectorcallfunc)
     * }
     */
    public static void PyFunction_SetVectorcall(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_SetVectorcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_SetVectorcall", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetKwDefaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetKwDefaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetKwDefaults(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetKwDefaults$descriptor() {
        return PyFunction_GetKwDefaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetKwDefaults(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetKwDefaults$handle() {
        return PyFunction_GetKwDefaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetKwDefaults(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetKwDefaults$address() {
        return PyFunction_GetKwDefaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetKwDefaults(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetKwDefaults(MemorySegment x0) {
        var mh$ = PyFunction_GetKwDefaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetKwDefaults", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_SetKwDefaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_SetKwDefaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_SetKwDefaults(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_SetKwDefaults$descriptor() {
        return PyFunction_SetKwDefaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_SetKwDefaults(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_SetKwDefaults$handle() {
        return PyFunction_SetKwDefaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_SetKwDefaults(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_SetKwDefaults$address() {
        return PyFunction_SetKwDefaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_SetKwDefaults(PyObject *, PyObject *)
     * }
     */
    public static int PyFunction_SetKwDefaults(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_SetKwDefaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_SetKwDefaults", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetClosure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetClosure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetClosure(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetClosure$descriptor() {
        return PyFunction_GetClosure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetClosure(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetClosure$handle() {
        return PyFunction_GetClosure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetClosure(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetClosure$address() {
        return PyFunction_GetClosure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetClosure(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetClosure(MemorySegment x0) {
        var mh$ = PyFunction_GetClosure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetClosure", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_SetClosure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_SetClosure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_SetClosure(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_SetClosure$descriptor() {
        return PyFunction_SetClosure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_SetClosure(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_SetClosure$handle() {
        return PyFunction_SetClosure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_SetClosure(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_SetClosure$address() {
        return PyFunction_SetClosure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_SetClosure(PyObject *, PyObject *)
     * }
     */
    public static int PyFunction_SetClosure(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_SetClosure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_SetClosure", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetAnnotations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetAnnotations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetAnnotations(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetAnnotations$descriptor() {
        return PyFunction_GetAnnotations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetAnnotations(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetAnnotations$handle() {
        return PyFunction_GetAnnotations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetAnnotations(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetAnnotations$address() {
        return PyFunction_GetAnnotations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetAnnotations(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetAnnotations(MemorySegment x0) {
        var mh$ = PyFunction_GetAnnotations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetAnnotations", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_SetAnnotations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_SetAnnotations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_SetAnnotations(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_SetAnnotations$descriptor() {
        return PyFunction_SetAnnotations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_SetAnnotations(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_SetAnnotations$handle() {
        return PyFunction_SetAnnotations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_SetAnnotations(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_SetAnnotations$address() {
        return PyFunction_SetAnnotations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_SetAnnotations(PyObject *, PyObject *)
     * }
     */
    public static int PyFunction_SetAnnotations(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_SetAnnotations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_SetAnnotations", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyClassMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyClassMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethod_Type
     * }
     */
    public static GroupLayout PyClassMethod_Type$layout() {
        return PyClassMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethod_Type
     * }
     */
    public static MemorySegment PyClassMethod_Type() {
        return PyClassMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethod_Type
     * }
     */
    public static void PyClassMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyClassMethod_Type$constants.SEGMENT, 0L, PyClassMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyStaticMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyStaticMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStaticMethod_Type
     * }
     */
    public static GroupLayout PyStaticMethod_Type$layout() {
        return PyStaticMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStaticMethod_Type
     * }
     */
    public static MemorySegment PyStaticMethod_Type() {
        return PyStaticMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStaticMethod_Type
     * }
     */
    public static void PyStaticMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyStaticMethod_Type$constants.SEGMENT, 0L, PyStaticMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyClassMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyClassMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyClassMethod_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyClassMethod_New$descriptor() {
        return PyClassMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyClassMethod_New(PyObject *)
     * }
     */
    public static MethodHandle PyClassMethod_New$handle() {
        return PyClassMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyClassMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyClassMethod_New$address() {
        return PyClassMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyClassMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyClassMethod_New(MemorySegment x0) {
        var mh$ = PyClassMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyClassMethod_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStaticMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStaticMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyStaticMethod_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyStaticMethod_New$descriptor() {
        return PyStaticMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyStaticMethod_New(PyObject *)
     * }
     */
    public static MethodHandle PyStaticMethod_New$handle() {
        return PyStaticMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyStaticMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyStaticMethod_New$address() {
        return PyStaticMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyStaticMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyStaticMethod_New(MemorySegment x0) {
        var mh$ = PyStaticMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStaticMethod_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PyFunction_EVENT_CREATE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyFunction_EVENT_CREATE = 0
     * }
     */
    public static int PyFunction_EVENT_CREATE() {
        return PyFunction_EVENT_CREATE;
    }
    private static final int PyFunction_EVENT_DESTROY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyFunction_EVENT_DESTROY = 1
     * }
     */
    public static int PyFunction_EVENT_DESTROY() {
        return PyFunction_EVENT_DESTROY;
    }
    private static final int PyFunction_EVENT_MODIFY_CODE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyFunction_EVENT_MODIFY_CODE = 2
     * }
     */
    public static int PyFunction_EVENT_MODIFY_CODE() {
        return PyFunction_EVENT_MODIFY_CODE;
    }
    private static final int PyFunction_EVENT_MODIFY_DEFAULTS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyFunction_EVENT_MODIFY_DEFAULTS = 3
     * }
     */
    public static int PyFunction_EVENT_MODIFY_DEFAULTS() {
        return PyFunction_EVENT_MODIFY_DEFAULTS;
    }
    private static final int PyFunction_EVENT_MODIFY_KWDEFAULTS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyFunction_EVENT_MODIFY_KWDEFAULTS = 4
     * }
     */
    public static int PyFunction_EVENT_MODIFY_KWDEFAULTS() {
        return PyFunction_EVENT_MODIFY_KWDEFAULTS;
    }

    private static class PyFunction_AddWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_AddWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_AddWatcher(PyFunction_WatchCallback callback)
     * }
     */
    public static FunctionDescriptor PyFunction_AddWatcher$descriptor() {
        return PyFunction_AddWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_AddWatcher(PyFunction_WatchCallback callback)
     * }
     */
    public static MethodHandle PyFunction_AddWatcher$handle() {
        return PyFunction_AddWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_AddWatcher(PyFunction_WatchCallback callback)
     * }
     */
    public static MemorySegment PyFunction_AddWatcher$address() {
        return PyFunction_AddWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_AddWatcher(PyFunction_WatchCallback callback)
     * }
     */
    public static int PyFunction_AddWatcher(MemorySegment callback) {
        var mh$ = PyFunction_AddWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_AddWatcher", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_ClearWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_ClearWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_ClearWatcher(int watcher_id)
     * }
     */
    public static FunctionDescriptor PyFunction_ClearWatcher$descriptor() {
        return PyFunction_ClearWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_ClearWatcher(int watcher_id)
     * }
     */
    public static MethodHandle PyFunction_ClearWatcher$handle() {
        return PyFunction_ClearWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_ClearWatcher(int watcher_id)
     * }
     */
    public static MemorySegment PyFunction_ClearWatcher$address() {
        return PyFunction_ClearWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_ClearWatcher(int watcher_id)
     * }
     */
    public static int PyFunction_ClearWatcher(int watcher_id) {
        var mh$ = PyFunction_ClearWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_ClearWatcher", watcher_id);
            }
            return (int)mh$.invokeExact(watcher_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethod_Type
     * }
     */
    public static GroupLayout PyMethod_Type$layout() {
        return PyMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethod_Type
     * }
     */
    public static MemorySegment PyMethod_Type() {
        return PyMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethod_Type
     * }
     */
    public static void PyMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMethod_Type$constants.SEGMENT, 0L, PyMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMethod_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyMethod_New$descriptor() {
        return PyMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMethod_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyMethod_New$handle() {
        return PyMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMethod_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyMethod_New$address() {
        return PyMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMethod_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyMethod_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMethod_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMethod_Function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMethod_Function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Function(PyObject *)
     * }
     */
    public static FunctionDescriptor PyMethod_Function$descriptor() {
        return PyMethod_Function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Function(PyObject *)
     * }
     */
    public static MethodHandle PyMethod_Function$handle() {
        return PyMethod_Function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Function(PyObject *)
     * }
     */
    public static MemorySegment PyMethod_Function$address() {
        return PyMethod_Function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMethod_Function(PyObject *)
     * }
     */
    public static MemorySegment PyMethod_Function(MemorySegment x0) {
        var mh$ = PyMethod_Function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMethod_Function", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMethod_Self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMethod_Self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Self(PyObject *)
     * }
     */
    public static FunctionDescriptor PyMethod_Self$descriptor() {
        return PyMethod_Self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Self(PyObject *)
     * }
     */
    public static MethodHandle PyMethod_Self$handle() {
        return PyMethod_Self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Self(PyObject *)
     * }
     */
    public static MemorySegment PyMethod_Self$address() {
        return PyMethod_Self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMethod_Self(PyObject *)
     * }
     */
    public static MemorySegment PyMethod_Self(MemorySegment x0) {
        var mh$ = PyMethod_Self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMethod_Self", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInstanceMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyInstanceMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyInstanceMethod_Type
     * }
     */
    public static GroupLayout PyInstanceMethod_Type$layout() {
        return PyInstanceMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyInstanceMethod_Type
     * }
     */
    public static MemorySegment PyInstanceMethod_Type() {
        return PyInstanceMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyInstanceMethod_Type
     * }
     */
    public static void PyInstanceMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyInstanceMethod_Type$constants.SEGMENT, 0L, PyInstanceMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyInstanceMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInstanceMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyInstanceMethod_New$descriptor() {
        return PyInstanceMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_New(PyObject *)
     * }
     */
    public static MethodHandle PyInstanceMethod_New$handle() {
        return PyInstanceMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyInstanceMethod_New$address() {
        return PyInstanceMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyInstanceMethod_New(MemorySegment x0) {
        var mh$ = PyInstanceMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInstanceMethod_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInstanceMethod_Function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInstanceMethod_Function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_Function(PyObject *)
     * }
     */
    public static FunctionDescriptor PyInstanceMethod_Function$descriptor() {
        return PyInstanceMethod_Function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_Function(PyObject *)
     * }
     */
    public static MethodHandle PyInstanceMethod_Function$handle() {
        return PyInstanceMethod_Function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_Function(PyObject *)
     * }
     */
    public static MemorySegment PyInstanceMethod_Function$address() {
        return PyInstanceMethod_Function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_Function(PyObject *)
     * }
     */
    public static MemorySegment PyInstanceMethod_Function(MemorySegment x0) {
        var mh$ = PyInstanceMethod_Function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInstanceMethod_Function", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_FromFd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_FromFd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static FunctionDescriptor PyFile_FromFd$descriptor() {
        return PyFile_FromFd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static MethodHandle PyFile_FromFd$handle() {
        return PyFile_FromFd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static MemorySegment PyFile_FromFd$address() {
        return PyFile_FromFd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static MemorySegment PyFile_FromFd(int x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7) {
        var mh$ = PyFile_FromFd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_FromFd", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_GetLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_GetLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyFile_GetLine$descriptor() {
        return PyFile_GetLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static MethodHandle PyFile_GetLine$handle() {
        return PyFile_GetLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static MemorySegment PyFile_GetLine$address() {
        return PyFile_GetLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static MemorySegment PyFile_GetLine(MemorySegment x0, int x1) {
        var mh$ = PyFile_GetLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_GetLine", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_WriteObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_WriteObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyFile_WriteObject$descriptor() {
        return PyFile_WriteObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyFile_WriteObject$handle() {
        return PyFile_WriteObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyFile_WriteObject$address() {
        return PyFile_WriteObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static int PyFile_WriteObject(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyFile_WriteObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_WriteObject", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_WriteString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_WriteString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFile_WriteString$descriptor() {
        return PyFile_WriteString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static MethodHandle PyFile_WriteString$handle() {
        return PyFile_WriteString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static MemorySegment PyFile_WriteString$address() {
        return PyFile_WriteString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static int PyFile_WriteString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFile_WriteString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_WriteString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_AsFileDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_AsFileDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_AsFileDescriptor$descriptor() {
        return PyObject_AsFileDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static MethodHandle PyObject_AsFileDescriptor$handle() {
        return PyObject_AsFileDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static MemorySegment PyObject_AsFileDescriptor$address() {
        return PyObject_AsFileDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static int PyObject_AsFileDescriptor(MemorySegment x0) {
        var mh$ = PyObject_AsFileDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_AsFileDescriptor", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FileSystemDefaultEncoding$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_FileSystemDefaultEncoding").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static AddressLayout Py_FileSystemDefaultEncoding$layout() {
        return Py_FileSystemDefaultEncoding$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncoding$segment() {
        return Py_FileSystemDefaultEncoding$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncoding() {
        return Py_FileSystemDefaultEncoding$constants.SEGMENT.get(Py_FileSystemDefaultEncoding$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static void Py_FileSystemDefaultEncoding(MemorySegment varValue) {
        Py_FileSystemDefaultEncoding$constants.SEGMENT.set(Py_FileSystemDefaultEncoding$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_FileSystemDefaultEncodeErrors$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_FileSystemDefaultEncodeErrors").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static AddressLayout Py_FileSystemDefaultEncodeErrors$layout() {
        return Py_FileSystemDefaultEncodeErrors$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncodeErrors$segment() {
        return Py_FileSystemDefaultEncodeErrors$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncodeErrors() {
        return Py_FileSystemDefaultEncodeErrors$constants.SEGMENT.get(Py_FileSystemDefaultEncodeErrors$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static void Py_FileSystemDefaultEncodeErrors(MemorySegment varValue) {
        Py_FileSystemDefaultEncodeErrors$constants.SEGMENT.set(Py_FileSystemDefaultEncodeErrors$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_HasFileSystemDefaultEncoding$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_HasFileSystemDefaultEncoding").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static OfInt Py_HasFileSystemDefaultEncoding$layout() {
        return Py_HasFileSystemDefaultEncoding$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static MemorySegment Py_HasFileSystemDefaultEncoding$segment() {
        return Py_HasFileSystemDefaultEncoding$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static int Py_HasFileSystemDefaultEncoding() {
        return Py_HasFileSystemDefaultEncoding$constants.SEGMENT.get(Py_HasFileSystemDefaultEncoding$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static void Py_HasFileSystemDefaultEncoding(int varValue) {
        Py_HasFileSystemDefaultEncoding$constants.SEGMENT.set(Py_HasFileSystemDefaultEncoding$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_UTF8Mode$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_UTF8Mode").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static OfInt Py_UTF8Mode$layout() {
        return Py_UTF8Mode$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static MemorySegment Py_UTF8Mode$segment() {
        return Py_UTF8Mode$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static int Py_UTF8Mode() {
        return Py_UTF8Mode$constants.SEGMENT.get(Py_UTF8Mode$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static void Py_UTF8Mode(int varValue) {
        Py_UTF8Mode$constants.SEGMENT.set(Py_UTF8Mode$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_UniversalNewlineFgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_UniversalNewlineFgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *Py_UniversalNewlineFgets(char *, int, FILE *, PyObject *)
     * }
     */
    public static FunctionDescriptor Py_UniversalNewlineFgets$descriptor() {
        return Py_UniversalNewlineFgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *Py_UniversalNewlineFgets(char *, int, FILE *, PyObject *)
     * }
     */
    public static MethodHandle Py_UniversalNewlineFgets$handle() {
        return Py_UniversalNewlineFgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *Py_UniversalNewlineFgets(char *, int, FILE *, PyObject *)
     * }
     */
    public static MemorySegment Py_UniversalNewlineFgets$address() {
        return Py_UniversalNewlineFgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *Py_UniversalNewlineFgets(char *, int, FILE *, PyObject *)
     * }
     */
    public static MemorySegment Py_UniversalNewlineFgets(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Py_UniversalNewlineFgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_UniversalNewlineFgets", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_NewStdPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_NewStdPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_NewStdPrinter(int)
     * }
     */
    public static FunctionDescriptor PyFile_NewStdPrinter$descriptor() {
        return PyFile_NewStdPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_NewStdPrinter(int)
     * }
     */
    public static MethodHandle PyFile_NewStdPrinter$handle() {
        return PyFile_NewStdPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_NewStdPrinter(int)
     * }
     */
    public static MemorySegment PyFile_NewStdPrinter$address() {
        return PyFile_NewStdPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_NewStdPrinter(int)
     * }
     */
    public static MemorySegment PyFile_NewStdPrinter(int x0) {
        var mh$ = PyFile_NewStdPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_NewStdPrinter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStdPrinter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyStdPrinter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStdPrinter_Type
     * }
     */
    public static GroupLayout PyStdPrinter_Type$layout() {
        return PyStdPrinter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStdPrinter_Type
     * }
     */
    public static MemorySegment PyStdPrinter_Type() {
        return PyStdPrinter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStdPrinter_Type
     * }
     */
    public static void PyStdPrinter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyStdPrinter_Type$constants.SEGMENT, 0L, PyStdPrinter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFile_OpenCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_OpenCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCode(const char *utf8path)
     * }
     */
    public static FunctionDescriptor PyFile_OpenCode$descriptor() {
        return PyFile_OpenCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCode(const char *utf8path)
     * }
     */
    public static MethodHandle PyFile_OpenCode$handle() {
        return PyFile_OpenCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCode(const char *utf8path)
     * }
     */
    public static MemorySegment PyFile_OpenCode$address() {
        return PyFile_OpenCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCode(const char *utf8path)
     * }
     */
    public static MemorySegment PyFile_OpenCode(MemorySegment utf8path) {
        var mh$ = PyFile_OpenCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_OpenCode", utf8path);
            }
            return (MemorySegment)mh$.invokeExact(utf8path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_OpenCodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_OpenCodeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCodeObject(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyFile_OpenCodeObject$descriptor() {
        return PyFile_OpenCodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCodeObject(PyObject *path)
     * }
     */
    public static MethodHandle PyFile_OpenCodeObject$handle() {
        return PyFile_OpenCodeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCodeObject(PyObject *path)
     * }
     */
    public static MemorySegment PyFile_OpenCodeObject$address() {
        return PyFile_OpenCodeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCodeObject(PyObject *path)
     * }
     */
    public static MemorySegment PyFile_OpenCodeObject(MemorySegment path) {
        var mh$ = PyFile_OpenCodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_OpenCodeObject", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_SetOpenCodeHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_SetOpenCodeHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, void *userData)
     * }
     */
    public static FunctionDescriptor PyFile_SetOpenCodeHook$descriptor() {
        return PyFile_SetOpenCodeHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, void *userData)
     * }
     */
    public static MethodHandle PyFile_SetOpenCodeHook$handle() {
        return PyFile_SetOpenCodeHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, void *userData)
     * }
     */
    public static MemorySegment PyFile_SetOpenCodeHook$address() {
        return PyFile_SetOpenCodeHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, void *userData)
     * }
     */
    public static int PyFile_SetOpenCodeHook(MemorySegment hook, MemorySegment userData) {
        var mh$ = PyFile_SetOpenCodeHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_SetOpenCodeHook", hook, userData);
            }
            return (int)mh$.invokeExact(hook, userData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCapsule_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCapsule_Type
     * }
     */
    public static GroupLayout PyCapsule_Type$layout() {
        return PyCapsule_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCapsule_Type
     * }
     */
    public static MemorySegment PyCapsule_Type() {
        return PyCapsule_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCapsule_Type
     * }
     */
    public static void PyCapsule_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCapsule_Type$constants.SEGMENT, 0L, PyCapsule_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCapsule_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static FunctionDescriptor PyCapsule_New$descriptor() {
        return PyCapsule_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static MethodHandle PyCapsule_New$handle() {
        return PyCapsule_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static MemorySegment PyCapsule_New$address() {
        return PyCapsule_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static MemorySegment PyCapsule_New(MemorySegment pointer, MemorySegment name, MemorySegment destructor) {
        var mh$ = PyCapsule_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_New", pointer, name, destructor);
            }
            return (MemorySegment)mh$.invokeExact(pointer, name, destructor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetPointer$descriptor() {
        return PyCapsule_GetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static MethodHandle PyCapsule_GetPointer$handle() {
        return PyCapsule_GetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_GetPointer$address() {
        return PyCapsule_GetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_GetPointer(MemorySegment capsule, MemorySegment name) {
        var mh$ = PyCapsule_GetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetPointer", capsule, name);
            }
            return (MemorySegment)mh$.invokeExact(capsule, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetDestructor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetDestructor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetDestructor$descriptor() {
        return PyCapsule_GetDestructor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static MethodHandle PyCapsule_GetDestructor$handle() {
        return PyCapsule_GetDestructor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetDestructor$address() {
        return PyCapsule_GetDestructor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetDestructor(MemorySegment capsule) {
        var mh$ = PyCapsule_GetDestructor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetDestructor", capsule);
            }
            return (MemorySegment)mh$.invokeExact(capsule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetName$descriptor() {
        return PyCapsule_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static MethodHandle PyCapsule_GetName$handle() {
        return PyCapsule_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetName$address() {
        return PyCapsule_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetName(MemorySegment capsule) {
        var mh$ = PyCapsule_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetName", capsule);
            }
            return (MemorySegment)mh$.invokeExact(capsule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetContext$descriptor() {
        return PyCapsule_GetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static MethodHandle PyCapsule_GetContext$handle() {
        return PyCapsule_GetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetContext$address() {
        return PyCapsule_GetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetContext(MemorySegment capsule) {
        var mh$ = PyCapsule_GetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetContext", capsule);
            }
            return (MemorySegment)mh$.invokeExact(capsule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_IsValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_IsValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static FunctionDescriptor PyCapsule_IsValid$descriptor() {
        return PyCapsule_IsValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static MethodHandle PyCapsule_IsValid$handle() {
        return PyCapsule_IsValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_IsValid$address() {
        return PyCapsule_IsValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static int PyCapsule_IsValid(MemorySegment capsule, MemorySegment name) {
        var mh$ = PyCapsule_IsValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_IsValid", capsule, name);
            }
            return (int)mh$.invokeExact(capsule, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetPointer$descriptor() {
        return PyCapsule_SetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static MethodHandle PyCapsule_SetPointer$handle() {
        return PyCapsule_SetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static MemorySegment PyCapsule_SetPointer$address() {
        return PyCapsule_SetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static int PyCapsule_SetPointer(MemorySegment capsule, MemorySegment pointer) {
        var mh$ = PyCapsule_SetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetPointer", capsule, pointer);
            }
            return (int)mh$.invokeExact(capsule, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetDestructor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetDestructor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetDestructor$descriptor() {
        return PyCapsule_SetDestructor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static MethodHandle PyCapsule_SetDestructor$handle() {
        return PyCapsule_SetDestructor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static MemorySegment PyCapsule_SetDestructor$address() {
        return PyCapsule_SetDestructor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static int PyCapsule_SetDestructor(MemorySegment capsule, MemorySegment destructor) {
        var mh$ = PyCapsule_SetDestructor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetDestructor", capsule, destructor);
            }
            return (int)mh$.invokeExact(capsule, destructor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetName$descriptor() {
        return PyCapsule_SetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static MethodHandle PyCapsule_SetName$handle() {
        return PyCapsule_SetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_SetName$address() {
        return PyCapsule_SetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static int PyCapsule_SetName(MemorySegment capsule, MemorySegment name) {
        var mh$ = PyCapsule_SetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetName", capsule, name);
            }
            return (int)mh$.invokeExact(capsule, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetContext$descriptor() {
        return PyCapsule_SetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static MethodHandle PyCapsule_SetContext$handle() {
        return PyCapsule_SetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static MemorySegment PyCapsule_SetContext$address() {
        return PyCapsule_SetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static int PyCapsule_SetContext(MemorySegment capsule, MemorySegment context) {
        var mh$ = PyCapsule_SetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetContext", capsule, context);
            }
            return (int)mh$.invokeExact(capsule, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_Import {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_Import");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static FunctionDescriptor PyCapsule_Import$descriptor() {
        return PyCapsule_Import.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static MethodHandle PyCapsule_Import$handle() {
        return PyCapsule_Import.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static MemorySegment PyCapsule_Import$address() {
        return PyCapsule_Import.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static MemorySegment PyCapsule_Import(MemorySegment name, int no_block) {
        var mh$ = PyCapsule_Import.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_Import", name, no_block);
            }
            return (MemorySegment)mh$.invokeExact(name, no_block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCode_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCode_Type
     * }
     */
    public static GroupLayout PyCode_Type$layout() {
        return PyCode_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCode_Type
     * }
     */
    public static MemorySegment PyCode_Type() {
        return PyCode_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCode_Type
     * }
     */
    public static void PyCode_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCode_Type$constants.SEGMENT, 0L, PyCode_Type$constants.LAYOUT.byteSize());
    }

    private static class PyUnstable_Code_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Code_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyUnstable_Code_New(int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnstable_Code_New$descriptor() {
        return PyUnstable_Code_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyUnstable_Code_New(int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyUnstable_Code_New$handle() {
        return PyUnstable_Code_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyUnstable_Code_New(int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyUnstable_Code_New$address() {
        return PyUnstable_Code_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyUnstable_Code_New(int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyUnstable_Code_New(int x0, int x1, int x2, int x3, int x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, int x14, MemorySegment x15, MemorySegment x16) {
        var mh$ = PyUnstable_Code_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Code_New", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Code_NewWithPosOnlyArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Code_NewWithPosOnlyArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyUnstable_Code_NewWithPosOnlyArgs(int, int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnstable_Code_NewWithPosOnlyArgs$descriptor() {
        return PyUnstable_Code_NewWithPosOnlyArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyUnstable_Code_NewWithPosOnlyArgs(int, int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyUnstable_Code_NewWithPosOnlyArgs$handle() {
        return PyUnstable_Code_NewWithPosOnlyArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyUnstable_Code_NewWithPosOnlyArgs(int, int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyUnstable_Code_NewWithPosOnlyArgs$address() {
        return PyUnstable_Code_NewWithPosOnlyArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyUnstable_Code_NewWithPosOnlyArgs(int, int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyUnstable_Code_NewWithPosOnlyArgs(int x0, int x1, int x2, int x3, int x4, int x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, MemorySegment x14, int x15, MemorySegment x16, MemorySegment x17) {
        var mh$ = PyUnstable_Code_NewWithPosOnlyArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Code_NewWithPosOnlyArgs", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_NewEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_NewEmpty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)
     * }
     */
    public static FunctionDescriptor PyCode_NewEmpty$descriptor() {
        return PyCode_NewEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)
     * }
     */
    public static MethodHandle PyCode_NewEmpty$handle() {
        return PyCode_NewEmpty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)
     * }
     */
    public static MemorySegment PyCode_NewEmpty$address() {
        return PyCode_NewEmpty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)
     * }
     */
    public static MemorySegment PyCode_NewEmpty(MemorySegment filename, MemorySegment funcname, int firstlineno) {
        var mh$ = PyCode_NewEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_NewEmpty", filename, funcname, firstlineno);
            }
            return (MemorySegment)mh$.invokeExact(filename, funcname, firstlineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_Addr2Line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_Addr2Line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCode_Addr2Line(PyCodeObject *, int)
     * }
     */
    public static FunctionDescriptor PyCode_Addr2Line$descriptor() {
        return PyCode_Addr2Line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCode_Addr2Line(PyCodeObject *, int)
     * }
     */
    public static MethodHandle PyCode_Addr2Line$handle() {
        return PyCode_Addr2Line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCode_Addr2Line(PyCodeObject *, int)
     * }
     */
    public static MemorySegment PyCode_Addr2Line$address() {
        return PyCode_Addr2Line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCode_Addr2Line(PyCodeObject *, int)
     * }
     */
    public static int PyCode_Addr2Line(MemorySegment x0, int x1) {
        var mh$ = PyCode_Addr2Line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_Addr2Line", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_Addr2Location {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_Addr2Location");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCode_Addr2Location(PyCodeObject *, int, int *, int *, int *, int *)
     * }
     */
    public static FunctionDescriptor PyCode_Addr2Location$descriptor() {
        return PyCode_Addr2Location.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCode_Addr2Location(PyCodeObject *, int, int *, int *, int *, int *)
     * }
     */
    public static MethodHandle PyCode_Addr2Location$handle() {
        return PyCode_Addr2Location.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCode_Addr2Location(PyCodeObject *, int, int *, int *, int *, int *)
     * }
     */
    public static MemorySegment PyCode_Addr2Location$address() {
        return PyCode_Addr2Location.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCode_Addr2Location(PyCodeObject *, int, int *, int *, int *, int *)
     * }
     */
    public static int PyCode_Addr2Location(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PyCode_Addr2Location.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_Addr2Location", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PY_CODE_EVENT_CREATE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PY_CODE_EVENT_CREATE = 0
     * }
     */
    public static int PY_CODE_EVENT_CREATE() {
        return PY_CODE_EVENT_CREATE;
    }
    private static final int PY_CODE_EVENT_DESTROY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PY_CODE_EVENT_DESTROY = 1
     * }
     */
    public static int PY_CODE_EVENT_DESTROY() {
        return PY_CODE_EVENT_DESTROY;
    }

    private static class PyCode_AddWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_AddWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCode_AddWatcher(PyCode_WatchCallback callback)
     * }
     */
    public static FunctionDescriptor PyCode_AddWatcher$descriptor() {
        return PyCode_AddWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCode_AddWatcher(PyCode_WatchCallback callback)
     * }
     */
    public static MethodHandle PyCode_AddWatcher$handle() {
        return PyCode_AddWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCode_AddWatcher(PyCode_WatchCallback callback)
     * }
     */
    public static MemorySegment PyCode_AddWatcher$address() {
        return PyCode_AddWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCode_AddWatcher(PyCode_WatchCallback callback)
     * }
     */
    public static int PyCode_AddWatcher(MemorySegment callback) {
        var mh$ = PyCode_AddWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_AddWatcher", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_ClearWatcher {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_ClearWatcher");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCode_ClearWatcher(int watcher_id)
     * }
     */
    public static FunctionDescriptor PyCode_ClearWatcher$descriptor() {
        return PyCode_ClearWatcher.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCode_ClearWatcher(int watcher_id)
     * }
     */
    public static MethodHandle PyCode_ClearWatcher$handle() {
        return PyCode_ClearWatcher.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCode_ClearWatcher(int watcher_id)
     * }
     */
    public static MemorySegment PyCode_ClearWatcher$address() {
        return PyCode_ClearWatcher.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCode_ClearWatcher(int watcher_id)
     * }
     */
    public static int PyCode_ClearWatcher(int watcher_id) {
        var mh$ = PyCode_ClearWatcher.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_ClearWatcher", watcher_id);
            }
            return (int)mh$.invokeExact(watcher_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCode_CheckLineNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCode_CheckLineNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange *bounds)
     * }
     */
    public static FunctionDescriptor _PyCode_CheckLineNumber$descriptor() {
        return _PyCode_CheckLineNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange *bounds)
     * }
     */
    public static MethodHandle _PyCode_CheckLineNumber$handle() {
        return _PyCode_CheckLineNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange *bounds)
     * }
     */
    public static MemorySegment _PyCode_CheckLineNumber$address() {
        return _PyCode_CheckLineNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange *bounds)
     * }
     */
    public static int _PyCode_CheckLineNumber(int lasti, MemorySegment bounds) {
        var mh$ = _PyCode_CheckLineNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCode_CheckLineNumber", lasti, bounds);
            }
            return (int)mh$.invokeExact(lasti, bounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCode_ConstantKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCode_ConstantKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyCode_ConstantKey(PyObject *obj)
     * }
     */
    public static FunctionDescriptor _PyCode_ConstantKey$descriptor() {
        return _PyCode_ConstantKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyCode_ConstantKey(PyObject *obj)
     * }
     */
    public static MethodHandle _PyCode_ConstantKey$handle() {
        return _PyCode_ConstantKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyCode_ConstantKey(PyObject *obj)
     * }
     */
    public static MemorySegment _PyCode_ConstantKey$address() {
        return _PyCode_ConstantKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyCode_ConstantKey(PyObject *obj)
     * }
     */
    public static MemorySegment _PyCode_ConstantKey(MemorySegment obj) {
        var mh$ = _PyCode_ConstantKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCode_ConstantKey", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_Optimize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_Optimize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_Optimize(PyObject *code, PyObject *consts, PyObject *names, PyObject *lnotab)
     * }
     */
    public static FunctionDescriptor PyCode_Optimize$descriptor() {
        return PyCode_Optimize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_Optimize(PyObject *code, PyObject *consts, PyObject *names, PyObject *lnotab)
     * }
     */
    public static MethodHandle PyCode_Optimize$handle() {
        return PyCode_Optimize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_Optimize(PyObject *code, PyObject *consts, PyObject *names, PyObject *lnotab)
     * }
     */
    public static MemorySegment PyCode_Optimize$address() {
        return PyCode_Optimize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_Optimize(PyObject *code, PyObject *consts, PyObject *names, PyObject *lnotab)
     * }
     */
    public static MemorySegment PyCode_Optimize(MemorySegment code, MemorySegment consts, MemorySegment names, MemorySegment lnotab) {
        var mh$ = PyCode_Optimize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_Optimize", code, consts, names, lnotab);
            }
            return (MemorySegment)mh$.invokeExact(code, consts, names, lnotab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Code_GetExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Code_GetExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_Code_GetExtra(PyObject *code, Py_ssize_t index, void **extra)
     * }
     */
    public static FunctionDescriptor PyUnstable_Code_GetExtra$descriptor() {
        return PyUnstable_Code_GetExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_Code_GetExtra(PyObject *code, Py_ssize_t index, void **extra)
     * }
     */
    public static MethodHandle PyUnstable_Code_GetExtra$handle() {
        return PyUnstable_Code_GetExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_Code_GetExtra(PyObject *code, Py_ssize_t index, void **extra)
     * }
     */
    public static MemorySegment PyUnstable_Code_GetExtra$address() {
        return PyUnstable_Code_GetExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_Code_GetExtra(PyObject *code, Py_ssize_t index, void **extra)
     * }
     */
    public static int PyUnstable_Code_GetExtra(MemorySegment code, long index, MemorySegment extra) {
        var mh$ = PyUnstable_Code_GetExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Code_GetExtra", code, index, extra);
            }
            return (int)mh$.invokeExact(code, index, extra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Code_SetExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Code_SetExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_Code_SetExtra(PyObject *code, Py_ssize_t index, void *extra)
     * }
     */
    public static FunctionDescriptor PyUnstable_Code_SetExtra$descriptor() {
        return PyUnstable_Code_SetExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_Code_SetExtra(PyObject *code, Py_ssize_t index, void *extra)
     * }
     */
    public static MethodHandle PyUnstable_Code_SetExtra$handle() {
        return PyUnstable_Code_SetExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_Code_SetExtra(PyObject *code, Py_ssize_t index, void *extra)
     * }
     */
    public static MemorySegment PyUnstable_Code_SetExtra$address() {
        return PyUnstable_Code_SetExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_Code_SetExtra(PyObject *code, Py_ssize_t index, void *extra)
     * }
     */
    public static int PyUnstable_Code_SetExtra(MemorySegment code, long index, MemorySegment extra) {
        var mh$ = PyUnstable_Code_SetExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Code_SetExtra", code, index, extra);
            }
            return (int)mh$.invokeExact(code, index, extra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_GetCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_GetCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCode(PyCodeObject *code)
     * }
     */
    public static FunctionDescriptor PyCode_GetCode$descriptor() {
        return PyCode_GetCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCode(PyCodeObject *code)
     * }
     */
    public static MethodHandle PyCode_GetCode$handle() {
        return PyCode_GetCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCode(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetCode$address() {
        return PyCode_GetCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_GetCode(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetCode(MemorySegment code) {
        var mh$ = PyCode_GetCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_GetCode", code);
            }
            return (MemorySegment)mh$.invokeExact(code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_GetVarnames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_GetVarnames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetVarnames(PyCodeObject *code)
     * }
     */
    public static FunctionDescriptor PyCode_GetVarnames$descriptor() {
        return PyCode_GetVarnames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetVarnames(PyCodeObject *code)
     * }
     */
    public static MethodHandle PyCode_GetVarnames$handle() {
        return PyCode_GetVarnames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetVarnames(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetVarnames$address() {
        return PyCode_GetVarnames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_GetVarnames(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetVarnames(MemorySegment code) {
        var mh$ = PyCode_GetVarnames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_GetVarnames", code);
            }
            return (MemorySegment)mh$.invokeExact(code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_GetCellvars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_GetCellvars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCellvars(PyCodeObject *code)
     * }
     */
    public static FunctionDescriptor PyCode_GetCellvars$descriptor() {
        return PyCode_GetCellvars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCellvars(PyCodeObject *code)
     * }
     */
    public static MethodHandle PyCode_GetCellvars$handle() {
        return PyCode_GetCellvars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCellvars(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetCellvars$address() {
        return PyCode_GetCellvars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_GetCellvars(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetCellvars(MemorySegment code) {
        var mh$ = PyCode_GetCellvars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_GetCellvars", code);
            }
            return (MemorySegment)mh$.invokeExact(code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_GetFreevars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_GetFreevars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetFreevars(PyCodeObject *code)
     * }
     */
    public static FunctionDescriptor PyCode_GetFreevars$descriptor() {
        return PyCode_GetFreevars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetFreevars(PyCodeObject *code)
     * }
     */
    public static MethodHandle PyCode_GetFreevars$handle() {
        return PyCode_GetFreevars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetFreevars(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetFreevars$address() {
        return PyCode_GetFreevars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_GetFreevars(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetFreevars(MemorySegment code) {
        var mh$ = PyCode_GetFreevars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_GetFreevars", code);
            }
            return (MemorySegment)mh$.invokeExact(code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PY_CODE_LOCATION_INFO_SHORT0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_SHORT0 = 0
     * }
     */
    public static int PY_CODE_LOCATION_INFO_SHORT0() {
        return PY_CODE_LOCATION_INFO_SHORT0;
    }
    private static final int PY_CODE_LOCATION_INFO_ONE_LINE0 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_ONE_LINE0 = 10
     * }
     */
    public static int PY_CODE_LOCATION_INFO_ONE_LINE0() {
        return PY_CODE_LOCATION_INFO_ONE_LINE0;
    }
    private static final int PY_CODE_LOCATION_INFO_ONE_LINE1 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_ONE_LINE1 = 11
     * }
     */
    public static int PY_CODE_LOCATION_INFO_ONE_LINE1() {
        return PY_CODE_LOCATION_INFO_ONE_LINE1;
    }
    private static final int PY_CODE_LOCATION_INFO_ONE_LINE2 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_ONE_LINE2 = 12
     * }
     */
    public static int PY_CODE_LOCATION_INFO_ONE_LINE2() {
        return PY_CODE_LOCATION_INFO_ONE_LINE2;
    }
    private static final int PY_CODE_LOCATION_INFO_NO_COLUMNS = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_NO_COLUMNS = 13
     * }
     */
    public static int PY_CODE_LOCATION_INFO_NO_COLUMNS() {
        return PY_CODE_LOCATION_INFO_NO_COLUMNS;
    }
    private static final int PY_CODE_LOCATION_INFO_LONG = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_LONG = 14
     * }
     */
    public static int PY_CODE_LOCATION_INFO_LONG() {
        return PY_CODE_LOCATION_INFO_LONG;
    }
    private static final int PY_CODE_LOCATION_INFO_NONE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_NONE = 15
     * }
     */
    public static int PY_CODE_LOCATION_INFO_NONE() {
        return PY_CODE_LOCATION_INFO_NONE;
    }

    private static class PyFrame_GetLineNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetLineNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyFrame_GetLineNumber$descriptor() {
        return PyFrame_GetLineNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static MethodHandle PyFrame_GetLineNumber$handle() {
        return PyFrame_GetLineNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static MemorySegment PyFrame_GetLineNumber$address() {
        return PyFrame_GetLineNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static int PyFrame_GetLineNumber(MemorySegment x0) {
        var mh$ = PyFrame_GetLineNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetLineNumber", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetCode$descriptor() {
        return PyFrame_GetCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetCode$handle() {
        return PyFrame_GetCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetCode$address() {
        return PyFrame_GetCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetCode(MemorySegment frame) {
        var mh$ = PyFrame_GetCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetCode", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFrame_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrame_Type
     * }
     */
    public static GroupLayout PyFrame_Type$layout() {
        return PyFrame_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrame_Type
     * }
     */
    public static MemorySegment PyFrame_Type() {
        return PyFrame_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrame_Type
     * }
     */
    public static void PyFrame_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFrame_Type$constants.SEGMENT, 0L, PyFrame_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFrameLocalsProxy_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFrameLocalsProxy_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrameLocalsProxy_Type
     * }
     */
    public static GroupLayout PyFrameLocalsProxy_Type$layout() {
        return PyFrameLocalsProxy_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrameLocalsProxy_Type
     * }
     */
    public static MemorySegment PyFrameLocalsProxy_Type() {
        return PyFrameLocalsProxy_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrameLocalsProxy_Type
     * }
     */
    public static void PyFrameLocalsProxy_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFrameLocalsProxy_Type$constants.SEGMENT, 0L, PyFrameLocalsProxy_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFrame_GetBack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetBack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyFrameObject *PyFrame_GetBack(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetBack$descriptor() {
        return PyFrame_GetBack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyFrameObject *PyFrame_GetBack(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetBack$handle() {
        return PyFrame_GetBack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyFrameObject *PyFrame_GetBack(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetBack$address() {
        return PyFrame_GetBack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyFrameObject *PyFrame_GetBack(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetBack(MemorySegment frame) {
        var mh$ = PyFrame_GetBack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetBack", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetLocals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetLocals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetLocals(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetLocals$descriptor() {
        return PyFrame_GetLocals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetLocals(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetLocals$handle() {
        return PyFrame_GetLocals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetLocals(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetLocals$address() {
        return PyFrame_GetLocals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetLocals(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetLocals(MemorySegment frame) {
        var mh$ = PyFrame_GetLocals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetLocals", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetGlobals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetGlobals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGlobals(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetGlobals$descriptor() {
        return PyFrame_GetGlobals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGlobals(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetGlobals$handle() {
        return PyFrame_GetGlobals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGlobals(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetGlobals$address() {
        return PyFrame_GetGlobals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGlobals(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetGlobals(MemorySegment frame) {
        var mh$ = PyFrame_GetGlobals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetGlobals", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetBuiltins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetBuiltins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetBuiltins(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetBuiltins$descriptor() {
        return PyFrame_GetBuiltins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetBuiltins(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetBuiltins$handle() {
        return PyFrame_GetBuiltins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetBuiltins(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetBuiltins$address() {
        return PyFrame_GetBuiltins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetBuiltins(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetBuiltins(MemorySegment frame) {
        var mh$ = PyFrame_GetBuiltins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetBuiltins", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetGenerator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetGenerator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGenerator(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetGenerator$descriptor() {
        return PyFrame_GetGenerator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGenerator(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetGenerator$handle() {
        return PyFrame_GetGenerator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGenerator(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetGenerator$address() {
        return PyFrame_GetGenerator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGenerator(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetGenerator(MemorySegment frame) {
        var mh$ = PyFrame_GetGenerator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetGenerator", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetLasti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetLasti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFrame_GetLasti(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetLasti$descriptor() {
        return PyFrame_GetLasti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFrame_GetLasti(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetLasti$handle() {
        return PyFrame_GetLasti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFrame_GetLasti(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetLasti$address() {
        return PyFrame_GetLasti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFrame_GetLasti(PyFrameObject *frame)
     * }
     */
    public static int PyFrame_GetLasti(MemorySegment frame) {
        var mh$ = PyFrame_GetLasti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetLasti", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetVar(PyFrameObject *frame, PyObject *name)
     * }
     */
    public static FunctionDescriptor PyFrame_GetVar$descriptor() {
        return PyFrame_GetVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetVar(PyFrameObject *frame, PyObject *name)
     * }
     */
    public static MethodHandle PyFrame_GetVar$handle() {
        return PyFrame_GetVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetVar(PyFrameObject *frame, PyObject *name)
     * }
     */
    public static MemorySegment PyFrame_GetVar$address() {
        return PyFrame_GetVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetVar(PyFrameObject *frame, PyObject *name)
     * }
     */
    public static MemorySegment PyFrame_GetVar(MemorySegment frame, MemorySegment name) {
        var mh$ = PyFrame_GetVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetVar", frame, name);
            }
            return (MemorySegment)mh$.invokeExact(frame, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetVarString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetVarString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetVarString(PyFrameObject *frame, const char *name)
     * }
     */
    public static FunctionDescriptor PyFrame_GetVarString$descriptor() {
        return PyFrame_GetVarString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetVarString(PyFrameObject *frame, const char *name)
     * }
     */
    public static MethodHandle PyFrame_GetVarString$handle() {
        return PyFrame_GetVarString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetVarString(PyFrameObject *frame, const char *name)
     * }
     */
    public static MemorySegment PyFrame_GetVarString$address() {
        return PyFrame_GetVarString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetVarString(PyFrameObject *frame, const char *name)
     * }
     */
    public static MemorySegment PyFrame_GetVarString(MemorySegment frame, MemorySegment name) {
        var mh$ = PyFrame_GetVarString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetVarString", frame, name);
            }
            return (MemorySegment)mh$.invokeExact(frame, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_InterpreterFrame_GetCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_InterpreterFrame_GetCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_InterpreterFrame_GetCode(struct _PyInterpreterFrame *frame)
     * }
     */
    public static FunctionDescriptor PyUnstable_InterpreterFrame_GetCode$descriptor() {
        return PyUnstable_InterpreterFrame_GetCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_InterpreterFrame_GetCode(struct _PyInterpreterFrame *frame)
     * }
     */
    public static MethodHandle PyUnstable_InterpreterFrame_GetCode$handle() {
        return PyUnstable_InterpreterFrame_GetCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_InterpreterFrame_GetCode(struct _PyInterpreterFrame *frame)
     * }
     */
    public static MemorySegment PyUnstable_InterpreterFrame_GetCode$address() {
        return PyUnstable_InterpreterFrame_GetCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnstable_InterpreterFrame_GetCode(struct _PyInterpreterFrame *frame)
     * }
     */
    public static MemorySegment PyUnstable_InterpreterFrame_GetCode(MemorySegment frame) {
        var mh$ = PyUnstable_InterpreterFrame_GetCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_InterpreterFrame_GetCode", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_InterpreterFrame_GetLasti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_InterpreterFrame_GetLasti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_InterpreterFrame_GetLasti(struct _PyInterpreterFrame *frame)
     * }
     */
    public static FunctionDescriptor PyUnstable_InterpreterFrame_GetLasti$descriptor() {
        return PyUnstable_InterpreterFrame_GetLasti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_InterpreterFrame_GetLasti(struct _PyInterpreterFrame *frame)
     * }
     */
    public static MethodHandle PyUnstable_InterpreterFrame_GetLasti$handle() {
        return PyUnstable_InterpreterFrame_GetLasti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_InterpreterFrame_GetLasti(struct _PyInterpreterFrame *frame)
     * }
     */
    public static MemorySegment PyUnstable_InterpreterFrame_GetLasti$address() {
        return PyUnstable_InterpreterFrame_GetLasti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_InterpreterFrame_GetLasti(struct _PyInterpreterFrame *frame)
     * }
     */
    public static int PyUnstable_InterpreterFrame_GetLasti(MemorySegment frame) {
        var mh$ = PyUnstable_InterpreterFrame_GetLasti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_InterpreterFrame_GetLasti", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_InterpreterFrame_GetLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_InterpreterFrame_GetLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_InterpreterFrame_GetLine(struct _PyInterpreterFrame *frame)
     * }
     */
    public static FunctionDescriptor PyUnstable_InterpreterFrame_GetLine$descriptor() {
        return PyUnstable_InterpreterFrame_GetLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_InterpreterFrame_GetLine(struct _PyInterpreterFrame *frame)
     * }
     */
    public static MethodHandle PyUnstable_InterpreterFrame_GetLine$handle() {
        return PyUnstable_InterpreterFrame_GetLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_InterpreterFrame_GetLine(struct _PyInterpreterFrame *frame)
     * }
     */
    public static MemorySegment PyUnstable_InterpreterFrame_GetLine$address() {
        return PyUnstable_InterpreterFrame_GetLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_InterpreterFrame_GetLine(struct _PyInterpreterFrame *frame)
     * }
     */
    public static int PyUnstable_InterpreterFrame_GetLine(MemorySegment frame) {
        var mh$ = PyUnstable_InterpreterFrame_GetLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_InterpreterFrame_GetLine", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_ExecutableKinds$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(6, Python_h.C_POINTER);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyUnstable_ExecutableKinds").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 6 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const PyTypeObject *const PyUnstable_ExecutableKinds[6]
     * }
     */
    public static SequenceLayout PyUnstable_ExecutableKinds$layout() {
        return PyUnstable_ExecutableKinds$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const PyTypeObject *const PyUnstable_ExecutableKinds[6]
     * }
     */
    public static long[] PyUnstable_ExecutableKinds$dimensions() {
        return PyUnstable_ExecutableKinds$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const PyTypeObject *const PyUnstable_ExecutableKinds[6]
     * }
     */
    public static MemorySegment PyUnstable_ExecutableKinds() {
        return PyUnstable_ExecutableKinds$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const PyTypeObject *const PyUnstable_ExecutableKinds[6]
     * }
     */
    public static void PyUnstable_ExecutableKinds(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyUnstable_ExecutableKinds$constants.SEGMENT, 0L, PyUnstable_ExecutableKinds$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern const PyTypeObject *const PyUnstable_ExecutableKinds[6]
     * }
     */
    public static MemorySegment PyUnstable_ExecutableKinds(long index0) {
        return (MemorySegment)PyUnstable_ExecutableKinds$constants.HANDLE.get(PyUnstable_ExecutableKinds$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern const PyTypeObject *const PyUnstable_ExecutableKinds[6]
     * }
     */
    public static void PyUnstable_ExecutableKinds(long index0, MemorySegment varValue) {
        PyUnstable_ExecutableKinds$constants.HANDLE.set(PyUnstable_ExecutableKinds$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class PyTraceBack_Here {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTraceBack_Here");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyTraceBack_Here$descriptor() {
        return PyTraceBack_Here.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static MethodHandle PyTraceBack_Here$handle() {
        return PyTraceBack_Here.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static MemorySegment PyTraceBack_Here$address() {
        return PyTraceBack_Here.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static int PyTraceBack_Here(MemorySegment x0) {
        var mh$ = PyTraceBack_Here.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTraceBack_Here", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceBack_Print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTraceBack_Print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyTraceBack_Print$descriptor() {
        return PyTraceBack_Print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyTraceBack_Print$handle() {
        return PyTraceBack_Print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyTraceBack_Print$address() {
        return PyTraceBack_Print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static int PyTraceBack_Print(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyTraceBack_Print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTraceBack_Print", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceBack_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyTraceBack_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTraceBack_Type
     * }
     */
    public static GroupLayout PyTraceBack_Type$layout() {
        return PyTraceBack_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTraceBack_Type
     * }
     */
    public static MemorySegment PyTraceBack_Type() {
        return PyTraceBack_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTraceBack_Type
     * }
     */
    public static void PyTraceBack_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyTraceBack_Type$constants.SEGMENT, 0L, PyTraceBack_Type$constants.LAYOUT.byteSize());
    }

    private static class _Py_EllipsisObject$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_EllipsisObject").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_EllipsisObject
     * }
     */
    public static GroupLayout _Py_EllipsisObject$layout() {
        return _Py_EllipsisObject$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_EllipsisObject
     * }
     */
    public static MemorySegment _Py_EllipsisObject() {
        return _Py_EllipsisObject$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_EllipsisObject
     * }
     */
    public static void _Py_EllipsisObject(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_EllipsisObject$constants.SEGMENT, 0L, _Py_EllipsisObject$constants.LAYOUT.byteSize());
    }

    private static class PySlice_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySlice_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySlice_Type
     * }
     */
    public static GroupLayout PySlice_Type$layout() {
        return PySlice_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySlice_Type
     * }
     */
    public static MemorySegment PySlice_Type() {
        return PySlice_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySlice_Type
     * }
     */
    public static void PySlice_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySlice_Type$constants.SEGMENT, 0L, PySlice_Type$constants.LAYOUT.byteSize());
    }

    private static class PyEllipsis_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyEllipsis_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEllipsis_Type
     * }
     */
    public static GroupLayout PyEllipsis_Type$layout() {
        return PyEllipsis_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEllipsis_Type
     * }
     */
    public static MemorySegment PyEllipsis_Type() {
        return PyEllipsis_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEllipsis_Type
     * }
     */
    public static void PyEllipsis_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyEllipsis_Type$constants.SEGMENT, 0L, PyEllipsis_Type$constants.LAYOUT.byteSize());
    }

    private static class PySlice_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static FunctionDescriptor PySlice_New$descriptor() {
        return PySlice_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static MethodHandle PySlice_New$handle() {
        return PySlice_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static MemorySegment PySlice_New$address() {
        return PySlice_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static MemorySegment PySlice_New(MemorySegment start, MemorySegment stop, MemorySegment step) {
        var mh$ = PySlice_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_New", start, stop, step);
            }
            return (MemorySegment)mh$.invokeExact(start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySlice_FromIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySlice_FromIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop)
     * }
     */
    public static FunctionDescriptor _PySlice_FromIndices$descriptor() {
        return _PySlice_FromIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop)
     * }
     */
    public static MethodHandle _PySlice_FromIndices$handle() {
        return _PySlice_FromIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop)
     * }
     */
    public static MemorySegment _PySlice_FromIndices$address() {
        return _PySlice_FromIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop)
     * }
     */
    public static MemorySegment _PySlice_FromIndices(long start, long stop) {
        var mh$ = _PySlice_FromIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySlice_FromIndices", start, stop);
            }
            return (MemorySegment)mh$.invokeExact(start, stop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySlice_GetLongIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySlice_GetLongIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PySlice_GetLongIndices(PySliceObject *self, PyObject *length, PyObject **start_ptr, PyObject **stop_ptr, PyObject **step_ptr)
     * }
     */
    public static FunctionDescriptor _PySlice_GetLongIndices$descriptor() {
        return _PySlice_GetLongIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PySlice_GetLongIndices(PySliceObject *self, PyObject *length, PyObject **start_ptr, PyObject **stop_ptr, PyObject **step_ptr)
     * }
     */
    public static MethodHandle _PySlice_GetLongIndices$handle() {
        return _PySlice_GetLongIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PySlice_GetLongIndices(PySliceObject *self, PyObject *length, PyObject **start_ptr, PyObject **stop_ptr, PyObject **step_ptr)
     * }
     */
    public static MemorySegment _PySlice_GetLongIndices$address() {
        return _PySlice_GetLongIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PySlice_GetLongIndices(PySliceObject *self, PyObject *length, PyObject **start_ptr, PyObject **stop_ptr, PyObject **step_ptr)
     * }
     */
    public static int _PySlice_GetLongIndices(MemorySegment self, MemorySegment length, MemorySegment start_ptr, MemorySegment stop_ptr, MemorySegment step_ptr) {
        var mh$ = _PySlice_GetLongIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySlice_GetLongIndices", self, length, start_ptr, stop_ptr, step_ptr);
            }
            return (int)mh$.invokeExact(self, length, start_ptr, stop_ptr, step_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_GetIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_GetIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static FunctionDescriptor PySlice_GetIndices$descriptor() {
        return PySlice_GetIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MethodHandle PySlice_GetIndices$handle() {
        return PySlice_GetIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MemorySegment PySlice_GetIndices$address() {
        return PySlice_GetIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static int PySlice_GetIndices(MemorySegment r, long length, MemorySegment start, MemorySegment stop, MemorySegment step) {
        var mh$ = PySlice_GetIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_GetIndices", r, length, start, stop, step);
            }
            return (int)mh$.invokeExact(r, length, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_GetIndicesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_GetIndicesEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static FunctionDescriptor PySlice_GetIndicesEx$descriptor() {
        return PySlice_GetIndicesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static MethodHandle PySlice_GetIndicesEx$handle() {
        return PySlice_GetIndicesEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static MemorySegment PySlice_GetIndicesEx$address() {
        return PySlice_GetIndicesEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static int PySlice_GetIndicesEx(MemorySegment r, long length, MemorySegment start, MemorySegment stop, MemorySegment step, MemorySegment slicelength) {
        var mh$ = PySlice_GetIndicesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_GetIndicesEx", r, length, start, stop, step, slicelength);
            }
            return (int)mh$.invokeExact(r, length, start, stop, step, slicelength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_Unpack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_Unpack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static FunctionDescriptor PySlice_Unpack$descriptor() {
        return PySlice_Unpack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MethodHandle PySlice_Unpack$handle() {
        return PySlice_Unpack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MemorySegment PySlice_Unpack$address() {
        return PySlice_Unpack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static int PySlice_Unpack(MemorySegment slice, MemorySegment start, MemorySegment stop, MemorySegment step) {
        var mh$ = PySlice_Unpack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_Unpack", slice, start, stop, step);
            }
            return (int)mh$.invokeExact(slice, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_AdjustIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_AdjustIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static FunctionDescriptor PySlice_AdjustIndices$descriptor() {
        return PySlice_AdjustIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static MethodHandle PySlice_AdjustIndices$handle() {
        return PySlice_AdjustIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static MemorySegment PySlice_AdjustIndices$address() {
        return PySlice_AdjustIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static long PySlice_AdjustIndices(long length, MemorySegment start, MemorySegment stop, long step) {
        var mh$ = PySlice_AdjustIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_AdjustIndices", length, start, stop, step);
            }
            return (long)mh$.invokeExact(length, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCell_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCell_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCell_Type
     * }
     */
    public static GroupLayout PyCell_Type$layout() {
        return PyCell_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCell_Type
     * }
     */
    public static MemorySegment PyCell_Type() {
        return PyCell_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCell_Type
     * }
     */
    public static void PyCell_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCell_Type$constants.SEGMENT, 0L, PyCell_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCell_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCell_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCell_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCell_New$descriptor() {
        return PyCell_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCell_New(PyObject *)
     * }
     */
    public static MethodHandle PyCell_New$handle() {
        return PyCell_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCell_New(PyObject *)
     * }
     */
    public static MemorySegment PyCell_New$address() {
        return PyCell_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCell_New(PyObject *)
     * }
     */
    public static MemorySegment PyCell_New(MemorySegment x0) {
        var mh$ = PyCell_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCell_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCell_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCell_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCell_Get(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCell_Get$descriptor() {
        return PyCell_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCell_Get(PyObject *)
     * }
     */
    public static MethodHandle PyCell_Get$handle() {
        return PyCell_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCell_Get(PyObject *)
     * }
     */
    public static MemorySegment PyCell_Get$address() {
        return PyCell_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCell_Get(PyObject *)
     * }
     */
    public static MemorySegment PyCell_Get(MemorySegment x0) {
        var mh$ = PyCell_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCell_Get", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCell_Set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCell_Set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCell_Set(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCell_Set$descriptor() {
        return PyCell_Set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCell_Set(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCell_Set$handle() {
        return PyCell_Set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCell_Set(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCell_Set$address() {
        return PyCell_Set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCell_Set(PyObject *, PyObject *)
     * }
     */
    public static int PyCell_Set(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyCell_Set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCell_Set", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySeqIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySeqIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySeqIter_Type
     * }
     */
    public static GroupLayout PySeqIter_Type$layout() {
        return PySeqIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySeqIter_Type
     * }
     */
    public static MemorySegment PySeqIter_Type() {
        return PySeqIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySeqIter_Type
     * }
     */
    public static void PySeqIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySeqIter_Type$constants.SEGMENT, 0L, PySeqIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCallIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCallIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCallIter_Type
     * }
     */
    public static GroupLayout PyCallIter_Type$layout() {
        return PyCallIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCallIter_Type
     * }
     */
    public static MemorySegment PyCallIter_Type() {
        return PyCallIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCallIter_Type
     * }
     */
    public static void PyCallIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCallIter_Type$constants.SEGMENT, 0L, PyCallIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PySeqIter_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySeqIter_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PySeqIter_New$descriptor() {
        return PySeqIter_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static MethodHandle PySeqIter_New$handle() {
        return PySeqIter_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static MemorySegment PySeqIter_New$address() {
        return PySeqIter_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static MemorySegment PySeqIter_New(MemorySegment x0) {
        var mh$ = PySeqIter_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySeqIter_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCallIter_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCallIter_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCallIter_New$descriptor() {
        return PyCallIter_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCallIter_New$handle() {
        return PyCallIter_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCallIter_New$address() {
        return PyCallIter_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCallIter_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyCallIter_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCallIter_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _PyStatus_TYPE_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyStatus_TYPE_OK = 0
     * }
     */
    public static int _PyStatus_TYPE_OK() {
        return _PyStatus_TYPE_OK;
    }
    private static final int _PyStatus_TYPE_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyStatus_TYPE_ERROR = 1
     * }
     */
    public static int _PyStatus_TYPE_ERROR() {
        return _PyStatus_TYPE_ERROR;
    }
    private static final int _PyStatus_TYPE_EXIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyStatus_TYPE_EXIT = 2
     * }
     */
    public static int _PyStatus_TYPE_EXIT() {
        return _PyStatus_TYPE_EXIT;
    }

    private static class PyStatus_Ok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout()    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_Ok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Ok()
     * }
     */
    public static FunctionDescriptor PyStatus_Ok$descriptor() {
        return PyStatus_Ok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Ok()
     * }
     */
    public static MethodHandle PyStatus_Ok$handle() {
        return PyStatus_Ok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Ok()
     * }
     */
    public static MemorySegment PyStatus_Ok$address() {
        return PyStatus_Ok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyStatus_Ok()
     * }
     */
    public static MemorySegment PyStatus_Ok(SegmentAllocator allocator) {
        var mh$ = PyStatus_Ok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_Ok", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_Error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_Error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Error(const char *err_msg)
     * }
     */
    public static FunctionDescriptor PyStatus_Error$descriptor() {
        return PyStatus_Error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Error(const char *err_msg)
     * }
     */
    public static MethodHandle PyStatus_Error$handle() {
        return PyStatus_Error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Error(const char *err_msg)
     * }
     */
    public static MemorySegment PyStatus_Error$address() {
        return PyStatus_Error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyStatus_Error(const char *err_msg)
     * }
     */
    public static MemorySegment PyStatus_Error(SegmentAllocator allocator, MemorySegment err_msg) {
        var mh$ = PyStatus_Error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_Error", allocator, err_msg);
            }
            return (MemorySegment)mh$.invokeExact(allocator, err_msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_NoMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout()    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_NoMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyStatus_NoMemory()
     * }
     */
    public static FunctionDescriptor PyStatus_NoMemory$descriptor() {
        return PyStatus_NoMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyStatus_NoMemory()
     * }
     */
    public static MethodHandle PyStatus_NoMemory$handle() {
        return PyStatus_NoMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyStatus_NoMemory()
     * }
     */
    public static MemorySegment PyStatus_NoMemory$address() {
        return PyStatus_NoMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyStatus_NoMemory()
     * }
     */
    public static MemorySegment PyStatus_NoMemory(SegmentAllocator allocator) {
        var mh$ = PyStatus_NoMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_NoMemory", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Exit(int exitcode)
     * }
     */
    public static FunctionDescriptor PyStatus_Exit$descriptor() {
        return PyStatus_Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Exit(int exitcode)
     * }
     */
    public static MethodHandle PyStatus_Exit$handle() {
        return PyStatus_Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Exit(int exitcode)
     * }
     */
    public static MemorySegment PyStatus_Exit$address() {
        return PyStatus_Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyStatus_Exit(int exitcode)
     * }
     */
    public static MemorySegment PyStatus_Exit(SegmentAllocator allocator, int exitcode) {
        var mh$ = PyStatus_Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_Exit", allocator, exitcode);
            }
            return (MemorySegment)mh$.invokeExact(allocator, exitcode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_IsError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            PyStatus.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_IsError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyStatus_IsError(PyStatus err)
     * }
     */
    public static FunctionDescriptor PyStatus_IsError$descriptor() {
        return PyStatus_IsError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyStatus_IsError(PyStatus err)
     * }
     */
    public static MethodHandle PyStatus_IsError$handle() {
        return PyStatus_IsError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyStatus_IsError(PyStatus err)
     * }
     */
    public static MemorySegment PyStatus_IsError$address() {
        return PyStatus_IsError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyStatus_IsError(PyStatus err)
     * }
     */
    public static int PyStatus_IsError(MemorySegment err) {
        var mh$ = PyStatus_IsError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_IsError", err);
            }
            return (int)mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_IsExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            PyStatus.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_IsExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyStatus_IsExit(PyStatus err)
     * }
     */
    public static FunctionDescriptor PyStatus_IsExit$descriptor() {
        return PyStatus_IsExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyStatus_IsExit(PyStatus err)
     * }
     */
    public static MethodHandle PyStatus_IsExit$handle() {
        return PyStatus_IsExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyStatus_IsExit(PyStatus err)
     * }
     */
    public static MemorySegment PyStatus_IsExit$address() {
        return PyStatus_IsExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyStatus_IsExit(PyStatus err)
     * }
     */
    public static int PyStatus_IsExit(MemorySegment err) {
        var mh$ = PyStatus_IsExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_IsExit", err);
            }
            return (int)mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_Exception {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            PyStatus.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_Exception");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyStatus_Exception(PyStatus err)
     * }
     */
    public static FunctionDescriptor PyStatus_Exception$descriptor() {
        return PyStatus_Exception.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyStatus_Exception(PyStatus err)
     * }
     */
    public static MethodHandle PyStatus_Exception$handle() {
        return PyStatus_Exception.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyStatus_Exception(PyStatus err)
     * }
     */
    public static MemorySegment PyStatus_Exception$address() {
        return PyStatus_Exception.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyStatus_Exception(PyStatus err)
     * }
     */
    public static int PyStatus_Exception(MemorySegment err) {
        var mh$ = PyStatus_Exception.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_Exception", err);
            }
            return (int)mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWideStringList_Append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWideStringList_Append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t *item)
     * }
     */
    public static FunctionDescriptor PyWideStringList_Append$descriptor() {
        return PyWideStringList_Append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t *item)
     * }
     */
    public static MethodHandle PyWideStringList_Append$handle() {
        return PyWideStringList_Append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t *item)
     * }
     */
    public static MemorySegment PyWideStringList_Append$address() {
        return PyWideStringList_Append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t *item)
     * }
     */
    public static MemorySegment PyWideStringList_Append(SegmentAllocator allocator, MemorySegment list, MemorySegment item) {
        var mh$ = PyWideStringList_Append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWideStringList_Append", allocator, list, item);
            }
            return (MemorySegment)mh$.invokeExact(allocator, list, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWideStringList_Insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWideStringList_Insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t index, const wchar_t *item)
     * }
     */
    public static FunctionDescriptor PyWideStringList_Insert$descriptor() {
        return PyWideStringList_Insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t index, const wchar_t *item)
     * }
     */
    public static MethodHandle PyWideStringList_Insert$handle() {
        return PyWideStringList_Insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t index, const wchar_t *item)
     * }
     */
    public static MemorySegment PyWideStringList_Insert$address() {
        return PyWideStringList_Insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t index, const wchar_t *item)
     * }
     */
    public static MemorySegment PyWideStringList_Insert(SegmentAllocator allocator, MemorySegment list, long index, MemorySegment item) {
        var mh$ = PyWideStringList_Insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWideStringList_Insert", allocator, list, index, item);
            }
            return (MemorySegment)mh$.invokeExact(allocator, list, index, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPreConfig_InitPythonConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPreConfig_InitPythonConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyPreConfig_InitPythonConfig(PyPreConfig *config)
     * }
     */
    public static FunctionDescriptor PyPreConfig_InitPythonConfig$descriptor() {
        return PyPreConfig_InitPythonConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyPreConfig_InitPythonConfig(PyPreConfig *config)
     * }
     */
    public static MethodHandle PyPreConfig_InitPythonConfig$handle() {
        return PyPreConfig_InitPythonConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyPreConfig_InitPythonConfig(PyPreConfig *config)
     * }
     */
    public static MemorySegment PyPreConfig_InitPythonConfig$address() {
        return PyPreConfig_InitPythonConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyPreConfig_InitPythonConfig(PyPreConfig *config)
     * }
     */
    public static void PyPreConfig_InitPythonConfig(MemorySegment config) {
        var mh$ = PyPreConfig_InitPythonConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPreConfig_InitPythonConfig", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPreConfig_InitIsolatedConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPreConfig_InitIsolatedConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyPreConfig_InitIsolatedConfig(PyPreConfig *config)
     * }
     */
    public static FunctionDescriptor PyPreConfig_InitIsolatedConfig$descriptor() {
        return PyPreConfig_InitIsolatedConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyPreConfig_InitIsolatedConfig(PyPreConfig *config)
     * }
     */
    public static MethodHandle PyPreConfig_InitIsolatedConfig$handle() {
        return PyPreConfig_InitIsolatedConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyPreConfig_InitIsolatedConfig(PyPreConfig *config)
     * }
     */
    public static MemorySegment PyPreConfig_InitIsolatedConfig$address() {
        return PyPreConfig_InitIsolatedConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyPreConfig_InitIsolatedConfig(PyPreConfig *config)
     * }
     */
    public static void PyPreConfig_InitIsolatedConfig(MemorySegment config) {
        var mh$ = PyPreConfig_InitIsolatedConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPreConfig_InitIsolatedConfig", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_InitPythonConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_InitPythonConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyConfig_InitPythonConfig(PyConfig *config)
     * }
     */
    public static FunctionDescriptor PyConfig_InitPythonConfig$descriptor() {
        return PyConfig_InitPythonConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyConfig_InitPythonConfig(PyConfig *config)
     * }
     */
    public static MethodHandle PyConfig_InitPythonConfig$handle() {
        return PyConfig_InitPythonConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyConfig_InitPythonConfig(PyConfig *config)
     * }
     */
    public static MemorySegment PyConfig_InitPythonConfig$address() {
        return PyConfig_InitPythonConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyConfig_InitPythonConfig(PyConfig *config)
     * }
     */
    public static void PyConfig_InitPythonConfig(MemorySegment config) {
        var mh$ = PyConfig_InitPythonConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_InitPythonConfig", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_InitIsolatedConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_InitIsolatedConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyConfig_InitIsolatedConfig(PyConfig *config)
     * }
     */
    public static FunctionDescriptor PyConfig_InitIsolatedConfig$descriptor() {
        return PyConfig_InitIsolatedConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyConfig_InitIsolatedConfig(PyConfig *config)
     * }
     */
    public static MethodHandle PyConfig_InitIsolatedConfig$handle() {
        return PyConfig_InitIsolatedConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyConfig_InitIsolatedConfig(PyConfig *config)
     * }
     */
    public static MemorySegment PyConfig_InitIsolatedConfig$address() {
        return PyConfig_InitIsolatedConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyConfig_InitIsolatedConfig(PyConfig *config)
     * }
     */
    public static void PyConfig_InitIsolatedConfig(MemorySegment config) {
        var mh$ = PyConfig_InitIsolatedConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_InitIsolatedConfig", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyConfig_Clear(PyConfig *)
     * }
     */
    public static FunctionDescriptor PyConfig_Clear$descriptor() {
        return PyConfig_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyConfig_Clear(PyConfig *)
     * }
     */
    public static MethodHandle PyConfig_Clear$handle() {
        return PyConfig_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyConfig_Clear(PyConfig *)
     * }
     */
    public static MemorySegment PyConfig_Clear$address() {
        return PyConfig_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyConfig_Clear(PyConfig *)
     * }
     */
    public static void PyConfig_Clear(MemorySegment x0) {
        var mh$ = PyConfig_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_Clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetString(PyConfig *config, wchar_t **config_str, const wchar_t *str)
     * }
     */
    public static FunctionDescriptor PyConfig_SetString$descriptor() {
        return PyConfig_SetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetString(PyConfig *config, wchar_t **config_str, const wchar_t *str)
     * }
     */
    public static MethodHandle PyConfig_SetString$handle() {
        return PyConfig_SetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetString(PyConfig *config, wchar_t **config_str, const wchar_t *str)
     * }
     */
    public static MemorySegment PyConfig_SetString$address() {
        return PyConfig_SetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetString(PyConfig *config, wchar_t **config_str, const wchar_t *str)
     * }
     */
    public static MemorySegment PyConfig_SetString(SegmentAllocator allocator, MemorySegment config, MemorySegment config_str, MemorySegment str) {
        var mh$ = PyConfig_SetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetString", allocator, config, config_str, str);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, config_str, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetBytesString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetBytesString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t **config_str, const char *str)
     * }
     */
    public static FunctionDescriptor PyConfig_SetBytesString$descriptor() {
        return PyConfig_SetBytesString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t **config_str, const char *str)
     * }
     */
    public static MethodHandle PyConfig_SetBytesString$handle() {
        return PyConfig_SetBytesString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t **config_str, const char *str)
     * }
     */
    public static MemorySegment PyConfig_SetBytesString$address() {
        return PyConfig_SetBytesString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t **config_str, const char *str)
     * }
     */
    public static MemorySegment PyConfig_SetBytesString(SegmentAllocator allocator, MemorySegment config, MemorySegment config_str, MemorySegment str) {
        var mh$ = PyConfig_SetBytesString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetBytesString", allocator, config, config_str, str);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, config_str, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_Read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_Read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_Read(PyConfig *config)
     * }
     */
    public static FunctionDescriptor PyConfig_Read$descriptor() {
        return PyConfig_Read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_Read(PyConfig *config)
     * }
     */
    public static MethodHandle PyConfig_Read$handle() {
        return PyConfig_Read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_Read(PyConfig *config)
     * }
     */
    public static MemorySegment PyConfig_Read$address() {
        return PyConfig_Read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_Read(PyConfig *config)
     * }
     */
    public static MemorySegment PyConfig_Read(SegmentAllocator allocator, MemorySegment config) {
        var mh$ = PyConfig_Read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_Read", allocator, config);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetBytesArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetBytesArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesArgv(PyConfig *config, Py_ssize_t argc, char *const *argv)
     * }
     */
    public static FunctionDescriptor PyConfig_SetBytesArgv$descriptor() {
        return PyConfig_SetBytesArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesArgv(PyConfig *config, Py_ssize_t argc, char *const *argv)
     * }
     */
    public static MethodHandle PyConfig_SetBytesArgv$handle() {
        return PyConfig_SetBytesArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesArgv(PyConfig *config, Py_ssize_t argc, char *const *argv)
     * }
     */
    public static MemorySegment PyConfig_SetBytesArgv$address() {
        return PyConfig_SetBytesArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesArgv(PyConfig *config, Py_ssize_t argc, char *const *argv)
     * }
     */
    public static MemorySegment PyConfig_SetBytesArgv(SegmentAllocator allocator, MemorySegment config, long argc, MemorySegment argv) {
        var mh$ = PyConfig_SetBytesArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetBytesArgv", allocator, config, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetArgv(PyConfig *config, Py_ssize_t argc, wchar_t *const *argv)
     * }
     */
    public static FunctionDescriptor PyConfig_SetArgv$descriptor() {
        return PyConfig_SetArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetArgv(PyConfig *config, Py_ssize_t argc, wchar_t *const *argv)
     * }
     */
    public static MethodHandle PyConfig_SetArgv$handle() {
        return PyConfig_SetArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetArgv(PyConfig *config, Py_ssize_t argc, wchar_t *const *argv)
     * }
     */
    public static MemorySegment PyConfig_SetArgv$address() {
        return PyConfig_SetArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetArgv(PyConfig *config, Py_ssize_t argc, wchar_t *const *argv)
     * }
     */
    public static MemorySegment PyConfig_SetArgv(SegmentAllocator allocator, MemorySegment config, long argc, MemorySegment argv) {
        var mh$ = PyConfig_SetArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetArgv", allocator, config, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetWideStringList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetWideStringList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList *list, Py_ssize_t length, wchar_t **items)
     * }
     */
    public static FunctionDescriptor PyConfig_SetWideStringList$descriptor() {
        return PyConfig_SetWideStringList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList *list, Py_ssize_t length, wchar_t **items)
     * }
     */
    public static MethodHandle PyConfig_SetWideStringList$handle() {
        return PyConfig_SetWideStringList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList *list, Py_ssize_t length, wchar_t **items)
     * }
     */
    public static MemorySegment PyConfig_SetWideStringList$address() {
        return PyConfig_SetWideStringList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList *list, Py_ssize_t length, wchar_t **items)
     * }
     */
    public static MemorySegment PyConfig_SetWideStringList(SegmentAllocator allocator, MemorySegment config, MemorySegment list, long length, MemorySegment items) {
        var mh$ = PyConfig_SetWideStringList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetWideStringList", allocator, config, list, length, items);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, list, length, items);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetArgcArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetArgcArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_GetArgcArgv(int *argc, wchar_t ***argv)
     * }
     */
    public static FunctionDescriptor Py_GetArgcArgv$descriptor() {
        return Py_GetArgcArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_GetArgcArgv(int *argc, wchar_t ***argv)
     * }
     */
    public static MethodHandle Py_GetArgcArgv$handle() {
        return Py_GetArgcArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_GetArgcArgv(int *argc, wchar_t ***argv)
     * }
     */
    public static MemorySegment Py_GetArgcArgv$address() {
        return Py_GetArgcArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_GetArgcArgv(int *argc, wchar_t ***argv)
     * }
     */
    public static void Py_GetArgcArgv(MemorySegment argc, MemorySegment argv) {
        var mh$ = Py_GetArgcArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetArgcArgv", argc, argv);
            }
            mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_New$descriptor() {
        return PyInterpreterState_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static MethodHandle PyInterpreterState_New$handle() {
        return PyInterpreterState_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static MemorySegment PyInterpreterState_New$address() {
        return PyInterpreterState_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static MemorySegment PyInterpreterState_New() {
        var mh$ = PyInterpreterState_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Clear$descriptor() {
        return PyInterpreterState_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_Clear$handle() {
        return PyInterpreterState_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Clear$address() {
        return PyInterpreterState_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static void PyInterpreterState_Clear(MemorySegment x0) {
        var mh$ = PyInterpreterState_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Delete$descriptor() {
        return PyInterpreterState_Delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_Delete$handle() {
        return PyInterpreterState_Delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Delete$address() {
        return PyInterpreterState_Delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static void PyInterpreterState_Delete(MemorySegment x0) {
        var mh$ = PyInterpreterState_Delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Delete", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Get$descriptor() {
        return PyInterpreterState_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static MethodHandle PyInterpreterState_Get$handle() {
        return PyInterpreterState_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static MemorySegment PyInterpreterState_Get$address() {
        return PyInterpreterState_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static MemorySegment PyInterpreterState_Get() {
        var mh$ = PyInterpreterState_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Get");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_GetDict$descriptor() {
        return PyInterpreterState_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_GetDict$handle() {
        return PyInterpreterState_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_GetDict$address() {
        return PyInterpreterState_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_GetDict(MemorySegment x0) {
        var mh$ = PyInterpreterState_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_GetDict", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_GetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_GetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_GetID$descriptor() {
        return PyInterpreterState_GetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_GetID$handle() {
        return PyInterpreterState_GetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_GetID$address() {
        return PyInterpreterState_GetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static long PyInterpreterState_GetID(MemorySegment x0) {
        var mh$ = PyInterpreterState_GetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_GetID", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyState_AddModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyState_AddModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyState_AddModule$descriptor() {
        return PyState_AddModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static MethodHandle PyState_AddModule$handle() {
        return PyState_AddModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_AddModule$address() {
        return PyState_AddModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static int PyState_AddModule(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyState_AddModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyState_AddModule", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyState_RemoveModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyState_RemoveModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyState_RemoveModule$descriptor() {
        return PyState_RemoveModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static MethodHandle PyState_RemoveModule$handle() {
        return PyState_RemoveModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_RemoveModule$address() {
        return PyState_RemoveModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static int PyState_RemoveModule(MemorySegment x0) {
        var mh$ = PyState_RemoveModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyState_RemoveModule", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyState_FindModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyState_FindModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyState_FindModule$descriptor() {
        return PyState_FindModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static MethodHandle PyState_FindModule$handle() {
        return PyState_FindModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_FindModule$address() {
        return PyState_FindModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_FindModule(MemorySegment x0) {
        var mh$ = PyState_FindModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyState_FindModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_New$descriptor() {
        return PyThreadState_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyThreadState_New$handle() {
        return PyThreadState_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyThreadState_New$address() {
        return PyThreadState_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyThreadState_New(MemorySegment x0) {
        var mh$ = PyThreadState_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Clear$descriptor() {
        return PyThreadState_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Clear$handle() {
        return PyThreadState_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Clear$address() {
        return PyThreadState_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static void PyThreadState_Clear(MemorySegment x0) {
        var mh$ = PyThreadState_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Delete$descriptor() {
        return PyThreadState_Delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Delete$handle() {
        return PyThreadState_Delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Delete$address() {
        return PyThreadState_Delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static void PyThreadState_Delete(MemorySegment x0) {
        var mh$ = PyThreadState_Delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Delete", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static FunctionDescriptor PyThreadState_Get$descriptor() {
        return PyThreadState_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static MethodHandle PyThreadState_Get$handle() {
        return PyThreadState_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static MemorySegment PyThreadState_Get$address() {
        return PyThreadState_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static MemorySegment PyThreadState_Get() {
        var mh$ = PyThreadState_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Get");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Swap$descriptor() {
        return PyThreadState_Swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Swap$handle() {
        return PyThreadState_Swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Swap$address() {
        return PyThreadState_Swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Swap(MemorySegment x0) {
        var mh$ = PyThreadState_Swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Swap", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static FunctionDescriptor PyThreadState_GetDict$descriptor() {
        return PyThreadState_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static MethodHandle PyThreadState_GetDict$handle() {
        return PyThreadState_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static MemorySegment PyThreadState_GetDict$address() {
        return PyThreadState_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static MemorySegment PyThreadState_GetDict() {
        var mh$ = PyThreadState_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetDict");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_SetAsyncExc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_SetAsyncExc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static FunctionDescriptor PyThreadState_SetAsyncExc$descriptor() {
        return PyThreadState_SetAsyncExc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static MethodHandle PyThreadState_SetAsyncExc$handle() {
        return PyThreadState_SetAsyncExc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static MemorySegment PyThreadState_SetAsyncExc$address() {
        return PyThreadState_SetAsyncExc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static int PyThreadState_SetAsyncExc(long x0, MemorySegment x1) {
        var mh$ = PyThreadState_SetAsyncExc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_SetAsyncExc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_GetInterpreter$descriptor() {
        return PyThreadState_GetInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_GetInterpreter$handle() {
        return PyThreadState_GetInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetInterpreter$address() {
        return PyThreadState_GetInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetInterpreter(MemorySegment tstate) {
        var mh$ = PyThreadState_GetInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetInterpreter", tstate);
            }
            return (MemorySegment)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_GetFrame$descriptor() {
        return PyThreadState_GetFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_GetFrame$handle() {
        return PyThreadState_GetFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetFrame$address() {
        return PyThreadState_GetFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetFrame(MemorySegment tstate) {
        var mh$ = PyThreadState_GetFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetFrame", tstate);
            }
            return (MemorySegment)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_GetID$descriptor() {
        return PyThreadState_GetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_GetID$handle() {
        return PyThreadState_GetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetID$address() {
        return PyThreadState_GetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static long PyThreadState_GetID(MemorySegment tstate) {
        var mh$ = PyThreadState_GetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetID", tstate);
            }
            return (long)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PyGILState_LOCKED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyGILState_LOCKED = 0
     * }
     */
    public static int PyGILState_LOCKED() {
        return PyGILState_LOCKED;
    }
    private static final int PyGILState_UNLOCKED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyGILState_UNLOCKED = 1
     * }
     */
    public static int PyGILState_UNLOCKED() {
        return PyGILState_UNLOCKED;
    }

    private static class PyGILState_Ensure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_Ensure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static FunctionDescriptor PyGILState_Ensure$descriptor() {
        return PyGILState_Ensure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static MethodHandle PyGILState_Ensure$handle() {
        return PyGILState_Ensure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static MemorySegment PyGILState_Ensure$address() {
        return PyGILState_Ensure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static int PyGILState_Ensure() {
        var mh$ = PyGILState_Ensure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_Ensure");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGILState_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static FunctionDescriptor PyGILState_Release$descriptor() {
        return PyGILState_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static MethodHandle PyGILState_Release$handle() {
        return PyGILState_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static MemorySegment PyGILState_Release$address() {
        return PyGILState_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static void PyGILState_Release(int x0) {
        var mh$ = PyGILState_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_Release", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGILState_GetThisThreadState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_GetThisThreadState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static FunctionDescriptor PyGILState_GetThisThreadState$descriptor() {
        return PyGILState_GetThisThreadState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static MethodHandle PyGILState_GetThisThreadState$handle() {
        return PyGILState_GetThisThreadState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static MemorySegment PyGILState_GetThisThreadState$address() {
        return PyGILState_GetThisThreadState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static MemorySegment PyGILState_GetThisThreadState() {
        var mh$ = PyGILState_GetThisThreadState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_GetThisThreadState");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_RequiresIDRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_RequiresIDRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyInterpreterState_RequiresIDRef(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_RequiresIDRef$descriptor() {
        return _PyInterpreterState_RequiresIDRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyInterpreterState_RequiresIDRef(PyInterpreterState *)
     * }
     */
    public static MethodHandle _PyInterpreterState_RequiresIDRef$handle() {
        return _PyInterpreterState_RequiresIDRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyInterpreterState_RequiresIDRef(PyInterpreterState *)
     * }
     */
    public static MemorySegment _PyInterpreterState_RequiresIDRef$address() {
        return _PyInterpreterState_RequiresIDRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyInterpreterState_RequiresIDRef(PyInterpreterState *)
     * }
     */
    public static int _PyInterpreterState_RequiresIDRef(MemorySegment x0) {
        var mh$ = _PyInterpreterState_RequiresIDRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_RequiresIDRef", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_RequireIDRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_RequireIDRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyInterpreterState_RequireIDRef(PyInterpreterState *, int)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_RequireIDRef$descriptor() {
        return _PyInterpreterState_RequireIDRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyInterpreterState_RequireIDRef(PyInterpreterState *, int)
     * }
     */
    public static MethodHandle _PyInterpreterState_RequireIDRef$handle() {
        return _PyInterpreterState_RequireIDRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyInterpreterState_RequireIDRef(PyInterpreterState *, int)
     * }
     */
    public static MemorySegment _PyInterpreterState_RequireIDRef$address() {
        return _PyInterpreterState_RequireIDRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyInterpreterState_RequireIDRef(PyInterpreterState *, int)
     * }
     */
    public static void _PyInterpreterState_RequireIDRef(MemorySegment x0, int x1) {
        var mh$ = _PyInterpreterState_RequireIDRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_RequireIDRef", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_InterpreterState_GetMainModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_InterpreterState_GetMainModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_InterpreterState_GetMainModule(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyUnstable_InterpreterState_GetMainModule$descriptor() {
        return PyUnstable_InterpreterState_GetMainModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_InterpreterState_GetMainModule(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyUnstable_InterpreterState_GetMainModule$handle() {
        return PyUnstable_InterpreterState_GetMainModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnstable_InterpreterState_GetMainModule(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyUnstable_InterpreterState_GetMainModule$address() {
        return PyUnstable_InterpreterState_GetMainModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnstable_InterpreterState_GetMainModule(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyUnstable_InterpreterState_GetMainModule(MemorySegment x0) {
        var mh$ = PyUnstable_InterpreterState_GetMainModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_InterpreterState_GetMainModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetUnchecked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetUnchecked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_GetUnchecked()
     * }
     */
    public static FunctionDescriptor PyThreadState_GetUnchecked$descriptor() {
        return PyThreadState_GetUnchecked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_GetUnchecked()
     * }
     */
    public static MethodHandle PyThreadState_GetUnchecked$handle() {
        return PyThreadState_GetUnchecked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_GetUnchecked()
     * }
     */
    public static MemorySegment PyThreadState_GetUnchecked$address() {
        return PyThreadState_GetUnchecked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_GetUnchecked()
     * }
     */
    public static MemorySegment PyThreadState_GetUnchecked() {
        var mh$ = PyThreadState_GetUnchecked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetUnchecked");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_EnterTracing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_EnterTracing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_EnterTracing(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_EnterTracing$descriptor() {
        return PyThreadState_EnterTracing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_EnterTracing(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_EnterTracing$handle() {
        return PyThreadState_EnterTracing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_EnterTracing(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_EnterTracing$address() {
        return PyThreadState_EnterTracing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_EnterTracing(PyThreadState *tstate)
     * }
     */
    public static void PyThreadState_EnterTracing(MemorySegment tstate) {
        var mh$ = PyThreadState_EnterTracing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_EnterTracing", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_LeaveTracing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_LeaveTracing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_LeaveTracing(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_LeaveTracing$descriptor() {
        return PyThreadState_LeaveTracing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_LeaveTracing(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_LeaveTracing$handle() {
        return PyThreadState_LeaveTracing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_LeaveTracing(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_LeaveTracing$address() {
        return PyThreadState_LeaveTracing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_LeaveTracing(PyThreadState *tstate)
     * }
     */
    public static void PyThreadState_LeaveTracing(MemorySegment tstate) {
        var mh$ = PyThreadState_LeaveTracing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_LeaveTracing", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGILState_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGILState_Check()
     * }
     */
    public static FunctionDescriptor PyGILState_Check$descriptor() {
        return PyGILState_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGILState_Check()
     * }
     */
    public static MethodHandle PyGILState_Check$handle() {
        return PyGILState_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGILState_Check()
     * }
     */
    public static MemorySegment PyGILState_Check$address() {
        return PyGILState_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGILState_Check()
     * }
     */
    public static int PyGILState_Check() {
        var mh$ = PyGILState_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_Check");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyThread_CurrentFrames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyThread_CurrentFrames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentFrames()
     * }
     */
    public static FunctionDescriptor _PyThread_CurrentFrames$descriptor() {
        return _PyThread_CurrentFrames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentFrames()
     * }
     */
    public static MethodHandle _PyThread_CurrentFrames$handle() {
        return _PyThread_CurrentFrames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentFrames()
     * }
     */
    public static MemorySegment _PyThread_CurrentFrames$address() {
        return _PyThread_CurrentFrames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentFrames()
     * }
     */
    public static MemorySegment _PyThread_CurrentFrames() {
        var mh$ = _PyThread_CurrentFrames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyThread_CurrentFrames");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Main {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Main");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Main()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Main$descriptor() {
        return PyInterpreterState_Main.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Main()
     * }
     */
    public static MethodHandle PyInterpreterState_Main$handle() {
        return PyInterpreterState_Main.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Main()
     * }
     */
    public static MemorySegment PyInterpreterState_Main$address() {
        return PyInterpreterState_Main.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Main()
     * }
     */
    public static MemorySegment PyInterpreterState_Main() {
        var mh$ = PyInterpreterState_Main.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Main");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Head()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Head$descriptor() {
        return PyInterpreterState_Head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Head()
     * }
     */
    public static MethodHandle PyInterpreterState_Head$handle() {
        return PyInterpreterState_Head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Head()
     * }
     */
    public static MemorySegment PyInterpreterState_Head$address() {
        return PyInterpreterState_Head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Head()
     * }
     */
    public static MemorySegment PyInterpreterState_Head() {
        var mh$ = PyInterpreterState_Head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Head");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Next(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Next$descriptor() {
        return PyInterpreterState_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Next(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_Next$handle() {
        return PyInterpreterState_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Next(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Next$address() {
        return PyInterpreterState_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Next(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Next(MemorySegment x0) {
        var mh$ = PyInterpreterState_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Next", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_ThreadHead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_ThreadHead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_ThreadHead$descriptor() {
        return PyInterpreterState_ThreadHead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_ThreadHead$handle() {
        return PyInterpreterState_ThreadHead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_ThreadHead$address() {
        return PyInterpreterState_ThreadHead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_ThreadHead(MemorySegment x0) {
        var mh$ = PyInterpreterState_ThreadHead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_ThreadHead", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Next(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Next$descriptor() {
        return PyThreadState_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Next(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Next$handle() {
        return PyThreadState_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Next(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Next$address() {
        return PyThreadState_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Next(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Next(MemorySegment x0) {
        var mh$ = PyThreadState_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Next", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_DeleteCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_DeleteCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_DeleteCurrent()
     * }
     */
    public static FunctionDescriptor PyThreadState_DeleteCurrent$descriptor() {
        return PyThreadState_DeleteCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_DeleteCurrent()
     * }
     */
    public static MethodHandle PyThreadState_DeleteCurrent$handle() {
        return PyThreadState_DeleteCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_DeleteCurrent()
     * }
     */
    public static MemorySegment PyThreadState_DeleteCurrent$address() {
        return PyThreadState_DeleteCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_DeleteCurrent()
     * }
     */
    public static void PyThreadState_DeleteCurrent() {
        var mh$ = PyThreadState_DeleteCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_DeleteCurrent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_GetEvalFrameFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_GetEvalFrameFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_GetEvalFrameFunc$descriptor() {
        return _PyInterpreterState_GetEvalFrameFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)
     * }
     */
    public static MethodHandle _PyInterpreterState_GetEvalFrameFunc$handle() {
        return _PyInterpreterState_GetEvalFrameFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)
     * }
     */
    public static MemorySegment _PyInterpreterState_GetEvalFrameFunc$address() {
        return _PyInterpreterState_GetEvalFrameFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)
     * }
     */
    public static MemorySegment _PyInterpreterState_GetEvalFrameFunc(MemorySegment interp) {
        var mh$ = _PyInterpreterState_GetEvalFrameFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_GetEvalFrameFunc", interp);
            }
            return (MemorySegment)mh$.invokeExact(interp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_SetEvalFrameFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_SetEvalFrameFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_SetEvalFrameFunc$descriptor() {
        return _PyInterpreterState_SetEvalFrameFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame)
     * }
     */
    public static MethodHandle _PyInterpreterState_SetEvalFrameFunc$handle() {
        return _PyInterpreterState_SetEvalFrameFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame)
     * }
     */
    public static MemorySegment _PyInterpreterState_SetEvalFrameFunc$address() {
        return _PyInterpreterState_SetEvalFrameFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame)
     * }
     */
    public static void _PyInterpreterState_SetEvalFrameFunc(MemorySegment interp, MemorySegment eval_frame) {
        var mh$ = _PyInterpreterState_SetEvalFrameFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_SetEvalFrameFunc", interp, eval_frame);
            }
            mh$.invokeExact(interp, eval_frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGen_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyGen_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGen_Type
     * }
     */
    public static GroupLayout PyGen_Type$layout() {
        return PyGen_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGen_Type
     * }
     */
    public static MemorySegment PyGen_Type() {
        return PyGen_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGen_Type
     * }
     */
    public static void PyGen_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyGen_Type$constants.SEGMENT, 0L, PyGen_Type$constants.LAYOUT.byteSize());
    }

    private static class PyGen_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGen_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyGen_New(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyGen_New$descriptor() {
        return PyGen_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyGen_New(PyFrameObject *)
     * }
     */
    public static MethodHandle PyGen_New$handle() {
        return PyGen_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyGen_New(PyFrameObject *)
     * }
     */
    public static MemorySegment PyGen_New$address() {
        return PyGen_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyGen_New(PyFrameObject *)
     * }
     */
    public static MemorySegment PyGen_New(MemorySegment x0) {
        var mh$ = PyGen_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGen_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGen_NewWithQualName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGen_NewWithQualName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyGen_NewWithQualName(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static FunctionDescriptor PyGen_NewWithQualName$descriptor() {
        return PyGen_NewWithQualName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyGen_NewWithQualName(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MethodHandle PyGen_NewWithQualName$handle() {
        return PyGen_NewWithQualName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyGen_NewWithQualName(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyGen_NewWithQualName$address() {
        return PyGen_NewWithQualName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyGen_NewWithQualName(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyGen_NewWithQualName(MemorySegment x0, MemorySegment name, MemorySegment qualname) {
        var mh$ = PyGen_NewWithQualName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGen_NewWithQualName", x0, name, qualname);
            }
            return (MemorySegment)mh$.invokeExact(x0, name, qualname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGen_GetCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGen_GetCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyGen_GetCode(PyGenObject *gen)
     * }
     */
    public static FunctionDescriptor PyGen_GetCode$descriptor() {
        return PyGen_GetCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyGen_GetCode(PyGenObject *gen)
     * }
     */
    public static MethodHandle PyGen_GetCode$handle() {
        return PyGen_GetCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyGen_GetCode(PyGenObject *gen)
     * }
     */
    public static MemorySegment PyGen_GetCode$address() {
        return PyGen_GetCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyGen_GetCode(PyGenObject *gen)
     * }
     */
    public static MemorySegment PyGen_GetCode(MemorySegment gen) {
        var mh$ = PyGen_GetCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGen_GetCode", gen);
            }
            return (MemorySegment)mh$.invokeExact(gen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCoro_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCoro_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCoro_Type
     * }
     */
    public static GroupLayout PyCoro_Type$layout() {
        return PyCoro_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCoro_Type
     * }
     */
    public static MemorySegment PyCoro_Type() {
        return PyCoro_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCoro_Type
     * }
     */
    public static void PyCoro_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCoro_Type$constants.SEGMENT, 0L, PyCoro_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCoro_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCoro_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCoro_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static FunctionDescriptor PyCoro_New$descriptor() {
        return PyCoro_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCoro_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MethodHandle PyCoro_New$handle() {
        return PyCoro_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCoro_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyCoro_New$address() {
        return PyCoro_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCoro_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyCoro_New(MemorySegment x0, MemorySegment name, MemorySegment qualname) {
        var mh$ = PyCoro_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCoro_New", x0, name, qualname);
            }
            return (MemorySegment)mh$.invokeExact(x0, name, qualname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyAsyncGen_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyAsyncGen_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyAsyncGen_Type
     * }
     */
    public static GroupLayout PyAsyncGen_Type$layout() {
        return PyAsyncGen_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyAsyncGen_Type
     * }
     */
    public static MemorySegment PyAsyncGen_Type() {
        return PyAsyncGen_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyAsyncGen_Type
     * }
     */
    public static void PyAsyncGen_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyAsyncGen_Type$constants.SEGMENT, 0L, PyAsyncGen_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyAsyncGenASend_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyAsyncGenASend_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenASend_Type
     * }
     */
    public static GroupLayout _PyAsyncGenASend_Type$layout() {
        return _PyAsyncGenASend_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenASend_Type
     * }
     */
    public static MemorySegment _PyAsyncGenASend_Type() {
        return _PyAsyncGenASend_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenASend_Type
     * }
     */
    public static void _PyAsyncGenASend_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyAsyncGenASend_Type$constants.SEGMENT, 0L, _PyAsyncGenASend_Type$constants.LAYOUT.byteSize());
    }

    private static class PyAsyncGen_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyAsyncGen_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyAsyncGen_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static FunctionDescriptor PyAsyncGen_New$descriptor() {
        return PyAsyncGen_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyAsyncGen_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MethodHandle PyAsyncGen_New$handle() {
        return PyAsyncGen_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyAsyncGen_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyAsyncGen_New$address() {
        return PyAsyncGen_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyAsyncGen_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyAsyncGen_New(MemorySegment x0, MemorySegment name, MemorySegment qualname) {
        var mh$ = PyAsyncGen_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyAsyncGen_New", x0, name, qualname);
            }
            return (MemorySegment)mh$.invokeExact(x0, name, qualname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyClassMethodDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyClassMethodDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethodDescr_Type
     * }
     */
    public static GroupLayout PyClassMethodDescr_Type$layout() {
        return PyClassMethodDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethodDescr_Type
     * }
     */
    public static MemorySegment PyClassMethodDescr_Type() {
        return PyClassMethodDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethodDescr_Type
     * }
     */
    public static void PyClassMethodDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyClassMethodDescr_Type$constants.SEGMENT, 0L, PyClassMethodDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyGetSetDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyGetSetDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGetSetDescr_Type
     * }
     */
    public static GroupLayout PyGetSetDescr_Type$layout() {
        return PyGetSetDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGetSetDescr_Type
     * }
     */
    public static MemorySegment PyGetSetDescr_Type() {
        return PyGetSetDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGetSetDescr_Type
     * }
     */
    public static void PyGetSetDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyGetSetDescr_Type$constants.SEGMENT, 0L, PyGetSetDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMemberDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMemberDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemberDescr_Type
     * }
     */
    public static GroupLayout PyMemberDescr_Type$layout() {
        return PyMemberDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemberDescr_Type
     * }
     */
    public static MemorySegment PyMemberDescr_Type() {
        return PyMemberDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemberDescr_Type
     * }
     */
    public static void PyMemberDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMemberDescr_Type$constants.SEGMENT, 0L, PyMemberDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMethodDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMethodDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethodDescr_Type
     * }
     */
    public static GroupLayout PyMethodDescr_Type$layout() {
        return PyMethodDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethodDescr_Type
     * }
     */
    public static MemorySegment PyMethodDescr_Type() {
        return PyMethodDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethodDescr_Type
     * }
     */
    public static void PyMethodDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMethodDescr_Type$constants.SEGMENT, 0L, PyMethodDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyWrapperDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyWrapperDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyWrapperDescr_Type
     * }
     */
    public static GroupLayout PyWrapperDescr_Type$layout() {
        return PyWrapperDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyWrapperDescr_Type
     * }
     */
    public static MemorySegment PyWrapperDescr_Type() {
        return PyWrapperDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyWrapperDescr_Type
     * }
     */
    public static void PyWrapperDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyWrapperDescr_Type$constants.SEGMENT, 0L, PyWrapperDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictProxy_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictProxy_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictProxy_Type
     * }
     */
    public static GroupLayout PyDictProxy_Type$layout() {
        return PyDictProxy_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictProxy_Type
     * }
     */
    public static MemorySegment PyDictProxy_Type() {
        return PyDictProxy_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictProxy_Type
     * }
     */
    public static void PyDictProxy_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictProxy_Type$constants.SEGMENT, 0L, PyDictProxy_Type$constants.LAYOUT.byteSize());
    }

    private static class PyProperty_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyProperty_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyProperty_Type
     * }
     */
    public static GroupLayout PyProperty_Type$layout() {
        return PyProperty_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyProperty_Type
     * }
     */
    public static MemorySegment PyProperty_Type() {
        return PyProperty_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyProperty_Type
     * }
     */
    public static void PyProperty_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyProperty_Type$constants.SEGMENT, 0L, PyProperty_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDescr_NewMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewMethod$descriptor() {
        return PyDescr_NewMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MethodHandle PyDescr_NewMethod$handle() {
        return PyDescr_NewMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMethod$address() {
        return PyDescr_NewMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMethod(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewMethod", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewClassMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewClassMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewClassMethod$descriptor() {
        return PyDescr_NewClassMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MethodHandle PyDescr_NewClassMethod$handle() {
        return PyDescr_NewClassMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewClassMethod$address() {
        return PyDescr_NewClassMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewClassMethod(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewClassMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewClassMethod", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewMember {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewMember");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewMember$descriptor() {
        return PyDescr_NewMember.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static MethodHandle PyDescr_NewMember$handle() {
        return PyDescr_NewMember.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMember$address() {
        return PyDescr_NewMember.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMember(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewMember.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewMember", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewGetSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewGetSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewGetSet$descriptor() {
        return PyDescr_NewGetSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static MethodHandle PyDescr_NewGetSet$handle() {
        return PyDescr_NewGetSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static MemorySegment PyDescr_NewGetSet$address() {
        return PyDescr_NewGetSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static MemorySegment PyDescr_NewGetSet(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewGetSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewGetSet", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDictProxy_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDictProxy_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyDictProxy_New$descriptor() {
        return PyDictProxy_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static MethodHandle PyDictProxy_New$handle() {
        return PyDictProxy_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static MemorySegment PyDictProxy_New$address() {
        return PyDictProxy_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static MemorySegment PyDictProxy_New(MemorySegment x0) {
        var mh$ = PyDictProxy_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDictProxy_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWrapper_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWrapper_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyWrapper_New$descriptor() {
        return PyWrapper_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyWrapper_New$handle() {
        return PyWrapper_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyWrapper_New$address() {
        return PyWrapper_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyWrapper_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyWrapper_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWrapper_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMember_GetOne {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMember_GetOne");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMember_GetOne(const char *, PyMemberDef *)
     * }
     */
    public static FunctionDescriptor PyMember_GetOne$descriptor() {
        return PyMember_GetOne.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMember_GetOne(const char *, PyMemberDef *)
     * }
     */
    public static MethodHandle PyMember_GetOne$handle() {
        return PyMember_GetOne.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMember_GetOne(const char *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyMember_GetOne$address() {
        return PyMember_GetOne.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMember_GetOne(const char *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyMember_GetOne(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyMember_GetOne.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMember_GetOne", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMember_SetOne {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMember_SetOne");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyMember_SetOne(char *, PyMemberDef *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyMember_SetOne$descriptor() {
        return PyMember_SetOne.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyMember_SetOne(char *, PyMemberDef *, PyObject *)
     * }
     */
    public static MethodHandle PyMember_SetOne$handle() {
        return PyMember_SetOne.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyMember_SetOne(char *, PyMemberDef *, PyObject *)
     * }
     */
    public static MemorySegment PyMember_SetOne$address() {
        return PyMember_SetOne.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyMember_SetOne(char *, PyMemberDef *, PyObject *)
     * }
     */
    public static int PyMember_SetOne(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyMember_SetOne.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMember_SetOne", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewWrapper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewWrapper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewWrapper(PyTypeObject *, struct wrapperbase *, void *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewWrapper$descriptor() {
        return PyDescr_NewWrapper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewWrapper(PyTypeObject *, struct wrapperbase *, void *)
     * }
     */
    public static MethodHandle PyDescr_NewWrapper$handle() {
        return PyDescr_NewWrapper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewWrapper(PyTypeObject *, struct wrapperbase *, void *)
     * }
     */
    public static MemorySegment PyDescr_NewWrapper$address() {
        return PyDescr_NewWrapper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewWrapper(PyTypeObject *, struct wrapperbase *, void *)
     * }
     */
    public static MemorySegment PyDescr_NewWrapper(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyDescr_NewWrapper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewWrapper", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_IsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_IsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDescr_IsData(PyObject *)
     * }
     */
    public static FunctionDescriptor PyDescr_IsData$descriptor() {
        return PyDescr_IsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDescr_IsData(PyObject *)
     * }
     */
    public static MethodHandle PyDescr_IsData$handle() {
        return PyDescr_IsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDescr_IsData(PyObject *)
     * }
     */
    public static MemorySegment PyDescr_IsData$address() {
        return PyDescr_IsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDescr_IsData(PyObject *)
     * }
     */
    public static int PyDescr_IsData(MemorySegment x0) {
        var mh$ = PyDescr_IsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_IsData", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GenericAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GenericAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor Py_GenericAlias$descriptor() {
        return Py_GenericAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle Py_GenericAlias$handle() {
        return Py_GenericAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment Py_GenericAlias$address() {
        return Py_GenericAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment Py_GenericAlias(MemorySegment x0, MemorySegment x1) {
        var mh$ = Py_GenericAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GenericAlias", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GenericAliasType$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_GenericAliasType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject Py_GenericAliasType
     * }
     */
    public static GroupLayout Py_GenericAliasType$layout() {
        return Py_GenericAliasType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject Py_GenericAliasType
     * }
     */
    public static MemorySegment Py_GenericAliasType() {
        return Py_GenericAliasType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject Py_GenericAliasType
     * }
     */
    public static void Py_GenericAliasType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, Py_GenericAliasType$constants.SEGMENT, 0L, Py_GenericAliasType$constants.LAYOUT.byteSize());
    }

    private static class PyErr_WarnEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static FunctionDescriptor PyErr_WarnEx$descriptor() {
        return PyErr_WarnEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static MethodHandle PyErr_WarnEx$handle() {
        return PyErr_WarnEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static MemorySegment PyErr_WarnEx$address() {
        return PyErr_WarnEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static int PyErr_WarnEx(MemorySegment category, MemorySegment message, long stack_level) {
        var mh$ = PyErr_WarnEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WarnEx", category, message, stack_level);
            }
            return (int)mh$.invokeExact(category, message, stack_level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char *format, ...)
     * }
     */
    public static class PyErr_WarnFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_WarnFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char *format, ...)
         * }
         */
        public static PyErr_WarnFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_WarnFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment category, long stack_level, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_WarnFormat", category, stack_level, format, x3);
                }
                return (int) spreader.invokeExact(category, stack_level, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const char *format, ...)
     * }
     */
    public static class PyErr_ResourceWarning {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ResourceWarning");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_ResourceWarning(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const char *format, ...)
         * }
         */
        public static PyErr_ResourceWarning makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_ResourceWarning(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment source, long stack_level, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_ResourceWarning", source, stack_level, format, x3);
                }
                return (int) spreader.invokeExact(source, stack_level, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyErr_WarnExplicit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnExplicit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static FunctionDescriptor PyErr_WarnExplicit$descriptor() {
        return PyErr_WarnExplicit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static MethodHandle PyErr_WarnExplicit$handle() {
        return PyErr_WarnExplicit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static MemorySegment PyErr_WarnExplicit$address() {
        return PyErr_WarnExplicit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static int PyErr_WarnExplicit(MemorySegment category, MemorySegment message, MemorySegment filename, int lineno, MemorySegment module, MemorySegment registry) {
        var mh$ = PyErr_WarnExplicit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WarnExplicit", category, message, filename, lineno, module, registry);
            }
            return (int)mh$.invokeExact(category, message, filename, lineno, module, registry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_WarnExplicitObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnExplicitObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)
     * }
     */
    public static FunctionDescriptor PyErr_WarnExplicitObject$descriptor() {
        return PyErr_WarnExplicitObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)
     * }
     */
    public static MethodHandle PyErr_WarnExplicitObject$handle() {
        return PyErr_WarnExplicitObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)
     * }
     */
    public static MemorySegment PyErr_WarnExplicitObject$address() {
        return PyErr_WarnExplicitObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)
     * }
     */
    public static int PyErr_WarnExplicitObject(MemorySegment category, MemorySegment message, MemorySegment filename, int lineno, MemorySegment module, MemorySegment registry) {
        var mh$ = PyErr_WarnExplicitObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WarnExplicitObject", category, message, filename, lineno, module, registry);
            }
            return (int)mh$.invokeExact(category, message, filename, lineno, module, registry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicitFormat(PyObject *category, const char *filename, int lineno, const char *module, PyObject *registry, const char *format, ...)
     * }
     */
    public static class PyErr_WarnExplicitFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnExplicitFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_WarnExplicitFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyErr_WarnExplicitFormat(PyObject *category, const char *filename, int lineno, const char *module, PyObject *registry, const char *format, ...)
         * }
         */
        public static PyErr_WarnExplicitFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_WarnExplicitFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment category, MemorySegment filename, int lineno, MemorySegment module, MemorySegment registry, MemorySegment format, Object... x6) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_WarnExplicitFormat", category, filename, lineno, module, registry, format, x6);
                }
                return (int) spreader.invokeExact(category, filename, lineno, module, registry, format, x6);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _PyWeakref_RefType$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyWeakref_RefType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_RefType
     * }
     */
    public static GroupLayout _PyWeakref_RefType$layout() {
        return _PyWeakref_RefType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_RefType
     * }
     */
    public static MemorySegment _PyWeakref_RefType() {
        return _PyWeakref_RefType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_RefType
     * }
     */
    public static void _PyWeakref_RefType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyWeakref_RefType$constants.SEGMENT, 0L, _PyWeakref_RefType$constants.LAYOUT.byteSize());
    }

    private static class _PyWeakref_ProxyType$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyWeakref_ProxyType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_ProxyType
     * }
     */
    public static GroupLayout _PyWeakref_ProxyType$layout() {
        return _PyWeakref_ProxyType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_ProxyType
     * }
     */
    public static MemorySegment _PyWeakref_ProxyType() {
        return _PyWeakref_ProxyType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_ProxyType
     * }
     */
    public static void _PyWeakref_ProxyType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyWeakref_ProxyType$constants.SEGMENT, 0L, _PyWeakref_ProxyType$constants.LAYOUT.byteSize());
    }

    private static class _PyWeakref_CallableProxyType$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyWeakref_CallableProxyType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_CallableProxyType
     * }
     */
    public static GroupLayout _PyWeakref_CallableProxyType$layout() {
        return _PyWeakref_CallableProxyType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_CallableProxyType
     * }
     */
    public static MemorySegment _PyWeakref_CallableProxyType() {
        return _PyWeakref_CallableProxyType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_CallableProxyType
     * }
     */
    public static void _PyWeakref_CallableProxyType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyWeakref_CallableProxyType$constants.SEGMENT, 0L, _PyWeakref_CallableProxyType$constants.LAYOUT.byteSize());
    }

    private static class PyWeakref_NewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_NewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static FunctionDescriptor PyWeakref_NewRef$descriptor() {
        return PyWeakref_NewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static MethodHandle PyWeakref_NewRef$handle() {
        return PyWeakref_NewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewRef$address() {
        return PyWeakref_NewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewRef(MemorySegment ob, MemorySegment callback) {
        var mh$ = PyWeakref_NewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_NewRef", ob, callback);
            }
            return (MemorySegment)mh$.invokeExact(ob, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWeakref_NewProxy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_NewProxy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static FunctionDescriptor PyWeakref_NewProxy$descriptor() {
        return PyWeakref_NewProxy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static MethodHandle PyWeakref_NewProxy$handle() {
        return PyWeakref_NewProxy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewProxy$address() {
        return PyWeakref_NewProxy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewProxy(MemorySegment ob, MemorySegment callback) {
        var mh$ = PyWeakref_NewProxy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_NewProxy", ob, callback);
            }
            return (MemorySegment)mh$.invokeExact(ob, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWeakref_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static FunctionDescriptor PyWeakref_GetObject$descriptor() {
        return PyWeakref_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static MethodHandle PyWeakref_GetObject$handle() {
        return PyWeakref_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static MemorySegment PyWeakref_GetObject$address() {
        return PyWeakref_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static MemorySegment PyWeakref_GetObject(MemorySegment ref) {
        var mh$ = PyWeakref_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_GetObject", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWeakref_GetRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_GetRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyWeakref_GetRef(PyObject *ref, PyObject **pobj)
     * }
     */
    public static FunctionDescriptor PyWeakref_GetRef$descriptor() {
        return PyWeakref_GetRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyWeakref_GetRef(PyObject *ref, PyObject **pobj)
     * }
     */
    public static MethodHandle PyWeakref_GetRef$handle() {
        return PyWeakref_GetRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyWeakref_GetRef(PyObject *ref, PyObject **pobj)
     * }
     */
    public static MemorySegment PyWeakref_GetRef$address() {
        return PyWeakref_GetRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyWeakref_GetRef(PyObject *ref, PyObject **pobj)
     * }
     */
    public static int PyWeakref_GetRef(MemorySegment ref, MemorySegment pobj) {
        var mh$ = PyWeakref_GetRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_GetRef", ref, pobj);
            }
            return (int)mh$.invokeExact(ref, pobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyWeakref_ClearRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyWeakref_ClearRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyWeakref_ClearRef(PyWeakReference *self)
     * }
     */
    public static FunctionDescriptor _PyWeakref_ClearRef$descriptor() {
        return _PyWeakref_ClearRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyWeakref_ClearRef(PyWeakReference *self)
     * }
     */
    public static MethodHandle _PyWeakref_ClearRef$handle() {
        return _PyWeakref_ClearRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyWeakref_ClearRef(PyWeakReference *self)
     * }
     */
    public static MemorySegment _PyWeakref_ClearRef$address() {
        return _PyWeakref_ClearRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyWeakref_ClearRef(PyWeakReference *self)
     * }
     */
    public static void _PyWeakref_ClearRef(MemorySegment self) {
        var mh$ = _PyWeakref_ClearRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyWeakref_ClearRef", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_UnnamedField$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyStructSequence_UnnamedField").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static AddressLayout PyStructSequence_UnnamedField$layout() {
        return PyStructSequence_UnnamedField$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static MemorySegment PyStructSequence_UnnamedField$segment() {
        return PyStructSequence_UnnamedField$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static MemorySegment PyStructSequence_UnnamedField() {
        return PyStructSequence_UnnamedField$constants.SEGMENT.get(PyStructSequence_UnnamedField$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static void PyStructSequence_UnnamedField(MemorySegment varValue) {
        PyStructSequence_UnnamedField$constants.SEGMENT.set(PyStructSequence_UnnamedField$constants.LAYOUT, 0L, varValue);
    }

    private static class PyStructSequence_InitType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_InitType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyStructSequence_InitType(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static FunctionDescriptor PyStructSequence_InitType$descriptor() {
        return PyStructSequence_InitType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyStructSequence_InitType(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static MethodHandle PyStructSequence_InitType$handle() {
        return PyStructSequence_InitType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyStructSequence_InitType(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_InitType$address() {
        return PyStructSequence_InitType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyStructSequence_InitType(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static void PyStructSequence_InitType(MemorySegment type, MemorySegment desc) {
        var mh$ = PyStructSequence_InitType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_InitType", type, desc);
            }
            mh$.invokeExact(type, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_InitType2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_InitType2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyStructSequence_InitType2(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static FunctionDescriptor PyStructSequence_InitType2$descriptor() {
        return PyStructSequence_InitType2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyStructSequence_InitType2(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static MethodHandle PyStructSequence_InitType2$handle() {
        return PyStructSequence_InitType2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyStructSequence_InitType2(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_InitType2$address() {
        return PyStructSequence_InitType2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyStructSequence_InitType2(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static int PyStructSequence_InitType2(MemorySegment type, MemorySegment desc) {
        var mh$ = PyStructSequence_InitType2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_InitType2", type, desc);
            }
            return (int)mh$.invokeExact(type, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_NewType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_NewType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static FunctionDescriptor PyStructSequence_NewType$descriptor() {
        return PyStructSequence_NewType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static MethodHandle PyStructSequence_NewType$handle() {
        return PyStructSequence_NewType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_NewType$address() {
        return PyStructSequence_NewType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_NewType(MemorySegment desc) {
        var mh$ = PyStructSequence_NewType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_NewType", desc);
            }
            return (MemorySegment)mh$.invokeExact(desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyStructSequence_New$descriptor() {
        return PyStructSequence_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyStructSequence_New$handle() {
        return PyStructSequence_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyStructSequence_New$address() {
        return PyStructSequence_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyStructSequence_New(MemorySegment type) {
        var mh$ = PyStructSequence_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_New", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyStructSequence_SetItem$descriptor() {
        return PyStructSequence_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyStructSequence_SetItem$handle() {
        return PyStructSequence_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyStructSequence_SetItem$address() {
        return PyStructSequence_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static void PyStructSequence_SetItem(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyStructSequence_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_SetItem", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyStructSequence_GetItem$descriptor() {
        return PyStructSequence_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyStructSequence_GetItem$handle() {
        return PyStructSequence_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyStructSequence_GetItem$address() {
        return PyStructSequence_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyStructSequence_GetItem(MemorySegment x0, long x1) {
        var mh$ = PyStructSequence_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_GetItem", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPickleBuffer_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyPickleBuffer_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyPickleBuffer_Type
     * }
     */
    public static GroupLayout PyPickleBuffer_Type$layout() {
        return PyPickleBuffer_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyPickleBuffer_Type
     * }
     */
    public static MemorySegment PyPickleBuffer_Type() {
        return PyPickleBuffer_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyPickleBuffer_Type
     * }
     */
    public static void PyPickleBuffer_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyPickleBuffer_Type$constants.SEGMENT, 0L, PyPickleBuffer_Type$constants.LAYOUT.byteSize());
    }

    private static class PyPickleBuffer_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPickleBuffer_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyPickleBuffer_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyPickleBuffer_FromObject$descriptor() {
        return PyPickleBuffer_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyPickleBuffer_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyPickleBuffer_FromObject$handle() {
        return PyPickleBuffer_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyPickleBuffer_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_FromObject$address() {
        return PyPickleBuffer_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyPickleBuffer_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_FromObject(MemorySegment x0) {
        var mh$ = PyPickleBuffer_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPickleBuffer_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPickleBuffer_GetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPickleBuffer_GetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *)
     * }
     */
    public static FunctionDescriptor PyPickleBuffer_GetBuffer$descriptor() {
        return PyPickleBuffer_GetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *)
     * }
     */
    public static MethodHandle PyPickleBuffer_GetBuffer$handle() {
        return PyPickleBuffer_GetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_GetBuffer$address() {
        return PyPickleBuffer_GetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_GetBuffer(MemorySegment x0) {
        var mh$ = PyPickleBuffer_GetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPickleBuffer_GetBuffer", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPickleBuffer_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPickleBuffer_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyPickleBuffer_Release(PyObject *)
     * }
     */
    public static FunctionDescriptor PyPickleBuffer_Release$descriptor() {
        return PyPickleBuffer_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyPickleBuffer_Release(PyObject *)
     * }
     */
    public static MethodHandle PyPickleBuffer_Release$handle() {
        return PyPickleBuffer_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyPickleBuffer_Release(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_Release$address() {
        return PyPickleBuffer_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyPickleBuffer_Release(PyObject *)
     * }
     */
    public static int PyPickleBuffer_Release(MemorySegment x0) {
        var mh$ = PyPickleBuffer_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPickleBuffer_Release", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int64_t PyTime_t
     * }
     */
    public static final OfLong PyTime_t = Python_h.C_LONG_LONG;

    private static class PyTime_AsSecondsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTime_AsSecondsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyTime_AsSecondsDouble(PyTime_t t)
     * }
     */
    public static FunctionDescriptor PyTime_AsSecondsDouble$descriptor() {
        return PyTime_AsSecondsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyTime_AsSecondsDouble(PyTime_t t)
     * }
     */
    public static MethodHandle PyTime_AsSecondsDouble$handle() {
        return PyTime_AsSecondsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyTime_AsSecondsDouble(PyTime_t t)
     * }
     */
    public static MemorySegment PyTime_AsSecondsDouble$address() {
        return PyTime_AsSecondsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyTime_AsSecondsDouble(PyTime_t t)
     * }
     */
    public static double PyTime_AsSecondsDouble(long t) {
        var mh$ = PyTime_AsSecondsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTime_AsSecondsDouble", t);
            }
            return (double)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTime_Monotonic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTime_Monotonic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTime_Monotonic(PyTime_t *result)
     * }
     */
    public static FunctionDescriptor PyTime_Monotonic$descriptor() {
        return PyTime_Monotonic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTime_Monotonic(PyTime_t *result)
     * }
     */
    public static MethodHandle PyTime_Monotonic$handle() {
        return PyTime_Monotonic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTime_Monotonic(PyTime_t *result)
     * }
     */
    public static MemorySegment PyTime_Monotonic$address() {
        return PyTime_Monotonic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTime_Monotonic(PyTime_t *result)
     * }
     */
    public static int PyTime_Monotonic(MemorySegment result) {
        var mh$ = PyTime_Monotonic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTime_Monotonic", result);
            }
            return (int)mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTime_PerfCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTime_PerfCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTime_PerfCounter(PyTime_t *result)
     * }
     */
    public static FunctionDescriptor PyTime_PerfCounter$descriptor() {
        return PyTime_PerfCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTime_PerfCounter(PyTime_t *result)
     * }
     */
    public static MethodHandle PyTime_PerfCounter$handle() {
        return PyTime_PerfCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTime_PerfCounter(PyTime_t *result)
     * }
     */
    public static MemorySegment PyTime_PerfCounter$address() {
        return PyTime_PerfCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTime_PerfCounter(PyTime_t *result)
     * }
     */
    public static int PyTime_PerfCounter(MemorySegment result) {
        var mh$ = PyTime_PerfCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTime_PerfCounter", result);
            }
            return (int)mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTime_Time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTime_Time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTime_Time(PyTime_t *result)
     * }
     */
    public static FunctionDescriptor PyTime_Time$descriptor() {
        return PyTime_Time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTime_Time(PyTime_t *result)
     * }
     */
    public static MethodHandle PyTime_Time$handle() {
        return PyTime_Time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTime_Time(PyTime_t *result)
     * }
     */
    public static MemorySegment PyTime_Time$address() {
        return PyTime_Time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTime_Time(PyTime_t *result)
     * }
     */
    public static int PyTime_Time(MemorySegment result) {
        var mh$ = PyTime_Time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTime_Time", result);
            }
            return (int)mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTime_MonotonicRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTime_MonotonicRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTime_MonotonicRaw(PyTime_t *result)
     * }
     */
    public static FunctionDescriptor PyTime_MonotonicRaw$descriptor() {
        return PyTime_MonotonicRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTime_MonotonicRaw(PyTime_t *result)
     * }
     */
    public static MethodHandle PyTime_MonotonicRaw$handle() {
        return PyTime_MonotonicRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTime_MonotonicRaw(PyTime_t *result)
     * }
     */
    public static MemorySegment PyTime_MonotonicRaw$address() {
        return PyTime_MonotonicRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTime_MonotonicRaw(PyTime_t *result)
     * }
     */
    public static int PyTime_MonotonicRaw(MemorySegment result) {
        var mh$ = PyTime_MonotonicRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTime_MonotonicRaw", result);
            }
            return (int)mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTime_PerfCounterRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTime_PerfCounterRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTime_PerfCounterRaw(PyTime_t *result)
     * }
     */
    public static FunctionDescriptor PyTime_PerfCounterRaw$descriptor() {
        return PyTime_PerfCounterRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTime_PerfCounterRaw(PyTime_t *result)
     * }
     */
    public static MethodHandle PyTime_PerfCounterRaw$handle() {
        return PyTime_PerfCounterRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTime_PerfCounterRaw(PyTime_t *result)
     * }
     */
    public static MemorySegment PyTime_PerfCounterRaw$address() {
        return PyTime_PerfCounterRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTime_PerfCounterRaw(PyTime_t *result)
     * }
     */
    public static int PyTime_PerfCounterRaw(MemorySegment result) {
        var mh$ = PyTime_PerfCounterRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTime_PerfCounterRaw", result);
            }
            return (int)mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTime_TimeRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTime_TimeRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTime_TimeRaw(PyTime_t *result)
     * }
     */
    public static FunctionDescriptor PyTime_TimeRaw$descriptor() {
        return PyTime_TimeRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTime_TimeRaw(PyTime_t *result)
     * }
     */
    public static MethodHandle PyTime_TimeRaw$handle() {
        return PyTime_TimeRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTime_TimeRaw(PyTime_t *result)
     * }
     */
    public static MemorySegment PyTime_TimeRaw$address() {
        return PyTime_TimeRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTime_TimeRaw(PyTime_t *result)
     * }
     */
    public static int PyTime_TimeRaw(MemorySegment result) {
        var mh$ = PyTime_TimeRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTime_TimeRaw", result);
            }
            return (int)mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static FunctionDescriptor PyCodec_Register$descriptor() {
        return PyCodec_Register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static MethodHandle PyCodec_Register$handle() {
        return PyCodec_Register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static MemorySegment PyCodec_Register$address() {
        return PyCodec_Register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static int PyCodec_Register(MemorySegment search_function) {
        var mh$ = PyCodec_Register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Register", search_function);
            }
            return (int)mh$.invokeExact(search_function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Unregister {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Unregister");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static FunctionDescriptor PyCodec_Unregister$descriptor() {
        return PyCodec_Unregister.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static MethodHandle PyCodec_Unregister$handle() {
        return PyCodec_Unregister.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static MemorySegment PyCodec_Unregister$address() {
        return PyCodec_Unregister.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static int PyCodec_Unregister(MemorySegment search_function) {
        var mh$ = PyCodec_Unregister.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Unregister", search_function);
            }
            return (int)mh$.invokeExact(search_function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_KnownEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_KnownEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static FunctionDescriptor PyCodec_KnownEncoding$descriptor() {
        return PyCodec_KnownEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static MethodHandle PyCodec_KnownEncoding$handle() {
        return PyCodec_KnownEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_KnownEncoding$address() {
        return PyCodec_KnownEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static int PyCodec_KnownEncoding(MemorySegment encoding) {
        var mh$ = PyCodec_KnownEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_KnownEncoding", encoding);
            }
            return (int)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_Encode$descriptor() {
        return PyCodec_Encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_Encode$handle() {
        return PyCodec_Encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Encode$address() {
        return PyCodec_Encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Encode(MemorySegment object, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_Encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Encode", object, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(object, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_Decode$descriptor() {
        return PyCodec_Decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_Decode$handle() {
        return PyCodec_Decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Decode$address() {
        return PyCodec_Decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Decode(MemorySegment object, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_Decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Decode", object, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(object, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static FunctionDescriptor PyCodec_Encoder$descriptor() {
        return PyCodec_Encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static MethodHandle PyCodec_Encoder$handle() {
        return PyCodec_Encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Encoder$address() {
        return PyCodec_Encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Encoder(MemorySegment encoding) {
        var mh$ = PyCodec_Encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Encoder", encoding);
            }
            return (MemorySegment)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static FunctionDescriptor PyCodec_Decoder$descriptor() {
        return PyCodec_Decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static MethodHandle PyCodec_Decoder$handle() {
        return PyCodec_Decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Decoder$address() {
        return PyCodec_Decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Decoder(MemorySegment encoding) {
        var mh$ = PyCodec_Decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Decoder", encoding);
            }
            return (MemorySegment)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_IncrementalEncoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_IncrementalEncoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_IncrementalEncoder$descriptor() {
        return PyCodec_IncrementalEncoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_IncrementalEncoder$handle() {
        return PyCodec_IncrementalEncoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalEncoder$address() {
        return PyCodec_IncrementalEncoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalEncoder(MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_IncrementalEncoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_IncrementalEncoder", encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_IncrementalDecoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_IncrementalDecoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_IncrementalDecoder$descriptor() {
        return PyCodec_IncrementalDecoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_IncrementalDecoder$handle() {
        return PyCodec_IncrementalDecoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalDecoder$address() {
        return PyCodec_IncrementalDecoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalDecoder(MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_IncrementalDecoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_IncrementalDecoder", encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_StreamReader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_StreamReader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_StreamReader$descriptor() {
        return PyCodec_StreamReader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_StreamReader$handle() {
        return PyCodec_StreamReader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamReader$address() {
        return PyCodec_StreamReader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamReader(MemorySegment encoding, MemorySegment stream, MemorySegment errors) {
        var mh$ = PyCodec_StreamReader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_StreamReader", encoding, stream, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, stream, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_StreamWriter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_StreamWriter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_StreamWriter$descriptor() {
        return PyCodec_StreamWriter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_StreamWriter$handle() {
        return PyCodec_StreamWriter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamWriter$address() {
        return PyCodec_StreamWriter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamWriter(MemorySegment encoding, MemorySegment stream, MemorySegment errors) {
        var mh$ = PyCodec_StreamWriter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_StreamWriter", encoding, stream, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, stream, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_RegisterError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_RegisterError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static FunctionDescriptor PyCodec_RegisterError$descriptor() {
        return PyCodec_RegisterError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static MethodHandle PyCodec_RegisterError$handle() {
        return PyCodec_RegisterError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static MemorySegment PyCodec_RegisterError$address() {
        return PyCodec_RegisterError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static int PyCodec_RegisterError(MemorySegment name, MemorySegment error) {
        var mh$ = PyCodec_RegisterError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_RegisterError", name, error);
            }
            return (int)mh$.invokeExact(name, error);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_LookupError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_LookupError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static FunctionDescriptor PyCodec_LookupError$descriptor() {
        return PyCodec_LookupError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static MethodHandle PyCodec_LookupError$handle() {
        return PyCodec_LookupError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static MemorySegment PyCodec_LookupError$address() {
        return PyCodec_LookupError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static MemorySegment PyCodec_LookupError(MemorySegment name) {
        var mh$ = PyCodec_LookupError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_LookupError", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_StrictErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_StrictErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_StrictErrors$descriptor() {
        return PyCodec_StrictErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_StrictErrors$handle() {
        return PyCodec_StrictErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_StrictErrors$address() {
        return PyCodec_StrictErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_StrictErrors(MemorySegment exc) {
        var mh$ = PyCodec_StrictErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_StrictErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_IgnoreErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_IgnoreErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_IgnoreErrors$descriptor() {
        return PyCodec_IgnoreErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_IgnoreErrors$handle() {
        return PyCodec_IgnoreErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_IgnoreErrors$address() {
        return PyCodec_IgnoreErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_IgnoreErrors(MemorySegment exc) {
        var mh$ = PyCodec_IgnoreErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_IgnoreErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_ReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_ReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_ReplaceErrors$descriptor() {
        return PyCodec_ReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_ReplaceErrors$handle() {
        return PyCodec_ReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_ReplaceErrors$address() {
        return PyCodec_ReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_ReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_ReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_ReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_XMLCharRefReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_XMLCharRefReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_XMLCharRefReplaceErrors$descriptor() {
        return PyCodec_XMLCharRefReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_XMLCharRefReplaceErrors$handle() {
        return PyCodec_XMLCharRefReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_XMLCharRefReplaceErrors$address() {
        return PyCodec_XMLCharRefReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_XMLCharRefReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_XMLCharRefReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_XMLCharRefReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_BackslashReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_BackslashReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_BackslashReplaceErrors$descriptor() {
        return PyCodec_BackslashReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_BackslashReplaceErrors$handle() {
        return PyCodec_BackslashReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_BackslashReplaceErrors$address() {
        return PyCodec_BackslashReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_BackslashReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_BackslashReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_BackslashReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_NameReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_NameReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_NameReplaceErrors$descriptor() {
        return PyCodec_NameReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_NameReplaceErrors$handle() {
        return PyCodec_NameReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_NameReplaceErrors$address() {
        return PyCodec_NameReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_NameReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_NameReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_NameReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_hexdigits$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_hexdigits").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *Py_hexdigits
     * }
     */
    public static AddressLayout Py_hexdigits$layout() {
        return Py_hexdigits$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *Py_hexdigits
     * }
     */
    public static MemorySegment Py_hexdigits$segment() {
        return Py_hexdigits$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *Py_hexdigits
     * }
     */
    public static MemorySegment Py_hexdigits() {
        return Py_hexdigits$constants.SEGMENT.get(Py_hexdigits$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *Py_hexdigits
     * }
     */
    public static void Py_hexdigits(MemorySegment varValue) {
        Py_hexdigits$constants.SEGMENT.set(Py_hexdigits$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef void *PyThread_type_lock
     * }
     */
    public static final AddressLayout PyThread_type_lock = Python_h.C_POINTER;
    private static final int PY_LOCK_FAILURE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PyLockStatus.PY_LOCK_FAILURE = 0
     * }
     */
    public static int PY_LOCK_FAILURE() {
        return PY_LOCK_FAILURE;
    }
    private static final int PY_LOCK_ACQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PyLockStatus.PY_LOCK_ACQUIRED = 1
     * }
     */
    public static int PY_LOCK_ACQUIRED() {
        return PY_LOCK_ACQUIRED;
    }
    private static final int PY_LOCK_INTR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PyLockStatus.PY_LOCK_INTR = 2
     * }
     */
    public static int PY_LOCK_INTR() {
        return PY_LOCK_INTR;
    }

    private static class PyThread_init_thread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_init_thread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static FunctionDescriptor PyThread_init_thread$descriptor() {
        return PyThread_init_thread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static MethodHandle PyThread_init_thread$handle() {
        return PyThread_init_thread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static MemorySegment PyThread_init_thread$address() {
        return PyThread_init_thread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static void PyThread_init_thread() {
        var mh$ = PyThread_init_thread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_init_thread");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_start_new_thread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_start_new_thread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static FunctionDescriptor PyThread_start_new_thread$descriptor() {
        return PyThread_start_new_thread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static MethodHandle PyThread_start_new_thread$handle() {
        return PyThread_start_new_thread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static MemorySegment PyThread_start_new_thread$address() {
        return PyThread_start_new_thread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static long PyThread_start_new_thread(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyThread_start_new_thread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_start_new_thread", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_exit_thread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_exit_thread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static FunctionDescriptor PyThread_exit_thread$descriptor() {
        return PyThread_exit_thread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static MethodHandle PyThread_exit_thread$handle() {
        return PyThread_exit_thread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static MemorySegment PyThread_exit_thread$address() {
        return PyThread_exit_thread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static void PyThread_exit_thread() {
        var mh$ = PyThread_exit_thread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_exit_thread");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_thread_ident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_thread_ident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static FunctionDescriptor PyThread_get_thread_ident$descriptor() {
        return PyThread_get_thread_ident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static MethodHandle PyThread_get_thread_ident$handle() {
        return PyThread_get_thread_ident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static MemorySegment PyThread_get_thread_ident$address() {
        return PyThread_get_thread_ident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static long PyThread_get_thread_ident() {
        var mh$ = PyThread_get_thread_ident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_thread_ident");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_thread_native_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_thread_native_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static FunctionDescriptor PyThread_get_thread_native_id$descriptor() {
        return PyThread_get_thread_native_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static MethodHandle PyThread_get_thread_native_id$handle() {
        return PyThread_get_thread_native_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static MemorySegment PyThread_get_thread_native_id$address() {
        return PyThread_get_thread_native_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static long PyThread_get_thread_native_id() {
        var mh$ = PyThread_get_thread_native_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_thread_native_id");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_allocate_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_allocate_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static FunctionDescriptor PyThread_allocate_lock$descriptor() {
        return PyThread_allocate_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static MethodHandle PyThread_allocate_lock$handle() {
        return PyThread_allocate_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static MemorySegment PyThread_allocate_lock$address() {
        return PyThread_allocate_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static MemorySegment PyThread_allocate_lock() {
        var mh$ = PyThread_allocate_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_allocate_lock");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_free_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_free_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static FunctionDescriptor PyThread_free_lock$descriptor() {
        return PyThread_free_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static MethodHandle PyThread_free_lock$handle() {
        return PyThread_free_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static MemorySegment PyThread_free_lock$address() {
        return PyThread_free_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static void PyThread_free_lock(MemorySegment x0) {
        var mh$ = PyThread_free_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_free_lock", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_acquire_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_acquire_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static FunctionDescriptor PyThread_acquire_lock$descriptor() {
        return PyThread_acquire_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static MethodHandle PyThread_acquire_lock$handle() {
        return PyThread_acquire_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static MemorySegment PyThread_acquire_lock$address() {
        return PyThread_acquire_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static int PyThread_acquire_lock(MemorySegment x0, int x1) {
        var mh$ = PyThread_acquire_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_acquire_lock", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_acquire_lock_timed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_acquire_lock_timed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static FunctionDescriptor PyThread_acquire_lock_timed$descriptor() {
        return PyThread_acquire_lock_timed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static MethodHandle PyThread_acquire_lock_timed$handle() {
        return PyThread_acquire_lock_timed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static MemorySegment PyThread_acquire_lock_timed$address() {
        return PyThread_acquire_lock_timed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static int PyThread_acquire_lock_timed(MemorySegment x0, long microseconds, int intr_flag) {
        var mh$ = PyThread_acquire_lock_timed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_acquire_lock_timed", x0, microseconds, intr_flag);
            }
            return (int)mh$.invokeExact(x0, microseconds, intr_flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_release_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_release_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static FunctionDescriptor PyThread_release_lock$descriptor() {
        return PyThread_release_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static MethodHandle PyThread_release_lock$handle() {
        return PyThread_release_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static MemorySegment PyThread_release_lock$address() {
        return PyThread_release_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static void PyThread_release_lock(MemorySegment x0) {
        var mh$ = PyThread_release_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_release_lock", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_stacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_stacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static FunctionDescriptor PyThread_get_stacksize$descriptor() {
        return PyThread_get_stacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static MethodHandle PyThread_get_stacksize$handle() {
        return PyThread_get_stacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static MemorySegment PyThread_get_stacksize$address() {
        return PyThread_get_stacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static long PyThread_get_stacksize() {
        var mh$ = PyThread_get_stacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_stacksize");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_set_stacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_set_stacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static FunctionDescriptor PyThread_set_stacksize$descriptor() {
        return PyThread_set_stacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static MethodHandle PyThread_set_stacksize$handle() {
        return PyThread_set_stacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static MemorySegment PyThread_set_stacksize$address() {
        return PyThread_set_stacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static int PyThread_set_stacksize(long x0) {
        var mh$ = PyThread_set_stacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_set_stacksize", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static FunctionDescriptor PyThread_GetInfo$descriptor() {
        return PyThread_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static MethodHandle PyThread_GetInfo$handle() {
        return PyThread_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static MemorySegment PyThread_GetInfo$address() {
        return PyThread_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static MemorySegment PyThread_GetInfo() {
        var mh$ = PyThread_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_GetInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_create_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_create_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static FunctionDescriptor PyThread_create_key$descriptor() {
        return PyThread_create_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static MethodHandle PyThread_create_key$handle() {
        return PyThread_create_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static MemorySegment PyThread_create_key$address() {
        return PyThread_create_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static int PyThread_create_key() {
        var mh$ = PyThread_create_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_create_key");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_delete_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_delete_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static FunctionDescriptor PyThread_delete_key$descriptor() {
        return PyThread_delete_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static MethodHandle PyThread_delete_key$handle() {
        return PyThread_delete_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static MemorySegment PyThread_delete_key$address() {
        return PyThread_delete_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static void PyThread_delete_key(int key) {
        var mh$ = PyThread_delete_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_delete_key", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_set_key_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_set_key_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static FunctionDescriptor PyThread_set_key_value$descriptor() {
        return PyThread_set_key_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static MethodHandle PyThread_set_key_value$handle() {
        return PyThread_set_key_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static MemorySegment PyThread_set_key_value$address() {
        return PyThread_set_key_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static int PyThread_set_key_value(int key, MemorySegment value) {
        var mh$ = PyThread_set_key_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_set_key_value", key, value);
            }
            return (int)mh$.invokeExact(key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_key_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_key_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static FunctionDescriptor PyThread_get_key_value$descriptor() {
        return PyThread_get_key_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static MethodHandle PyThread_get_key_value$handle() {
        return PyThread_get_key_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static MemorySegment PyThread_get_key_value$address() {
        return PyThread_get_key_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static MemorySegment PyThread_get_key_value(int key) {
        var mh$ = PyThread_get_key_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_key_value", key);
            }
            return (MemorySegment)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_delete_key_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_delete_key_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static FunctionDescriptor PyThread_delete_key_value$descriptor() {
        return PyThread_delete_key_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static MethodHandle PyThread_delete_key_value$handle() {
        return PyThread_delete_key_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static MemorySegment PyThread_delete_key_value$address() {
        return PyThread_delete_key_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static void PyThread_delete_key_value(int key) {
        var mh$ = PyThread_delete_key_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_delete_key_value", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_ReInitTLS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_ReInitTLS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static FunctionDescriptor PyThread_ReInitTLS$descriptor() {
        return PyThread_ReInitTLS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static MethodHandle PyThread_ReInitTLS$handle() {
        return PyThread_ReInitTLS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static MemorySegment PyThread_ReInitTLS$address() {
        return PyThread_ReInitTLS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static void PyThread_ReInitTLS() {
        var mh$ = PyThread_ReInitTLS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_ReInitTLS");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static FunctionDescriptor PyThread_tss_alloc$descriptor() {
        return PyThread_tss_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static MethodHandle PyThread_tss_alloc$handle() {
        return PyThread_tss_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static MemorySegment PyThread_tss_alloc$address() {
        return PyThread_tss_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static MemorySegment PyThread_tss_alloc() {
        var mh$ = PyThread_tss_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_free$descriptor() {
        return PyThread_tss_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_free$handle() {
        return PyThread_tss_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_free$address() {
        return PyThread_tss_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static void PyThread_tss_free(MemorySegment key) {
        var mh$ = PyThread_tss_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_free", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_is_created {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_is_created");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_is_created$descriptor() {
        return PyThread_tss_is_created.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_is_created$handle() {
        return PyThread_tss_is_created.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_is_created$address() {
        return PyThread_tss_is_created.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static int PyThread_tss_is_created(MemorySegment key) {
        var mh$ = PyThread_tss_is_created.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_is_created", key);
            }
            return (int)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_create$descriptor() {
        return PyThread_tss_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_create$handle() {
        return PyThread_tss_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_create$address() {
        return PyThread_tss_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static int PyThread_tss_create(MemorySegment key) {
        var mh$ = PyThread_tss_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_create", key);
            }
            return (int)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_delete$descriptor() {
        return PyThread_tss_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_delete$handle() {
        return PyThread_tss_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_delete$address() {
        return PyThread_tss_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static void PyThread_tss_delete(MemorySegment key) {
        var mh$ = PyThread_tss_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_delete", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static FunctionDescriptor PyThread_tss_set$descriptor() {
        return PyThread_tss_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static MethodHandle PyThread_tss_set$handle() {
        return PyThread_tss_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static MemorySegment PyThread_tss_set$address() {
        return PyThread_tss_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static int PyThread_tss_set(MemorySegment key, MemorySegment value) {
        var mh$ = PyThread_tss_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_set", key, value);
            }
            return (int)mh$.invokeExact(key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_get$descriptor() {
        return PyThread_tss_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_get$handle() {
        return PyThread_tss_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_get$address() {
        return PyThread_tss_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_get(MemorySegment key) {
        var mh$ = PyThread_tss_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_get", key);
            }
            return (MemorySegment)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PY_TIMEOUT_MAX$constants {
        public static final OfLong LAYOUT = Python_h.C_LONG_LONG;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PY_TIMEOUT_MAX").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const long long PY_TIMEOUT_MAX
     * }
     */
    public static OfLong PY_TIMEOUT_MAX$layout() {
        return PY_TIMEOUT_MAX$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const long long PY_TIMEOUT_MAX
     * }
     */
    public static MemorySegment PY_TIMEOUT_MAX$segment() {
        return PY_TIMEOUT_MAX$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const long long PY_TIMEOUT_MAX
     * }
     */
    public static long PY_TIMEOUT_MAX() {
        return PY_TIMEOUT_MAX$constants.SEGMENT.get(PY_TIMEOUT_MAX$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const long long PY_TIMEOUT_MAX
     * }
     */
    public static void PY_TIMEOUT_MAX(long varValue) {
        PY_TIMEOUT_MAX$constants.SEGMENT.set(PY_TIMEOUT_MAX$constants.LAYOUT, 0L, varValue);
    }

    private static class sched_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sched_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static FunctionDescriptor sched_yield$descriptor() {
        return sched_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MethodHandle sched_yield$handle() {
        return sched_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MemorySegment sched_yield$address() {
        return sched_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static int sched_yield() {
        var mh$ = sched_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_yield");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sched_get_priority_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int)
     * }
     */
    public static FunctionDescriptor sched_get_priority_min$descriptor() {
        return sched_get_priority_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int)
     * }
     */
    public static MethodHandle sched_get_priority_min$handle() {
        return sched_get_priority_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int)
     * }
     */
    public static MemorySegment sched_get_priority_min$address() {
        return sched_get_priority_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int)
     * }
     */
    public static int sched_get_priority_min(int x0) {
        var mh$ = sched_get_priority_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_min", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sched_get_priority_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int)
     * }
     */
    public static FunctionDescriptor sched_get_priority_max$descriptor() {
        return sched_get_priority_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int)
     * }
     */
    public static MethodHandle sched_get_priority_max$handle() {
        return sched_get_priority_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int)
     * }
     */
    public static MemorySegment sched_get_priority_max$address() {
        return sched_get_priority_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int)
     * }
     */
    public static int sched_get_priority_max(int x0) {
        var mh$ = sched_get_priority_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_max", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int QOS_CLASS_USER_INTERACTIVE = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_USER_INTERACTIVE = 33
     * }
     */
    public static int QOS_CLASS_USER_INTERACTIVE() {
        return QOS_CLASS_USER_INTERACTIVE;
    }
    private static final int QOS_CLASS_USER_INITIATED = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_USER_INITIATED = 25
     * }
     */
    public static int QOS_CLASS_USER_INITIATED() {
        return QOS_CLASS_USER_INITIATED;
    }
    private static final int QOS_CLASS_DEFAULT = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_DEFAULT = 21
     * }
     */
    public static int QOS_CLASS_DEFAULT() {
        return QOS_CLASS_DEFAULT;
    }
    private static final int QOS_CLASS_UTILITY = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_UTILITY = 17
     * }
     */
    public static int QOS_CLASS_UTILITY() {
        return QOS_CLASS_UTILITY;
    }
    private static final int QOS_CLASS_BACKGROUND = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_BACKGROUND = 9
     * }
     */
    public static int QOS_CLASS_BACKGROUND() {
        return QOS_CLASS_BACKGROUND;
    }
    private static final int QOS_CLASS_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_UNSPECIFIED = 0
     * }
     */
    public static int QOS_CLASS_UNSPECIFIED() {
        return QOS_CLASS_UNSPECIFIED;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int qos_class_t
     * }
     */
    public static final OfInt qos_class_t = Python_h.C_INT;

    private static class qos_class_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qos_class_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static FunctionDescriptor qos_class_self$descriptor() {
        return qos_class_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static MethodHandle qos_class_self$handle() {
        return qos_class_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static MemorySegment qos_class_self$address() {
        return qos_class_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static int qos_class_self() {
        var mh$ = qos_class_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qos_class_self");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qos_class_main {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qos_class_main");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static FunctionDescriptor qos_class_main$descriptor() {
        return qos_class_main.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static MethodHandle qos_class_main$handle() {
        return qos_class_main.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static MemorySegment qos_class_main$address() {
        return qos_class_main.ADDR;
    }

    /**
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static int qos_class_main() {
        var mh$ = qos_class_main.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qos_class_main");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_set_qos_class_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_set_qos_class_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_set_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_attr_set_qos_class_np$descriptor() {
        return pthread_attr_set_qos_class_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_set_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MethodHandle pthread_attr_set_qos_class_np$handle() {
        return pthread_attr_set_qos_class_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_set_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MemorySegment pthread_attr_set_qos_class_np$address() {
        return pthread_attr_set_qos_class_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_set_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static int pthread_attr_set_qos_class_np(MemorySegment __attr, int __qos_class, int __relative_priority) {
        var mh$ = pthread_attr_set_qos_class_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_set_qos_class_np", __attr, __qos_class, __relative_priority);
            }
            return (int)mh$.invokeExact(__attr, __qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_get_qos_class_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_get_qos_class_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_get_qos_class_np(pthread_attr_t *restrict  _Nonnull __attr, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_attr_get_qos_class_np$descriptor() {
        return pthread_attr_get_qos_class_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_get_qos_class_np(pthread_attr_t *restrict  _Nonnull __attr, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static MethodHandle pthread_attr_get_qos_class_np$handle() {
        return pthread_attr_get_qos_class_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_get_qos_class_np(pthread_attr_t *restrict  _Nonnull __attr, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static MemorySegment pthread_attr_get_qos_class_np$address() {
        return pthread_attr_get_qos_class_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_get_qos_class_np(pthread_attr_t *restrict  _Nonnull __attr, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static int pthread_attr_get_qos_class_np(MemorySegment __attr, MemorySegment __qos_class, MemorySegment __relative_priority) {
        var mh$ = pthread_attr_get_qos_class_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_get_qos_class_np", __attr, __qos_class, __relative_priority);
            }
            return (int)mh$.invokeExact(__attr, __qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_set_qos_class_self_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_set_qos_class_self_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_set_qos_class_self_np$descriptor() {
        return pthread_set_qos_class_self_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MethodHandle pthread_set_qos_class_self_np$handle() {
        return pthread_set_qos_class_self_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MemorySegment pthread_set_qos_class_self_np$address() {
        return pthread_set_qos_class_self_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static int pthread_set_qos_class_self_np(int __qos_class, int __relative_priority) {
        var mh$ = pthread_set_qos_class_self_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_set_qos_class_self_np", __qos_class, __relative_priority);
            }
            return (int)mh$.invokeExact(__qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_get_qos_class_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_get_qos_class_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_get_qos_class_np$descriptor() {
        return pthread_get_qos_class_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static MethodHandle pthread_get_qos_class_np$handle() {
        return pthread_get_qos_class_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static MemorySegment pthread_get_qos_class_np$address() {
        return pthread_get_qos_class_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static int pthread_get_qos_class_np(MemorySegment __pthread, MemorySegment __qos_class, MemorySegment __relative_priority) {
        var mh$ = pthread_get_qos_class_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_get_qos_class_np", __pthread, __qos_class, __relative_priority);
            }
            return (int)mh$.invokeExact(__pthread, __qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct pthread_override_s *pthread_override_t
     * }
     */
    public static final AddressLayout pthread_override_t = Python_h.C_POINTER;

    private static class pthread_override_qos_class_start_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_override_qos_class_start_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pthread_override_t  _Nonnull pthread_override_qos_class_start_np(pthread_t  _Nonnull __pthread, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_override_qos_class_start_np$descriptor() {
        return pthread_override_qos_class_start_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pthread_override_t  _Nonnull pthread_override_qos_class_start_np(pthread_t  _Nonnull __pthread, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MethodHandle pthread_override_qos_class_start_np$handle() {
        return pthread_override_qos_class_start_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pthread_override_t  _Nonnull pthread_override_qos_class_start_np(pthread_t  _Nonnull __pthread, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MemorySegment pthread_override_qos_class_start_np$address() {
        return pthread_override_qos_class_start_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pthread_override_t  _Nonnull pthread_override_qos_class_start_np(pthread_t  _Nonnull __pthread, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MemorySegment pthread_override_qos_class_start_np(MemorySegment __pthread, int __qos_class, int __relative_priority) {
        var mh$ = pthread_override_qos_class_start_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_override_qos_class_start_np", __pthread, __qos_class, __relative_priority);
            }
            return (MemorySegment)mh$.invokeExact(__pthread, __qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_override_qos_class_end_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_override_qos_class_end_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_override_qos_class_end_np(pthread_override_t  _Nonnull __override)
     * }
     */
    public static FunctionDescriptor pthread_override_qos_class_end_np$descriptor() {
        return pthread_override_qos_class_end_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_override_qos_class_end_np(pthread_override_t  _Nonnull __override)
     * }
     */
    public static MethodHandle pthread_override_qos_class_end_np$handle() {
        return pthread_override_qos_class_end_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_override_qos_class_end_np(pthread_override_t  _Nonnull __override)
     * }
     */
    public static MemorySegment pthread_override_qos_class_end_np$address() {
        return pthread_override_qos_class_end_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_override_qos_class_end_np(pthread_override_t  _Nonnull __override)
     * }
     */
    public static int pthread_override_qos_class_end_np(MemorySegment __override) {
        var mh$ = pthread_override_qos_class_end_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_override_qos_class_end_np", __override);
            }
            return (int)mh$.invokeExact(__override);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_t mach_port_t
     * }
     */
    public static final OfInt mach_port_t = Python_h.C_INT;

    private static class pthread_atfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_atfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void), void (* _Nullable)(void))
     * }
     */
    public static FunctionDescriptor pthread_atfork$descriptor() {
        return pthread_atfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void), void (* _Nullable)(void))
     * }
     */
    public static MethodHandle pthread_atfork$handle() {
        return pthread_atfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void), void (* _Nullable)(void))
     * }
     */
    public static MemorySegment pthread_atfork$address() {
        return pthread_atfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void), void (* _Nullable)(void))
     * }
     */
    public static int pthread_atfork(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_atfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_atfork", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_destroy(pthread_attr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_destroy$descriptor() {
        return pthread_attr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_destroy(pthread_attr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_destroy$handle() {
        return pthread_attr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_destroy(pthread_attr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_destroy$address() {
        return pthread_attr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_destroy(pthread_attr_t * _Nonnull)
     * }
     */
    public static int pthread_attr_destroy(MemorySegment x0) {
        var mh$ = pthread_attr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getdetachstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getdetachstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getdetachstate(const pthread_attr_t * _Nonnull, int * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getdetachstate$descriptor() {
        return pthread_attr_getdetachstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getdetachstate(const pthread_attr_t * _Nonnull, int * _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getdetachstate$handle() {
        return pthread_attr_getdetachstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getdetachstate(const pthread_attr_t * _Nonnull, int * _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getdetachstate$address() {
        return pthread_attr_getdetachstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getdetachstate(const pthread_attr_t * _Nonnull, int * _Nonnull)
     * }
     */
    public static int pthread_attr_getdetachstate(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getdetachstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getdetachstate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getguardsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getguardsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getguardsize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getguardsize$descriptor() {
        return pthread_attr_getguardsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getguardsize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getguardsize$handle() {
        return pthread_attr_getguardsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getguardsize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getguardsize$address() {
        return pthread_attr_getguardsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getguardsize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getguardsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getguardsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getguardsize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getinheritsched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getinheritsched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getinheritsched(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getinheritsched$descriptor() {
        return pthread_attr_getinheritsched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getinheritsched(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getinheritsched$handle() {
        return pthread_attr_getinheritsched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getinheritsched(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getinheritsched$address() {
        return pthread_attr_getinheritsched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getinheritsched(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getinheritsched(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getinheritsched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getinheritsched", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getschedparam(const pthread_attr_t *restrict _Nonnull, struct sched_param *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getschedparam$descriptor() {
        return pthread_attr_getschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getschedparam(const pthread_attr_t *restrict _Nonnull, struct sched_param *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getschedparam$handle() {
        return pthread_attr_getschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getschedparam(const pthread_attr_t *restrict _Nonnull, struct sched_param *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getschedparam$address() {
        return pthread_attr_getschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getschedparam(const pthread_attr_t *restrict _Nonnull, struct sched_param *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getschedparam(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getschedparam", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getschedpolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getschedpolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getschedpolicy(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getschedpolicy$descriptor() {
        return pthread_attr_getschedpolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getschedpolicy(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getschedpolicy$handle() {
        return pthread_attr_getschedpolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getschedpolicy(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getschedpolicy$address() {
        return pthread_attr_getschedpolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getschedpolicy(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getschedpolicy(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getschedpolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getschedpolicy", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getscope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getscope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getscope(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getscope$descriptor() {
        return pthread_attr_getscope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getscope(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getscope$handle() {
        return pthread_attr_getscope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getscope(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getscope$address() {
        return pthread_attr_getscope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getscope(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getscope(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getscope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getscope", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getstack(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstack$descriptor() {
        return pthread_attr_getstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getstack(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getstack$handle() {
        return pthread_attr_getstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getstack(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getstack$address() {
        return pthread_attr_getstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getstack(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getstack(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_attr_getstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstack", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstackaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getstackaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getstackaddr(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstackaddr$descriptor() {
        return pthread_attr_getstackaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getstackaddr(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getstackaddr$handle() {
        return pthread_attr_getstackaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getstackaddr(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getstackaddr$address() {
        return pthread_attr_getstackaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getstackaddr(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getstackaddr(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getstackaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstackaddr", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getstacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getstacksize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstacksize$descriptor() {
        return pthread_attr_getstacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getstacksize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getstacksize$handle() {
        return pthread_attr_getstacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getstacksize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getstacksize$address() {
        return pthread_attr_getstacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getstacksize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getstacksize(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getstacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstacksize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_init(pthread_attr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_init$descriptor() {
        return pthread_attr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_init(pthread_attr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_init$handle() {
        return pthread_attr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_init(pthread_attr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_init$address() {
        return pthread_attr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_init(pthread_attr_t * _Nonnull)
     * }
     */
    public static int pthread_attr_init(MemorySegment x0) {
        var mh$ = pthread_attr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_init", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setdetachstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setdetachstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setdetachstate(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_attr_setdetachstate$descriptor() {
        return pthread_attr_setdetachstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setdetachstate(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_attr_setdetachstate$handle() {
        return pthread_attr_setdetachstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setdetachstate(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_attr_setdetachstate$address() {
        return pthread_attr_setdetachstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setdetachstate(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static int pthread_attr_setdetachstate(MemorySegment x0, int x1) {
        var mh$ = pthread_attr_setdetachstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setdetachstate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setguardsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setguardsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setguardsize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static FunctionDescriptor pthread_attr_setguardsize$descriptor() {
        return pthread_attr_setguardsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setguardsize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static MethodHandle pthread_attr_setguardsize$handle() {
        return pthread_attr_setguardsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setguardsize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static MemorySegment pthread_attr_setguardsize$address() {
        return pthread_attr_setguardsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setguardsize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static int pthread_attr_setguardsize(MemorySegment x0, long x1) {
        var mh$ = pthread_attr_setguardsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setguardsize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setinheritsched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setinheritsched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setinheritsched(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_attr_setinheritsched$descriptor() {
        return pthread_attr_setinheritsched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setinheritsched(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_attr_setinheritsched$handle() {
        return pthread_attr_setinheritsched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setinheritsched(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_attr_setinheritsched$address() {
        return pthread_attr_setinheritsched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setinheritsched(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static int pthread_attr_setinheritsched(MemorySegment x0, int x1) {
        var mh$ = pthread_attr_setinheritsched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setinheritsched", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setschedparam(pthread_attr_t *restrict _Nonnull, const struct sched_param *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_setschedparam$descriptor() {
        return pthread_attr_setschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setschedparam(pthread_attr_t *restrict _Nonnull, const struct sched_param *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_setschedparam$handle() {
        return pthread_attr_setschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setschedparam(pthread_attr_t *restrict _Nonnull, const struct sched_param *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_setschedparam$address() {
        return pthread_attr_setschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setschedparam(pthread_attr_t *restrict _Nonnull, const struct sched_param *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_setschedparam(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_setschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setschedparam", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setschedpolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setschedpolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setschedpolicy(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_attr_setschedpolicy$descriptor() {
        return pthread_attr_setschedpolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setschedpolicy(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_attr_setschedpolicy$handle() {
        return pthread_attr_setschedpolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setschedpolicy(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_attr_setschedpolicy$address() {
        return pthread_attr_setschedpolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setschedpolicy(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static int pthread_attr_setschedpolicy(MemorySegment x0, int x1) {
        var mh$ = pthread_attr_setschedpolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setschedpolicy", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setscope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setscope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setscope(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_attr_setscope$descriptor() {
        return pthread_attr_setscope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setscope(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_attr_setscope$handle() {
        return pthread_attr_setscope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setscope(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_attr_setscope$address() {
        return pthread_attr_setscope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setscope(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static int pthread_attr_setscope(MemorySegment x0, int x1) {
        var mh$ = pthread_attr_setscope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setscope", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setstack(pthread_attr_t * _Nonnull, void * _Nonnull, size_t)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstack$descriptor() {
        return pthread_attr_setstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setstack(pthread_attr_t * _Nonnull, void * _Nonnull, size_t)
     * }
     */
    public static MethodHandle pthread_attr_setstack$handle() {
        return pthread_attr_setstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setstack(pthread_attr_t * _Nonnull, void * _Nonnull, size_t)
     * }
     */
    public static MemorySegment pthread_attr_setstack$address() {
        return pthread_attr_setstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setstack(pthread_attr_t * _Nonnull, void * _Nonnull, size_t)
     * }
     */
    public static int pthread_attr_setstack(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = pthread_attr_setstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstack", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstackaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setstackaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setstackaddr(pthread_attr_t * _Nonnull, void * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstackaddr$descriptor() {
        return pthread_attr_setstackaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setstackaddr(pthread_attr_t * _Nonnull, void * _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_setstackaddr$handle() {
        return pthread_attr_setstackaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setstackaddr(pthread_attr_t * _Nonnull, void * _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_setstackaddr$address() {
        return pthread_attr_setstackaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setstackaddr(pthread_attr_t * _Nonnull, void * _Nonnull)
     * }
     */
    public static int pthread_attr_setstackaddr(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_setstackaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstackaddr", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setstacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setstacksize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstacksize$descriptor() {
        return pthread_attr_setstacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setstacksize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static MethodHandle pthread_attr_setstacksize$handle() {
        return pthread_attr_setstacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setstacksize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static MemorySegment pthread_attr_setstacksize$address() {
        return pthread_attr_setstacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setstacksize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static int pthread_attr_setstacksize(MemorySegment x0, long x1) {
        var mh$ = pthread_attr_setstacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstacksize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cancel(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cancel$descriptor() {
        return pthread_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cancel(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_cancel$handle() {
        return pthread_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cancel(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_cancel$address() {
        return pthread_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cancel(pthread_t _Nonnull)
     * }
     */
    public static int pthread_cancel(MemorySegment x0) {
        var mh$ = pthread_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cancel", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_broadcast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_broadcast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_broadcast(pthread_cond_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cond_broadcast$descriptor() {
        return pthread_cond_broadcast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_broadcast(pthread_cond_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_cond_broadcast$handle() {
        return pthread_cond_broadcast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_broadcast(pthread_cond_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_cond_broadcast$address() {
        return pthread_cond_broadcast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_broadcast(pthread_cond_t * _Nonnull)
     * }
     */
    public static int pthread_cond_broadcast(MemorySegment x0) {
        var mh$ = pthread_cond_broadcast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_broadcast", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_destroy(pthread_cond_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cond_destroy$descriptor() {
        return pthread_cond_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_destroy(pthread_cond_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_cond_destroy$handle() {
        return pthread_cond_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_destroy(pthread_cond_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_cond_destroy$address() {
        return pthread_cond_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_destroy(pthread_cond_t * _Nonnull)
     * }
     */
    public static int pthread_cond_destroy(MemorySegment x0) {
        var mh$ = pthread_cond_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_init(pthread_cond_t *restrict _Nonnull, const pthread_condattr_t *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_cond_init$descriptor() {
        return pthread_cond_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_init(pthread_cond_t *restrict _Nonnull, const pthread_condattr_t *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_cond_init$handle() {
        return pthread_cond_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_init(pthread_cond_t *restrict _Nonnull, const pthread_condattr_t *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_cond_init$address() {
        return pthread_cond_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_init(pthread_cond_t *restrict _Nonnull, const pthread_condattr_t *restrict _Nullable)
     * }
     */
    public static int pthread_cond_init(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_cond_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_init", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_signal(pthread_cond_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cond_signal$descriptor() {
        return pthread_cond_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_signal(pthread_cond_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_cond_signal$handle() {
        return pthread_cond_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_signal(pthread_cond_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_cond_signal$address() {
        return pthread_cond_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_signal(pthread_cond_t * _Nonnull)
     * }
     */
    public static int pthread_cond_signal(MemorySegment x0) {
        var mh$ = pthread_cond_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_signal", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_timedwait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_timedwait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull, const struct timespec *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_cond_timedwait$descriptor() {
        return pthread_cond_timedwait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull, const struct timespec *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_cond_timedwait$handle() {
        return pthread_cond_timedwait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull, const struct timespec *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_cond_timedwait$address() {
        return pthread_cond_timedwait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_timedwait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull, const struct timespec *restrict _Nullable)
     * }
     */
    public static int pthread_cond_timedwait(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_cond_timedwait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_timedwait", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_wait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cond_wait$descriptor() {
        return pthread_cond_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_wait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_cond_wait$handle() {
        return pthread_cond_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_wait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_cond_wait$address() {
        return pthread_cond_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_wait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull)
     * }
     */
    public static int pthread_cond_wait(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_cond_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_wait", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_condattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_condattr_destroy(pthread_condattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_condattr_destroy$descriptor() {
        return pthread_condattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_condattr_destroy(pthread_condattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_condattr_destroy$handle() {
        return pthread_condattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_condattr_destroy(pthread_condattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_condattr_destroy$address() {
        return pthread_condattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_condattr_destroy(pthread_condattr_t * _Nonnull)
     * }
     */
    public static int pthread_condattr_destroy(MemorySegment x0) {
        var mh$ = pthread_condattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_condattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_condattr_init(pthread_condattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_condattr_init$descriptor() {
        return pthread_condattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_condattr_init(pthread_condattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_condattr_init$handle() {
        return pthread_condattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_condattr_init(pthread_condattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_condattr_init$address() {
        return pthread_condattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_condattr_init(pthread_condattr_t * _Nonnull)
     * }
     */
    public static int pthread_condattr_init(MemorySegment x0) {
        var mh$ = pthread_condattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_init", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_condattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_condattr_getpshared(const pthread_condattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_condattr_getpshared$descriptor() {
        return pthread_condattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_condattr_getpshared(const pthread_condattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_condattr_getpshared$handle() {
        return pthread_condattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_condattr_getpshared(const pthread_condattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_condattr_getpshared$address() {
        return pthread_condattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_condattr_getpshared(const pthread_condattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_condattr_getpshared(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_condattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_getpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_condattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_condattr_setpshared(pthread_condattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_condattr_setpshared$descriptor() {
        return pthread_condattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_condattr_setpshared(pthread_condattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_condattr_setpshared$handle() {
        return pthread_condattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_condattr_setpshared(pthread_condattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_condattr_setpshared$address() {
        return pthread_condattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_condattr_setpshared(pthread_condattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_condattr_setpshared(MemorySegment x0, int x1) {
        var mh$ = pthread_condattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_setpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_create(pthread_t  _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_create$descriptor() {
        return pthread_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_create(pthread_t  _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_create$handle() {
        return pthread_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_create(pthread_t  _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_create$address() {
        return pthread_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_create(pthread_t  _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)
     * }
     */
    public static int pthread_create(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = pthread_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_create", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_detach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_detach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_detach(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_detach$descriptor() {
        return pthread_detach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_detach(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_detach$handle() {
        return pthread_detach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_detach(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_detach$address() {
        return pthread_detach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_detach(pthread_t _Nonnull)
     * }
     */
    public static int pthread_detach(MemorySegment x0) {
        var mh$ = pthread_detach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_detach", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_equal(pthread_t _Nullable, pthread_t _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_equal$descriptor() {
        return pthread_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_equal(pthread_t _Nullable, pthread_t _Nullable)
     * }
     */
    public static MethodHandle pthread_equal$handle() {
        return pthread_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_equal(pthread_t _Nullable, pthread_t _Nullable)
     * }
     */
    public static MemorySegment pthread_equal$address() {
        return pthread_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_equal(pthread_t _Nullable, pthread_t _Nullable)
     * }
     */
    public static int pthread_equal(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_equal", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_exit(void * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_exit$descriptor() {
        return pthread_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_exit(void * _Nullable)
     * }
     */
    public static MethodHandle pthread_exit$handle() {
        return pthread_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_exit(void * _Nullable)
     * }
     */
    public static MemorySegment pthread_exit$address() {
        return pthread_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_exit(void * _Nullable)
     * }
     */
    public static void pthread_exit(MemorySegment x0) {
        var mh$ = pthread_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getconcurrency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getconcurrency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getconcurrency()
     * }
     */
    public static FunctionDescriptor pthread_getconcurrency$descriptor() {
        return pthread_getconcurrency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getconcurrency()
     * }
     */
    public static MethodHandle pthread_getconcurrency$handle() {
        return pthread_getconcurrency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getconcurrency()
     * }
     */
    public static MemorySegment pthread_getconcurrency$address() {
        return pthread_getconcurrency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getconcurrency()
     * }
     */
    public static int pthread_getconcurrency() {
        var mh$ = pthread_getconcurrency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getconcurrency");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getschedparam(pthread_t _Nonnull, int *restrict _Nullable, struct sched_param *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_getschedparam$descriptor() {
        return pthread_getschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getschedparam(pthread_t _Nonnull, int *restrict _Nullable, struct sched_param *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_getschedparam$handle() {
        return pthread_getschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getschedparam(pthread_t _Nonnull, int *restrict _Nullable, struct sched_param *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_getschedparam$address() {
        return pthread_getschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getschedparam(pthread_t _Nonnull, int *restrict _Nullable, struct sched_param *restrict _Nullable)
     * }
     */
    public static int pthread_getschedparam(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_getschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getschedparam", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getspecific {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getspecific");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void * _Nullable pthread_getspecific(pthread_key_t)
     * }
     */
    public static FunctionDescriptor pthread_getspecific$descriptor() {
        return pthread_getspecific.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void * _Nullable pthread_getspecific(pthread_key_t)
     * }
     */
    public static MethodHandle pthread_getspecific$handle() {
        return pthread_getspecific.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void * _Nullable pthread_getspecific(pthread_key_t)
     * }
     */
    public static MemorySegment pthread_getspecific$address() {
        return pthread_getspecific.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void * _Nullable pthread_getspecific(pthread_key_t)
     * }
     */
    public static MemorySegment pthread_getspecific(long x0) {
        var mh$ = pthread_getspecific.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getspecific", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_join(pthread_t _Nonnull, void * _Nullable * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_join$descriptor() {
        return pthread_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_join(pthread_t _Nonnull, void * _Nullable * _Nullable)
     * }
     */
    public static MethodHandle pthread_join$handle() {
        return pthread_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_join(pthread_t _Nonnull, void * _Nullable * _Nullable)
     * }
     */
    public static MemorySegment pthread_join$address() {
        return pthread_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_join(pthread_t _Nonnull, void * _Nullable * _Nullable)
     * }
     */
    public static int pthread_join(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_join", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_key_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_key_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_key_create(pthread_key_t * _Nonnull, void (* _Nullable)(void * _Nonnull))
     * }
     */
    public static FunctionDescriptor pthread_key_create$descriptor() {
        return pthread_key_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_key_create(pthread_key_t * _Nonnull, void (* _Nullable)(void * _Nonnull))
     * }
     */
    public static MethodHandle pthread_key_create$handle() {
        return pthread_key_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_key_create(pthread_key_t * _Nonnull, void (* _Nullable)(void * _Nonnull))
     * }
     */
    public static MemorySegment pthread_key_create$address() {
        return pthread_key_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_key_create(pthread_key_t * _Nonnull, void (* _Nullable)(void * _Nonnull))
     * }
     */
    public static int pthread_key_create(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_key_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_key_create", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_key_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_key_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_key_delete(pthread_key_t)
     * }
     */
    public static FunctionDescriptor pthread_key_delete$descriptor() {
        return pthread_key_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_key_delete(pthread_key_t)
     * }
     */
    public static MethodHandle pthread_key_delete$handle() {
        return pthread_key_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_key_delete(pthread_key_t)
     * }
     */
    public static MemorySegment pthread_key_delete$address() {
        return pthread_key_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_key_delete(pthread_key_t)
     * }
     */
    public static int pthread_key_delete(long x0) {
        var mh$ = pthread_key_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_key_delete", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_destroy(pthread_mutex_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_destroy$descriptor() {
        return pthread_mutex_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_destroy(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_destroy$handle() {
        return pthread_mutex_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_destroy(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_destroy$address() {
        return pthread_mutex_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_destroy(pthread_mutex_t * _Nonnull)
     * }
     */
    public static int pthread_mutex_destroy(MemorySegment x0) {
        var mh$ = pthread_mutex_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_getprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_getprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_getprioceiling$descriptor() {
        return pthread_mutex_getprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_getprioceiling$handle() {
        return pthread_mutex_getprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_getprioceiling$address() {
        return pthread_mutex_getprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutex_getprioceiling(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutex_getprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_getprioceiling", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_mutex_init$descriptor() {
        return pthread_mutex_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_mutex_init$handle() {
        return pthread_mutex_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_mutex_init$address() {
        return pthread_mutex_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable)
     * }
     */
    public static int pthread_mutex_init(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutex_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_init", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_lock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_lock$descriptor() {
        return pthread_mutex_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_lock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_lock$handle() {
        return pthread_mutex_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_lock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_lock$address() {
        return pthread_mutex_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_lock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static int pthread_mutex_lock(MemorySegment x0) {
        var mh$ = pthread_mutex_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_lock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_setprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_setprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_setprioceiling(pthread_mutex_t *restrict _Nonnull, int, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_setprioceiling$descriptor() {
        return pthread_mutex_setprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_setprioceiling(pthread_mutex_t *restrict _Nonnull, int, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_setprioceiling$handle() {
        return pthread_mutex_setprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_setprioceiling(pthread_mutex_t *restrict _Nonnull, int, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_setprioceiling$address() {
        return pthread_mutex_setprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_setprioceiling(pthread_mutex_t *restrict _Nonnull, int, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutex_setprioceiling(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = pthread_mutex_setprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_setprioceiling", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_trylock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_trylock$descriptor() {
        return pthread_mutex_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_trylock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_trylock$handle() {
        return pthread_mutex_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_trylock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_trylock$address() {
        return pthread_mutex_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_trylock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static int pthread_mutex_trylock(MemorySegment x0) {
        var mh$ = pthread_mutex_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_trylock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_unlock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_unlock$descriptor() {
        return pthread_mutex_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_unlock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_unlock$handle() {
        return pthread_mutex_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_unlock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_unlock$address() {
        return pthread_mutex_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_unlock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static int pthread_mutex_unlock(MemorySegment x0) {
        var mh$ = pthread_mutex_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_unlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_destroy(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_destroy$descriptor() {
        return pthread_mutexattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_destroy(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_destroy$handle() {
        return pthread_mutexattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_destroy(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_destroy$address() {
        return pthread_mutexattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_destroy(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static int pthread_mutexattr_destroy(MemorySegment x0) {
        var mh$ = pthread_mutexattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_getprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getprioceiling$descriptor() {
        return pthread_mutexattr_getprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_getprioceiling$handle() {
        return pthread_mutexattr_getprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_getprioceiling$address() {
        return pthread_mutexattr_getprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_getprioceiling(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_getprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getprioceiling", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getprotocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_getprotocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getprotocol$descriptor() {
        return pthread_mutexattr_getprotocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_getprotocol$handle() {
        return pthread_mutexattr_getprotocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_getprotocol$address() {
        return pthread_mutexattr_getprotocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_getprotocol(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_getprotocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getprotocol", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getpshared$descriptor() {
        return pthread_mutexattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_getpshared$handle() {
        return pthread_mutexattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_getpshared$address() {
        return pthread_mutexattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_getpshared(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_gettype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_gettype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_gettype$descriptor() {
        return pthread_mutexattr_gettype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_gettype$handle() {
        return pthread_mutexattr_gettype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_gettype$address() {
        return pthread_mutexattr_gettype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_gettype(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_gettype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_gettype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getpolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_getpolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getpolicy_np$descriptor() {
        return pthread_mutexattr_getpolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_getpolicy_np$handle() {
        return pthread_mutexattr_getpolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_getpolicy_np$address() {
        return pthread_mutexattr_getpolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_getpolicy_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_getpolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getpolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_init(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_init$descriptor() {
        return pthread_mutexattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_init(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_init$handle() {
        return pthread_mutexattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_init(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_init$address() {
        return pthread_mutexattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_init(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static int pthread_mutexattr_init(MemorySegment x0) {
        var mh$ = pthread_mutexattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_init", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_setprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setprioceiling$descriptor() {
        return pthread_mutexattr_setprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_setprioceiling$handle() {
        return pthread_mutexattr_setprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_setprioceiling$address() {
        return pthread_mutexattr_setprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_setprioceiling(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_setprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setprioceiling", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setprotocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_setprotocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprotocol(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setprotocol$descriptor() {
        return pthread_mutexattr_setprotocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprotocol(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_setprotocol$handle() {
        return pthread_mutexattr_setprotocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprotocol(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_setprotocol$address() {
        return pthread_mutexattr_setprotocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_setprotocol(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_setprotocol(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_setprotocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setprotocol", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpshared(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setpshared$descriptor() {
        return pthread_mutexattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpshared(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_setpshared$handle() {
        return pthread_mutexattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpshared(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_setpshared$address() {
        return pthread_mutexattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_setpshared(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_setpshared(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_settype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_settype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_settype(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_settype$descriptor() {
        return pthread_mutexattr_settype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_settype(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_settype$handle() {
        return pthread_mutexattr_settype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_settype(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_settype$address() {
        return pthread_mutexattr_settype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_settype(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_settype(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_settype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_settype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setpolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_setpolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setpolicy_np$descriptor() {
        return pthread_mutexattr_setpolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_setpolicy_np$handle() {
        return pthread_mutexattr_setpolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_setpolicy_np$address() {
        return pthread_mutexattr_setpolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_setpolicy_np(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_setpolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setpolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_once {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_once");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_once(pthread_once_t * _Nonnull, void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor pthread_once$descriptor() {
        return pthread_once.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_once(pthread_once_t * _Nonnull, void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle pthread_once$handle() {
        return pthread_once.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_once(pthread_once_t * _Nonnull, void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment pthread_once$address() {
        return pthread_once.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_once(pthread_once_t * _Nonnull, void (* _Nonnull)(void))
     * }
     */
    public static int pthread_once(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_once.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_once", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_destroy(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_destroy$descriptor() {
        return pthread_rwlock_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_destroy(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_destroy$handle() {
        return pthread_rwlock_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_destroy(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_destroy$address() {
        return pthread_rwlock_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_destroy(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_destroy(MemorySegment x0) {
        var mh$ = pthread_rwlock_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_init(pthread_rwlock_t *restrict _Nonnull, const pthread_rwlockattr_t *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_init$descriptor() {
        return pthread_rwlock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_init(pthread_rwlock_t *restrict _Nonnull, const pthread_rwlockattr_t *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_rwlock_init$handle() {
        return pthread_rwlock_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_init(pthread_rwlock_t *restrict _Nonnull, const pthread_rwlockattr_t *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_rwlock_init$address() {
        return pthread_rwlock_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_init(pthread_rwlock_t *restrict _Nonnull, const pthread_rwlockattr_t *restrict _Nullable)
     * }
     */
    public static int pthread_rwlock_init(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_rwlock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_init", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_rdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_rdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_rdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_rdlock$descriptor() {
        return pthread_rwlock_rdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_rdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_rdlock$handle() {
        return pthread_rwlock_rdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_rdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_rdlock$address() {
        return pthread_rwlock_rdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_rdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_rdlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_rdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_rdlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_tryrdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_tryrdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_tryrdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_tryrdlock$descriptor() {
        return pthread_rwlock_tryrdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_tryrdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_tryrdlock$handle() {
        return pthread_rwlock_tryrdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_tryrdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_tryrdlock$address() {
        return pthread_rwlock_tryrdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_tryrdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_tryrdlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_tryrdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_tryrdlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_trywrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_trywrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_trywrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_trywrlock$descriptor() {
        return pthread_rwlock_trywrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_trywrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_trywrlock$handle() {
        return pthread_rwlock_trywrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_trywrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_trywrlock$address() {
        return pthread_rwlock_trywrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_trywrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_trywrlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_trywrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_trywrlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_wrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_wrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_wrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_wrlock$descriptor() {
        return pthread_rwlock_wrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_wrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_wrlock$handle() {
        return pthread_rwlock_wrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_wrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_wrlock$address() {
        return pthread_rwlock_wrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_wrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_wrlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_wrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_wrlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_unlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_unlock$descriptor() {
        return pthread_rwlock_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_unlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_unlock$handle() {
        return pthread_rwlock_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_unlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_unlock$address() {
        return pthread_rwlock_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_unlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_unlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_unlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlockattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_destroy(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_destroy$descriptor() {
        return pthread_rwlockattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_destroy(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlockattr_destroy$handle() {
        return pthread_rwlockattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_destroy(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlockattr_destroy$address() {
        return pthread_rwlockattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlockattr_destroy(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static int pthread_rwlockattr_destroy(MemorySegment x0) {
        var mh$ = pthread_rwlockattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlockattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_getpshared$descriptor() {
        return pthread_rwlockattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlockattr_getpshared$handle() {
        return pthread_rwlockattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlockattr_getpshared$address() {
        return pthread_rwlockattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_rwlockattr_getpshared(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_rwlockattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_getpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlockattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_init(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_init$descriptor() {
        return pthread_rwlockattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_init(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlockattr_init$handle() {
        return pthread_rwlockattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_init(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlockattr_init$address() {
        return pthread_rwlockattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlockattr_init(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static int pthread_rwlockattr_init(MemorySegment x0) {
        var mh$ = pthread_rwlockattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_init", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlockattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_setpshared$descriptor() {
        return pthread_rwlockattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_rwlockattr_setpshared$handle() {
        return pthread_rwlockattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_rwlockattr_setpshared$address() {
        return pthread_rwlockattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_rwlockattr_setpshared(MemorySegment x0, int x1) {
        var mh$ = pthread_rwlockattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_setpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pthread_t  _Nonnull pthread_self()
     * }
     */
    public static FunctionDescriptor pthread_self$descriptor() {
        return pthread_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pthread_t  _Nonnull pthread_self()
     * }
     */
    public static MethodHandle pthread_self$handle() {
        return pthread_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pthread_t  _Nonnull pthread_self()
     * }
     */
    public static MemorySegment pthread_self$address() {
        return pthread_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pthread_t  _Nonnull pthread_self()
     * }
     */
    public static MemorySegment pthread_self() {
        var mh$ = pthread_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_self");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setcancelstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setcancelstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setcancelstate(int, int * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_setcancelstate$descriptor() {
        return pthread_setcancelstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setcancelstate(int, int * _Nullable)
     * }
     */
    public static MethodHandle pthread_setcancelstate$handle() {
        return pthread_setcancelstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setcancelstate(int, int * _Nullable)
     * }
     */
    public static MemorySegment pthread_setcancelstate$address() {
        return pthread_setcancelstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setcancelstate(int, int * _Nullable)
     * }
     */
    public static int pthread_setcancelstate(int x0, MemorySegment x1) {
        var mh$ = pthread_setcancelstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setcancelstate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setcanceltype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setcanceltype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setcanceltype(int, int * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_setcanceltype$descriptor() {
        return pthread_setcanceltype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setcanceltype(int, int * _Nullable)
     * }
     */
    public static MethodHandle pthread_setcanceltype$handle() {
        return pthread_setcanceltype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setcanceltype(int, int * _Nullable)
     * }
     */
    public static MemorySegment pthread_setcanceltype$address() {
        return pthread_setcanceltype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setcanceltype(int, int * _Nullable)
     * }
     */
    public static int pthread_setcanceltype(int x0, MemorySegment x1) {
        var mh$ = pthread_setcanceltype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setcanceltype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setconcurrency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setconcurrency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setconcurrency(int)
     * }
     */
    public static FunctionDescriptor pthread_setconcurrency$descriptor() {
        return pthread_setconcurrency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setconcurrency(int)
     * }
     */
    public static MethodHandle pthread_setconcurrency$handle() {
        return pthread_setconcurrency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setconcurrency(int)
     * }
     */
    public static MemorySegment pthread_setconcurrency$address() {
        return pthread_setconcurrency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setconcurrency(int)
     * }
     */
    public static int pthread_setconcurrency(int x0) {
        var mh$ = pthread_setconcurrency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setconcurrency", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setschedparam(pthread_t _Nonnull, int, const struct sched_param * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_setschedparam$descriptor() {
        return pthread_setschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setschedparam(pthread_t _Nonnull, int, const struct sched_param * _Nonnull)
     * }
     */
    public static MethodHandle pthread_setschedparam$handle() {
        return pthread_setschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setschedparam(pthread_t _Nonnull, int, const struct sched_param * _Nonnull)
     * }
     */
    public static MemorySegment pthread_setschedparam$address() {
        return pthread_setschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setschedparam(pthread_t _Nonnull, int, const struct sched_param * _Nonnull)
     * }
     */
    public static int pthread_setschedparam(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = pthread_setschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setschedparam", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setspecific {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setspecific");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setspecific(pthread_key_t, const void * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_setspecific$descriptor() {
        return pthread_setspecific.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setspecific(pthread_key_t, const void * _Nullable)
     * }
     */
    public static MethodHandle pthread_setspecific$handle() {
        return pthread_setspecific.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setspecific(pthread_key_t, const void * _Nullable)
     * }
     */
    public static MemorySegment pthread_setspecific$address() {
        return pthread_setspecific.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setspecific(pthread_key_t, const void * _Nullable)
     * }
     */
    public static int pthread_setspecific(long x0, MemorySegment x1) {
        var mh$ = pthread_setspecific.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setspecific", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_testcancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_testcancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_testcancel()
     * }
     */
    public static FunctionDescriptor pthread_testcancel$descriptor() {
        return pthread_testcancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_testcancel()
     * }
     */
    public static MethodHandle pthread_testcancel$handle() {
        return pthread_testcancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_testcancel()
     * }
     */
    public static MemorySegment pthread_testcancel$address() {
        return pthread_testcancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_testcancel()
     * }
     */
    public static void pthread_testcancel() {
        var mh$ = pthread_testcancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_testcancel");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_is_threaded_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_is_threaded_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_is_threaded_np()
     * }
     */
    public static FunctionDescriptor pthread_is_threaded_np$descriptor() {
        return pthread_is_threaded_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_is_threaded_np()
     * }
     */
    public static MethodHandle pthread_is_threaded_np$handle() {
        return pthread_is_threaded_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_is_threaded_np()
     * }
     */
    public static MemorySegment pthread_is_threaded_np$address() {
        return pthread_is_threaded_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_is_threaded_np()
     * }
     */
    public static int pthread_is_threaded_np() {
        var mh$ = pthread_is_threaded_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_is_threaded_np");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_threadid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_threadid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_threadid_np(pthread_t _Nullable, __uint64_t * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_threadid_np$descriptor() {
        return pthread_threadid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_threadid_np(pthread_t _Nullable, __uint64_t * _Nullable)
     * }
     */
    public static MethodHandle pthread_threadid_np$handle() {
        return pthread_threadid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_threadid_np(pthread_t _Nullable, __uint64_t * _Nullable)
     * }
     */
    public static MemorySegment pthread_threadid_np$address() {
        return pthread_threadid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_threadid_np(pthread_t _Nullable, __uint64_t * _Nullable)
     * }
     */
    public static int pthread_threadid_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_threadid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_threadid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getname_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getname_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getname_np(pthread_t _Nonnull, char * _Nonnull, size_t)
     * }
     */
    public static FunctionDescriptor pthread_getname_np$descriptor() {
        return pthread_getname_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getname_np(pthread_t _Nonnull, char * _Nonnull, size_t)
     * }
     */
    public static MethodHandle pthread_getname_np$handle() {
        return pthread_getname_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getname_np(pthread_t _Nonnull, char * _Nonnull, size_t)
     * }
     */
    public static MemorySegment pthread_getname_np$address() {
        return pthread_getname_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getname_np(pthread_t _Nonnull, char * _Nonnull, size_t)
     * }
     */
    public static int pthread_getname_np(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = pthread_getname_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getname_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setname_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setname_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setname_np(const char * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_setname_np$descriptor() {
        return pthread_setname_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setname_np(const char * _Nonnull)
     * }
     */
    public static MethodHandle pthread_setname_np$handle() {
        return pthread_setname_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setname_np(const char * _Nonnull)
     * }
     */
    public static MemorySegment pthread_setname_np$address() {
        return pthread_setname_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setname_np(const char * _Nonnull)
     * }
     */
    public static int pthread_setname_np(MemorySegment x0) {
        var mh$ = pthread_setname_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setname_np", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_main_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_main_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_main_np()
     * }
     */
    public static FunctionDescriptor pthread_main_np$descriptor() {
        return pthread_main_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_main_np()
     * }
     */
    public static MethodHandle pthread_main_np$handle() {
        return pthread_main_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_main_np()
     * }
     */
    public static MemorySegment pthread_main_np$address() {
        return pthread_main_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_main_np()
     * }
     */
    public static int pthread_main_np() {
        var mh$ = pthread_main_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_main_np");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mach_thread_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mach_thread_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mach_port_t pthread_mach_thread_np(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mach_thread_np$descriptor() {
        return pthread_mach_thread_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mach_port_t pthread_mach_thread_np(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_mach_thread_np$handle() {
        return pthread_mach_thread_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mach_port_t pthread_mach_thread_np(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_mach_thread_np$address() {
        return pthread_mach_thread_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mach_port_t pthread_mach_thread_np(pthread_t _Nonnull)
     * }
     */
    public static int pthread_mach_thread_np(MemorySegment x0) {
        var mh$ = pthread_mach_thread_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mach_thread_np", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_get_stacksize_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_get_stacksize_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t pthread_get_stacksize_np(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_get_stacksize_np$descriptor() {
        return pthread_get_stacksize_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t pthread_get_stacksize_np(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_get_stacksize_np$handle() {
        return pthread_get_stacksize_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t pthread_get_stacksize_np(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_get_stacksize_np$address() {
        return pthread_get_stacksize_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t pthread_get_stacksize_np(pthread_t _Nonnull)
     * }
     */
    public static long pthread_get_stacksize_np(MemorySegment x0) {
        var mh$ = pthread_get_stacksize_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_get_stacksize_np", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_get_stackaddr_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_get_stackaddr_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void * _Nonnull pthread_get_stackaddr_np(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_get_stackaddr_np$descriptor() {
        return pthread_get_stackaddr_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void * _Nonnull pthread_get_stackaddr_np(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_get_stackaddr_np$handle() {
        return pthread_get_stackaddr_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void * _Nonnull pthread_get_stackaddr_np(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_get_stackaddr_np$address() {
        return pthread_get_stackaddr_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void * _Nonnull pthread_get_stackaddr_np(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_get_stackaddr_np(MemorySegment x0) {
        var mh$ = pthread_get_stackaddr_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_get_stackaddr_np", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_signal_thread_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_signal_thread_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_signal_thread_np(pthread_cond_t * _Nonnull, pthread_t _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_cond_signal_thread_np$descriptor() {
        return pthread_cond_signal_thread_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_signal_thread_np(pthread_cond_t * _Nonnull, pthread_t _Nullable)
     * }
     */
    public static MethodHandle pthread_cond_signal_thread_np$handle() {
        return pthread_cond_signal_thread_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_signal_thread_np(pthread_cond_t * _Nonnull, pthread_t _Nullable)
     * }
     */
    public static MemorySegment pthread_cond_signal_thread_np$address() {
        return pthread_cond_signal_thread_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_signal_thread_np(pthread_cond_t * _Nonnull, pthread_t _Nullable)
     * }
     */
    public static int pthread_cond_signal_thread_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_cond_signal_thread_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_signal_thread_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_timedwait_relative_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_timedwait_relative_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait_relative_np(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_cond_timedwait_relative_np$descriptor() {
        return pthread_cond_timedwait_relative_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait_relative_np(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable)
     * }
     */
    public static MethodHandle pthread_cond_timedwait_relative_np$handle() {
        return pthread_cond_timedwait_relative_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait_relative_np(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable)
     * }
     */
    public static MemorySegment pthread_cond_timedwait_relative_np$address() {
        return pthread_cond_timedwait_relative_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_timedwait_relative_np(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable)
     * }
     */
    public static int pthread_cond_timedwait_relative_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_cond_timedwait_relative_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_timedwait_relative_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_create_suspended_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_create_suspended_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_create_suspended_np(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_create_suspended_np$descriptor() {
        return pthread_create_suspended_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_create_suspended_np(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable)
     * }
     */
    public static MethodHandle pthread_create_suspended_np$handle() {
        return pthread_create_suspended_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_create_suspended_np(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable)
     * }
     */
    public static MemorySegment pthread_create_suspended_np$address() {
        return pthread_create_suspended_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_create_suspended_np(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable)
     * }
     */
    public static int pthread_create_suspended_np(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = pthread_create_suspended_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_create_suspended_np", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_kill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_kill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_kill(pthread_t _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_kill$descriptor() {
        return pthread_kill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_kill(pthread_t _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_kill$handle() {
        return pthread_kill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_kill(pthread_t _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_kill$address() {
        return pthread_kill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_kill(pthread_t _Nonnull, int)
     * }
     */
    public static int pthread_kill(MemorySegment x0, int x1) {
        var mh$ = pthread_kill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_kill", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_from_mach_thread_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_from_mach_thread_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pthread_t  _Nullable pthread_from_mach_thread_np(mach_port_t)
     * }
     */
    public static FunctionDescriptor pthread_from_mach_thread_np$descriptor() {
        return pthread_from_mach_thread_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pthread_t  _Nullable pthread_from_mach_thread_np(mach_port_t)
     * }
     */
    public static MethodHandle pthread_from_mach_thread_np$handle() {
        return pthread_from_mach_thread_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pthread_t  _Nullable pthread_from_mach_thread_np(mach_port_t)
     * }
     */
    public static MemorySegment pthread_from_mach_thread_np$address() {
        return pthread_from_mach_thread_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pthread_t  _Nullable pthread_from_mach_thread_np(mach_port_t)
     * }
     */
    public static MemorySegment pthread_from_mach_thread_np(int x0) {
        var mh$ = pthread_from_mach_thread_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_from_mach_thread_np", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_sigmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_sigmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_sigmask$descriptor() {
        return pthread_sigmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
     * }
     */
    public static MethodHandle pthread_sigmask$handle() {
        return pthread_sigmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
     * }
     */
    public static MemorySegment pthread_sigmask$address() {
        return pthread_sigmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
     * }
     */
    public static int pthread_sigmask(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_sigmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_sigmask", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_yield_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_yield_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_yield_np()
     * }
     */
    public static FunctionDescriptor pthread_yield_np$descriptor() {
        return pthread_yield_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_yield_np()
     * }
     */
    public static MethodHandle pthread_yield_np$handle() {
        return pthread_yield_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_yield_np()
     * }
     */
    public static MemorySegment pthread_yield_np$address() {
        return pthread_yield_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_yield_np()
     * }
     */
    public static void pthread_yield_np() {
        var mh$ = pthread_yield_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_yield_np");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_jit_write_protect_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_jit_write_protect_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_jit_write_protect_np(int enabled)
     * }
     */
    public static FunctionDescriptor pthread_jit_write_protect_np$descriptor() {
        return pthread_jit_write_protect_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_jit_write_protect_np(int enabled)
     * }
     */
    public static MethodHandle pthread_jit_write_protect_np$handle() {
        return pthread_jit_write_protect_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_jit_write_protect_np(int enabled)
     * }
     */
    public static MemorySegment pthread_jit_write_protect_np$address() {
        return pthread_jit_write_protect_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_jit_write_protect_np(int enabled)
     * }
     */
    public static void pthread_jit_write_protect_np(int enabled) {
        var mh$ = pthread_jit_write_protect_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_jit_write_protect_np", enabled);
            }
            mh$.invokeExact(enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_jit_write_protect_supported_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_jit_write_protect_supported_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_jit_write_protect_supported_np()
     * }
     */
    public static FunctionDescriptor pthread_jit_write_protect_supported_np$descriptor() {
        return pthread_jit_write_protect_supported_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_jit_write_protect_supported_np()
     * }
     */
    public static MethodHandle pthread_jit_write_protect_supported_np$handle() {
        return pthread_jit_write_protect_supported_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_jit_write_protect_supported_np()
     * }
     */
    public static MemorySegment pthread_jit_write_protect_supported_np$address() {
        return pthread_jit_write_protect_supported_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_jit_write_protect_supported_np()
     * }
     */
    public static int pthread_jit_write_protect_supported_np() {
        var mh$ = pthread_jit_write_protect_supported_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_jit_write_protect_supported_np");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_jit_write_with_callback_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_jit_write_with_callback_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_jit_write_with_callback_np(pthread_jit_write_callback_t  _Nonnull callback, void * _Nullable ctx)
     * }
     */
    public static FunctionDescriptor pthread_jit_write_with_callback_np$descriptor() {
        return pthread_jit_write_with_callback_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_jit_write_with_callback_np(pthread_jit_write_callback_t  _Nonnull callback, void * _Nullable ctx)
     * }
     */
    public static MethodHandle pthread_jit_write_with_callback_np$handle() {
        return pthread_jit_write_with_callback_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_jit_write_with_callback_np(pthread_jit_write_callback_t  _Nonnull callback, void * _Nullable ctx)
     * }
     */
    public static MemorySegment pthread_jit_write_with_callback_np$address() {
        return pthread_jit_write_with_callback_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_jit_write_with_callback_np(pthread_jit_write_callback_t  _Nonnull callback, void * _Nullable ctx)
     * }
     */
    public static int pthread_jit_write_with_callback_np(MemorySegment callback, MemorySegment ctx) {
        var mh$ = pthread_jit_write_with_callback_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_jit_write_with_callback_np", callback, ctx);
            }
            return (int)mh$.invokeExact(callback, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_jit_write_freeze_callbacks_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_jit_write_freeze_callbacks_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_jit_write_freeze_callbacks_np()
     * }
     */
    public static FunctionDescriptor pthread_jit_write_freeze_callbacks_np$descriptor() {
        return pthread_jit_write_freeze_callbacks_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_jit_write_freeze_callbacks_np()
     * }
     */
    public static MethodHandle pthread_jit_write_freeze_callbacks_np$handle() {
        return pthread_jit_write_freeze_callbacks_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_jit_write_freeze_callbacks_np()
     * }
     */
    public static MemorySegment pthread_jit_write_freeze_callbacks_np$address() {
        return pthread_jit_write_freeze_callbacks_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_jit_write_freeze_callbacks_np()
     * }
     */
    public static void pthread_jit_write_freeze_callbacks_np() {
        var mh$ = pthread_jit_write_freeze_callbacks_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_jit_write_freeze_callbacks_np");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cpu_number_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cpu_number_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cpu_number_np(size_t * _Nonnull cpu_number_out)
     * }
     */
    public static FunctionDescriptor pthread_cpu_number_np$descriptor() {
        return pthread_cpu_number_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cpu_number_np(size_t * _Nonnull cpu_number_out)
     * }
     */
    public static MethodHandle pthread_cpu_number_np$handle() {
        return pthread_cpu_number_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cpu_number_np(size_t * _Nonnull cpu_number_out)
     * }
     */
    public static MemorySegment pthread_cpu_number_np$address() {
        return pthread_cpu_number_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cpu_number_np(size_t * _Nonnull cpu_number_out)
     * }
     */
    public static int pthread_cpu_number_np(MemorySegment cpu_number_out) {
        var mh$ = pthread_cpu_number_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cpu_number_np", cpu_number_out);
            }
            return (int)mh$.invokeExact(cpu_number_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyContext_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContext_Type
     * }
     */
    public static GroupLayout PyContext_Type$layout() {
        return PyContext_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContext_Type
     * }
     */
    public static MemorySegment PyContext_Type() {
        return PyContext_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContext_Type
     * }
     */
    public static void PyContext_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyContext_Type$constants.SEGMENT, 0L, PyContext_Type$constants.LAYOUT.byteSize());
    }

    private static class PyContextVar_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyContextVar_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextVar_Type
     * }
     */
    public static GroupLayout PyContextVar_Type$layout() {
        return PyContextVar_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextVar_Type
     * }
     */
    public static MemorySegment PyContextVar_Type() {
        return PyContextVar_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextVar_Type
     * }
     */
    public static void PyContextVar_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyContextVar_Type$constants.SEGMENT, 0L, PyContextVar_Type$constants.LAYOUT.byteSize());
    }

    private static class PyContextToken_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyContextToken_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextToken_Type
     * }
     */
    public static GroupLayout PyContextToken_Type$layout() {
        return PyContextToken_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextToken_Type
     * }
     */
    public static MemorySegment PyContextToken_Type() {
        return PyContextToken_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextToken_Type
     * }
     */
    public static void PyContextToken_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyContextToken_Type$constants.SEGMENT, 0L, PyContextToken_Type$constants.LAYOUT.byteSize());
    }

    private static class PyContext_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContext_New()
     * }
     */
    public static FunctionDescriptor PyContext_New$descriptor() {
        return PyContext_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContext_New()
     * }
     */
    public static MethodHandle PyContext_New$handle() {
        return PyContext_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContext_New()
     * }
     */
    public static MemorySegment PyContext_New$address() {
        return PyContext_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContext_New()
     * }
     */
    public static MemorySegment PyContext_New() {
        var mh$ = PyContext_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContext_Copy(PyObject *)
     * }
     */
    public static FunctionDescriptor PyContext_Copy$descriptor() {
        return PyContext_Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContext_Copy(PyObject *)
     * }
     */
    public static MethodHandle PyContext_Copy$handle() {
        return PyContext_Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContext_Copy(PyObject *)
     * }
     */
    public static MemorySegment PyContext_Copy$address() {
        return PyContext_Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContext_Copy(PyObject *)
     * }
     */
    public static MemorySegment PyContext_Copy(MemorySegment x0) {
        var mh$ = PyContext_Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_Copy", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_CopyCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_CopyCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContext_CopyCurrent()
     * }
     */
    public static FunctionDescriptor PyContext_CopyCurrent$descriptor() {
        return PyContext_CopyCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContext_CopyCurrent()
     * }
     */
    public static MethodHandle PyContext_CopyCurrent$handle() {
        return PyContext_CopyCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContext_CopyCurrent()
     * }
     */
    public static MemorySegment PyContext_CopyCurrent$address() {
        return PyContext_CopyCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContext_CopyCurrent()
     * }
     */
    public static MemorySegment PyContext_CopyCurrent() {
        var mh$ = PyContext_CopyCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_CopyCurrent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_Enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_Enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyContext_Enter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyContext_Enter$descriptor() {
        return PyContext_Enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyContext_Enter(PyObject *)
     * }
     */
    public static MethodHandle PyContext_Enter$handle() {
        return PyContext_Enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyContext_Enter(PyObject *)
     * }
     */
    public static MemorySegment PyContext_Enter$address() {
        return PyContext_Enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyContext_Enter(PyObject *)
     * }
     */
    public static int PyContext_Enter(MemorySegment x0) {
        var mh$ = PyContext_Enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_Enter", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyContext_Exit(PyObject *)
     * }
     */
    public static FunctionDescriptor PyContext_Exit$descriptor() {
        return PyContext_Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyContext_Exit(PyObject *)
     * }
     */
    public static MethodHandle PyContext_Exit$handle() {
        return PyContext_Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyContext_Exit(PyObject *)
     * }
     */
    public static MemorySegment PyContext_Exit$address() {
        return PyContext_Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyContext_Exit(PyObject *)
     * }
     */
    public static int PyContext_Exit(MemorySegment x0) {
        var mh$ = PyContext_Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_Exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContextVar_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContextVar_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_New(const char *name, PyObject *default_value)
     * }
     */
    public static FunctionDescriptor PyContextVar_New$descriptor() {
        return PyContextVar_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_New(const char *name, PyObject *default_value)
     * }
     */
    public static MethodHandle PyContextVar_New$handle() {
        return PyContextVar_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_New(const char *name, PyObject *default_value)
     * }
     */
    public static MemorySegment PyContextVar_New$address() {
        return PyContextVar_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContextVar_New(const char *name, PyObject *default_value)
     * }
     */
    public static MemorySegment PyContextVar_New(MemorySegment name, MemorySegment default_value) {
        var mh$ = PyContextVar_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContextVar_New", name, default_value);
            }
            return (MemorySegment)mh$.invokeExact(name, default_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContextVar_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContextVar_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyContextVar_Get(PyObject *var, PyObject *default_value, PyObject **value)
     * }
     */
    public static FunctionDescriptor PyContextVar_Get$descriptor() {
        return PyContextVar_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyContextVar_Get(PyObject *var, PyObject *default_value, PyObject **value)
     * }
     */
    public static MethodHandle PyContextVar_Get$handle() {
        return PyContextVar_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyContextVar_Get(PyObject *var, PyObject *default_value, PyObject **value)
     * }
     */
    public static MemorySegment PyContextVar_Get$address() {
        return PyContextVar_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyContextVar_Get(PyObject *var, PyObject *default_value, PyObject **value)
     * }
     */
    public static int PyContextVar_Get(MemorySegment var_, MemorySegment default_value, MemorySegment value) {
        var mh$ = PyContextVar_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContextVar_Get", var_, default_value, value);
            }
            return (int)mh$.invokeExact(var_, default_value, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContextVar_Set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContextVar_Set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_Set(PyObject *var, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyContextVar_Set$descriptor() {
        return PyContextVar_Set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_Set(PyObject *var, PyObject *value)
     * }
     */
    public static MethodHandle PyContextVar_Set$handle() {
        return PyContextVar_Set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_Set(PyObject *var, PyObject *value)
     * }
     */
    public static MemorySegment PyContextVar_Set$address() {
        return PyContextVar_Set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContextVar_Set(PyObject *var, PyObject *value)
     * }
     */
    public static MemorySegment PyContextVar_Set(MemorySegment var_, MemorySegment value) {
        var mh$ = PyContextVar_Set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContextVar_Set", var_, value);
            }
            return (MemorySegment)mh$.invokeExact(var_, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContextVar_Reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContextVar_Reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyContextVar_Reset(PyObject *var, PyObject *token)
     * }
     */
    public static FunctionDescriptor PyContextVar_Reset$descriptor() {
        return PyContextVar_Reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyContextVar_Reset(PyObject *var, PyObject *token)
     * }
     */
    public static MethodHandle PyContextVar_Reset$handle() {
        return PyContextVar_Reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyContextVar_Reset(PyObject *var, PyObject *token)
     * }
     */
    public static MemorySegment PyContextVar_Reset$address() {
        return PyContextVar_Reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyContextVar_Reset(PyObject *var, PyObject *token)
     * }
     */
    public static int PyContextVar_Reset(MemorySegment var_, MemorySegment token) {
        var mh$ = PyContextVar_Reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContextVar_Reset", var_, token);
            }
            return (int)mh$.invokeExact(var_, token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_Parse(PyObject *, const char *, ...)
     * }
     */
    public static class PyArg_Parse {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_Parse");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_Parse(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_Parse(PyObject *, const char *, ...)
         * }
         */
        public static PyArg_Parse makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_Parse(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_Parse", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_ParseTuple(PyObject *, const char *, ...)
     * }
     */
    public static class PyArg_ParseTuple {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_ParseTuple");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_ParseTuple(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_ParseTuple(PyObject *, const char *, ...)
         * }
         */
        public static PyArg_ParseTuple makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_ParseTuple(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_ParseTuple", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_ParseTupleAndKeywords(PyObject *, PyObject *, const char *, char *const *, ...)
     * }
     */
    public static class PyArg_ParseTupleAndKeywords {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_ParseTupleAndKeywords");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_ParseTupleAndKeywords(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_ParseTupleAndKeywords(PyObject *, PyObject *, const char *, char *const *, ...)
         * }
         */
        public static PyArg_ParseTupleAndKeywords makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_ParseTupleAndKeywords(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_ParseTupleAndKeywords", x0, x1, x2, x3, x4);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyArg_VaParse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_VaParse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static FunctionDescriptor PyArg_VaParse$descriptor() {
        return PyArg_VaParse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static MethodHandle PyArg_VaParse$handle() {
        return PyArg_VaParse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static MemorySegment PyArg_VaParse$address() {
        return PyArg_VaParse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static int PyArg_VaParse(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyArg_VaParse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyArg_VaParse", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyArg_VaParseTupleAndKeywords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_VaParseTupleAndKeywords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char *const *, va_list)
     * }
     */
    public static FunctionDescriptor PyArg_VaParseTupleAndKeywords$descriptor() {
        return PyArg_VaParseTupleAndKeywords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char *const *, va_list)
     * }
     */
    public static MethodHandle PyArg_VaParseTupleAndKeywords$handle() {
        return PyArg_VaParseTupleAndKeywords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char *const *, va_list)
     * }
     */
    public static MemorySegment PyArg_VaParseTupleAndKeywords$address() {
        return PyArg_VaParseTupleAndKeywords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char *const *, va_list)
     * }
     */
    public static int PyArg_VaParseTupleAndKeywords(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PyArg_VaParseTupleAndKeywords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyArg_VaParseTupleAndKeywords", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyArg_ValidateKeywordArguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_ValidateKeywordArguments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static FunctionDescriptor PyArg_ValidateKeywordArguments$descriptor() {
        return PyArg_ValidateKeywordArguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static MethodHandle PyArg_ValidateKeywordArguments$handle() {
        return PyArg_ValidateKeywordArguments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static MemorySegment PyArg_ValidateKeywordArguments$address() {
        return PyArg_ValidateKeywordArguments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static int PyArg_ValidateKeywordArguments(MemorySegment x0) {
        var mh$ = PyArg_ValidateKeywordArguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyArg_ValidateKeywordArguments", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...)
     * }
     */
    public static class PyArg_UnpackTuple {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_LONG
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_UnpackTuple");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_UnpackTuple(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...)
         * }
         */
        public static PyArg_UnpackTuple makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_UnpackTuple(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, long x2, long x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_UnpackTuple", x0, x1, x2, x3, x4);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *Py_BuildValue(const char *, ...)
     * }
     */
    public static class Py_BuildValue {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("Py_BuildValue");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private Py_BuildValue(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *Py_BuildValue(const char *, ...)
         * }
         */
        public static Py_BuildValue makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new Py_BuildValue(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("Py_BuildValue", x0, x1);
                }
                return (MemorySegment) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class Py_VaBuildValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_VaBuildValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static FunctionDescriptor Py_VaBuildValue$descriptor() {
        return Py_VaBuildValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static MethodHandle Py_VaBuildValue$handle() {
        return Py_VaBuildValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static MemorySegment Py_VaBuildValue$address() {
        return Py_VaBuildValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static MemorySegment Py_VaBuildValue(MemorySegment x0, MemorySegment x1) {
        var mh$ = Py_VaBuildValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_VaBuildValue", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddObjectRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddObjectRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyModule_AddObjectRef$descriptor() {
        return PyModule_AddObjectRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static MethodHandle PyModule_AddObjectRef$handle() {
        return PyModule_AddObjectRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static MemorySegment PyModule_AddObjectRef$address() {
        return PyModule_AddObjectRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static int PyModule_AddObjectRef(MemorySegment mod, MemorySegment name, MemorySegment value) {
        var mh$ = PyModule_AddObjectRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddObjectRef", mod, name, value);
            }
            return (int)mh$.invokeExact(mod, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_Add(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyModule_Add$descriptor() {
        return PyModule_Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_Add(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static MethodHandle PyModule_Add$handle() {
        return PyModule_Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_Add(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static MemorySegment PyModule_Add$address() {
        return PyModule_Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_Add(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static int PyModule_Add(MemorySegment mod, MemorySegment name, MemorySegment value) {
        var mh$ = PyModule_Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_Add", mod, name, value);
            }
            return (int)mh$.invokeExact(mod, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyModule_AddObject$descriptor() {
        return PyModule_AddObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static MethodHandle PyModule_AddObject$handle() {
        return PyModule_AddObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static MemorySegment PyModule_AddObject$address() {
        return PyModule_AddObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static int PyModule_AddObject(MemorySegment mod, MemorySegment x1, MemorySegment value) {
        var mh$ = PyModule_AddObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddObject", mod, x1, value);
            }
            return (int)mh$.invokeExact(mod, x1, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddIntConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddIntConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static FunctionDescriptor PyModule_AddIntConstant$descriptor() {
        return PyModule_AddIntConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static MethodHandle PyModule_AddIntConstant$handle() {
        return PyModule_AddIntConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static MemorySegment PyModule_AddIntConstant$address() {
        return PyModule_AddIntConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static int PyModule_AddIntConstant(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = PyModule_AddIntConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddIntConstant", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddStringConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddStringConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static FunctionDescriptor PyModule_AddStringConstant$descriptor() {
        return PyModule_AddStringConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static MethodHandle PyModule_AddStringConstant$handle() {
        return PyModule_AddStringConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static MemorySegment PyModule_AddStringConstant$address() {
        return PyModule_AddStringConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static int PyModule_AddStringConstant(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyModule_AddStringConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddStringConstant", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyModule_AddType$descriptor() {
        return PyModule_AddType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static MethodHandle PyModule_AddType$handle() {
        return PyModule_AddType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static MemorySegment PyModule_AddType$address() {
        return PyModule_AddType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static int PyModule_AddType(MemorySegment module, MemorySegment type) {
        var mh$ = PyModule_AddType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddType", module, type);
            }
            return (int)mh$.invokeExact(module, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_SetDocString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_SetDocString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyModule_SetDocString$descriptor() {
        return PyModule_SetDocString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyModule_SetDocString$handle() {
        return PyModule_SetDocString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyModule_SetDocString$address() {
        return PyModule_SetDocString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static int PyModule_SetDocString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyModule_SetDocString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_SetDocString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddFunctions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddFunctions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static FunctionDescriptor PyModule_AddFunctions$descriptor() {
        return PyModule_AddFunctions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static MethodHandle PyModule_AddFunctions$handle() {
        return PyModule_AddFunctions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyModule_AddFunctions$address() {
        return PyModule_AddFunctions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static int PyModule_AddFunctions(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyModule_AddFunctions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddFunctions", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_ExecDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_ExecDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static FunctionDescriptor PyModule_ExecDef$descriptor() {
        return PyModule_ExecDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static MethodHandle PyModule_ExecDef$handle() {
        return PyModule_ExecDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static MemorySegment PyModule_ExecDef$address() {
        return PyModule_ExecDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static int PyModule_ExecDef(MemorySegment module, MemorySegment def) {
        var mh$ = PyModule_ExecDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_ExecDef", module, def);
            }
            return (int)mh$.invokeExact(module, def);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_Create2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_Create2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static FunctionDescriptor PyModule_Create2$descriptor() {
        return PyModule_Create2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static MethodHandle PyModule_Create2$handle() {
        return PyModule_Create2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static MemorySegment PyModule_Create2$address() {
        return PyModule_Create2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static MemorySegment PyModule_Create2(MemorySegment x0, int apiver) {
        var mh$ = PyModule_Create2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_Create2", x0, apiver);
            }
            return (MemorySegment)mh$.invokeExact(x0, apiver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_FromDefAndSpec2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_FromDefAndSpec2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static FunctionDescriptor PyModule_FromDefAndSpec2$descriptor() {
        return PyModule_FromDefAndSpec2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static MethodHandle PyModule_FromDefAndSpec2$handle() {
        return PyModule_FromDefAndSpec2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static MemorySegment PyModule_FromDefAndSpec2$address() {
        return PyModule_FromDefAndSpec2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static MemorySegment PyModule_FromDefAndSpec2(MemorySegment def, MemorySegment spec, int module_api_version) {
        var mh$ = PyModule_FromDefAndSpec2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_FromDefAndSpec2", def, spec, module_api_version);
            }
            return (MemorySegment)mh$.invokeExact(def, spec, module_api_version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int _PyArg_ParseTupleAndKeywordsFast(PyObject *, PyObject *, struct _PyArg_Parser *, ...)
     * }
     */
    public static class _PyArg_ParseTupleAndKeywordsFast {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_ParseTupleAndKeywordsFast");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyArg_ParseTupleAndKeywordsFast(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int _PyArg_ParseTupleAndKeywordsFast(PyObject *, PyObject *, struct _PyArg_Parser *, ...)
         * }
         */
        public static _PyArg_ParseTupleAndKeywordsFast makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyArg_ParseTupleAndKeywordsFast(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, MemorySegment x2, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyArg_ParseTupleAndKeywordsFast", x0, x1, x2, x3);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyCompile_OpcodeStackEffect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCompile_OpcodeStackEffect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffect(int opcode, int oparg)
     * }
     */
    public static FunctionDescriptor PyCompile_OpcodeStackEffect$descriptor() {
        return PyCompile_OpcodeStackEffect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffect(int opcode, int oparg)
     * }
     */
    public static MethodHandle PyCompile_OpcodeStackEffect$handle() {
        return PyCompile_OpcodeStackEffect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffect(int opcode, int oparg)
     * }
     */
    public static MemorySegment PyCompile_OpcodeStackEffect$address() {
        return PyCompile_OpcodeStackEffect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffect(int opcode, int oparg)
     * }
     */
    public static int PyCompile_OpcodeStackEffect(int opcode, int oparg) {
        var mh$ = PyCompile_OpcodeStackEffect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCompile_OpcodeStackEffect", opcode, oparg);
            }
            return (int)mh$.invokeExact(opcode, oparg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCompile_OpcodeStackEffectWithJump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCompile_OpcodeStackEffectWithJump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump)
     * }
     */
    public static FunctionDescriptor PyCompile_OpcodeStackEffectWithJump$descriptor() {
        return PyCompile_OpcodeStackEffectWithJump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump)
     * }
     */
    public static MethodHandle PyCompile_OpcodeStackEffectWithJump$handle() {
        return PyCompile_OpcodeStackEffectWithJump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump)
     * }
     */
    public static MemorySegment PyCompile_OpcodeStackEffectWithJump$address() {
        return PyCompile_OpcodeStackEffectWithJump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump)
     * }
     */
    public static int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump) {
        var mh$ = PyCompile_OpcodeStackEffectWithJump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCompile_OpcodeStackEffectWithJump", opcode, oparg, jump);
            }
            return (int)mh$.invokeExact(opcode, oparg, jump);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_CompileString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_CompileString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static FunctionDescriptor Py_CompileString$descriptor() {
        return Py_CompileString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static MethodHandle Py_CompileString$handle() {
        return Py_CompileString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static MemorySegment Py_CompileString$address() {
        return Py_CompileString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static MemorySegment Py_CompileString(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Py_CompileString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_CompileString", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static FunctionDescriptor PyErr_Print$descriptor() {
        return PyErr_Print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static MethodHandle PyErr_Print$handle() {
        return PyErr_Print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static MemorySegment PyErr_Print$address() {
        return PyErr_Print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static void PyErr_Print() {
        var mh$ = PyErr_Print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Print");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_PrintEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_PrintEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static FunctionDescriptor PyErr_PrintEx$descriptor() {
        return PyErr_PrintEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static MethodHandle PyErr_PrintEx$handle() {
        return PyErr_PrintEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static MemorySegment PyErr_PrintEx$address() {
        return PyErr_PrintEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static void PyErr_PrintEx(int x0) {
        var mh$ = PyErr_PrintEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_PrintEx", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Display {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Display");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_Display$descriptor() {
        return PyErr_Display.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_Display$handle() {
        return PyErr_Display.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_Display$address() {
        return PyErr_Display.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void PyErr_Display(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_Display.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Display", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_DisplayException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_DisplayException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_DisplayException(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_DisplayException$descriptor() {
        return PyErr_DisplayException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_DisplayException(PyObject *)
     * }
     */
    public static MethodHandle PyErr_DisplayException$handle() {
        return PyErr_DisplayException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_DisplayException(PyObject *)
     * }
     */
    public static MemorySegment PyErr_DisplayException$address() {
        return PyErr_DisplayException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_DisplayException(PyObject *)
     * }
     */
    public static void PyErr_DisplayException(MemorySegment x0) {
        var mh$ = PyErr_DisplayException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_DisplayException", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_InputHook$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyOS_InputHook").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static AddressLayout PyOS_InputHook$layout() {
        return PyOS_InputHook$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static MemorySegment PyOS_InputHook$segment() {
        return PyOS_InputHook$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static MemorySegment PyOS_InputHook() {
        return PyOS_InputHook$constants.SEGMENT.get(PyOS_InputHook$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static void PyOS_InputHook(MemorySegment varValue) {
        PyOS_InputHook$constants.SEGMENT.set(PyOS_InputHook$constants.LAYOUT, 0L, varValue);
    }

    private static class PyRun_SimpleStringFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleStringFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleStringFlags$descriptor() {
        return PyRun_SimpleStringFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *)
     * }
     */
    public static MethodHandle PyRun_SimpleStringFlags$handle() {
        return PyRun_SimpleStringFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *)
     * }
     */
    public static MemorySegment PyRun_SimpleStringFlags$address() {
        return PyRun_SimpleStringFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *)
     * }
     */
    public static int PyRun_SimpleStringFlags(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyRun_SimpleStringFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleStringFlags", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_AnyFileExFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_AnyFileExFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_AnyFileExFlags$descriptor() {
        return PyRun_AnyFileExFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_AnyFileExFlags$handle() {
        return PyRun_AnyFileExFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_AnyFileExFlags$address() {
        return PyRun_AnyFileExFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_AnyFileExFlags(MemorySegment fp, MemorySegment filename, int closeit, MemorySegment flags) {
        var mh$ = PyRun_AnyFileExFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_AnyFileExFlags", fp, filename, closeit, flags);
            }
            return (int)mh$.invokeExact(fp, filename, closeit, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_SimpleFileExFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleFileExFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleFileExFlags$descriptor() {
        return PyRun_SimpleFileExFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_SimpleFileExFlags$handle() {
        return PyRun_SimpleFileExFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_SimpleFileExFlags$address() {
        return PyRun_SimpleFileExFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_SimpleFileExFlags(MemorySegment fp, MemorySegment filename, int closeit, MemorySegment flags) {
        var mh$ = PyRun_SimpleFileExFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleFileExFlags", fp, filename, closeit, flags);
            }
            return (int)mh$.invokeExact(fp, filename, closeit, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveOneFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveOneFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveOneFlags$descriptor() {
        return PyRun_InteractiveOneFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_InteractiveOneFlags$handle() {
        return PyRun_InteractiveOneFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_InteractiveOneFlags$address() {
        return PyRun_InteractiveOneFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_InteractiveOneFlags(MemorySegment fp, MemorySegment filename, MemorySegment flags) {
        var mh$ = PyRun_InteractiveOneFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveOneFlags", fp, filename, flags);
            }
            return (int)mh$.invokeExact(fp, filename, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveOneObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveOneObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveOneObject$descriptor() {
        return PyRun_InteractiveOneObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_InteractiveOneObject$handle() {
        return PyRun_InteractiveOneObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_InteractiveOneObject$address() {
        return PyRun_InteractiveOneObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveOneObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_InteractiveOneObject(MemorySegment fp, MemorySegment filename, MemorySegment flags) {
        var mh$ = PyRun_InteractiveOneObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveOneObject", fp, filename, flags);
            }
            return (int)mh$.invokeExact(fp, filename, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveLoopFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveLoopFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoopFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveLoopFlags$descriptor() {
        return PyRun_InteractiveLoopFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoopFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_InteractiveLoopFlags$handle() {
        return PyRun_InteractiveLoopFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoopFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_InteractiveLoopFlags$address() {
        return PyRun_InteractiveLoopFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveLoopFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_InteractiveLoopFlags(MemorySegment fp, MemorySegment filename, MemorySegment flags) {
        var mh$ = PyRun_InteractiveLoopFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveLoopFlags", fp, filename, flags);
            }
            return (int)mh$.invokeExact(fp, filename, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_StringFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_StringFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_StringFlags(const char *, int, PyObject *, PyObject *, PyCompilerFlags *)
     * }
     */
    public static FunctionDescriptor PyRun_StringFlags$descriptor() {
        return PyRun_StringFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_StringFlags(const char *, int, PyObject *, PyObject *, PyCompilerFlags *)
     * }
     */
    public static MethodHandle PyRun_StringFlags$handle() {
        return PyRun_StringFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_StringFlags(const char *, int, PyObject *, PyObject *, PyCompilerFlags *)
     * }
     */
    public static MemorySegment PyRun_StringFlags$address() {
        return PyRun_StringFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_StringFlags(const char *, int, PyObject *, PyObject *, PyCompilerFlags *)
     * }
     */
    public static MemorySegment PyRun_StringFlags(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PyRun_StringFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_StringFlags", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_FileExFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_FileExFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_FileExFlags$descriptor() {
        return PyRun_FileExFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_FileExFlags$handle() {
        return PyRun_FileExFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_FileExFlags$address() {
        return PyRun_FileExFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_FileExFlags(MemorySegment fp, MemorySegment filename, int start, MemorySegment globals, MemorySegment locals, int closeit, MemorySegment flags) {
        var mh$ = PyRun_FileExFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_FileExFlags", fp, filename, start, globals, locals, closeit, flags);
            }
            return (MemorySegment)mh$.invokeExact(fp, filename, start, globals, locals, closeit, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_CompileStringExFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_CompileStringExFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringExFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static FunctionDescriptor Py_CompileStringExFlags$descriptor() {
        return Py_CompileStringExFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringExFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MethodHandle Py_CompileStringExFlags$handle() {
        return Py_CompileStringExFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringExFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MemorySegment Py_CompileStringExFlags$address() {
        return Py_CompileStringExFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_CompileStringExFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MemorySegment Py_CompileStringExFlags(MemorySegment str, MemorySegment filename, int start, MemorySegment flags, int optimize) {
        var mh$ = Py_CompileStringExFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_CompileStringExFlags", str, filename, start, flags, optimize);
            }
            return (MemorySegment)mh$.invokeExact(str, filename, start, flags, optimize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_CompileStringObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_CompileStringObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringObject(const char *str, PyObject *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static FunctionDescriptor Py_CompileStringObject$descriptor() {
        return Py_CompileStringObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringObject(const char *str, PyObject *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MethodHandle Py_CompileStringObject$handle() {
        return Py_CompileStringObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringObject(const char *str, PyObject *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MemorySegment Py_CompileStringObject$address() {
        return Py_CompileStringObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_CompileStringObject(const char *str, PyObject *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MemorySegment Py_CompileStringObject(MemorySegment str, MemorySegment filename, int start, MemorySegment flags, int optimize) {
        var mh$ = Py_CompileStringObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_CompileStringObject", str, filename, start, flags, optimize);
            }
            return (MemorySegment)mh$.invokeExact(str, filename, start, flags, optimize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_String(const char *str, int s, PyObject *g, PyObject *l)
     * }
     */
    public static FunctionDescriptor PyRun_String$descriptor() {
        return PyRun_String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_String(const char *str, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MethodHandle PyRun_String$handle() {
        return PyRun_String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_String(const char *str, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MemorySegment PyRun_String$address() {
        return PyRun_String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_String(const char *str, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MemorySegment PyRun_String(MemorySegment str, int s, MemorySegment g, MemorySegment l) {
        var mh$ = PyRun_String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_String", str, s, g, l);
            }
            return (MemorySegment)mh$.invokeExact(str, s, g, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_AnyFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_AnyFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_AnyFile(FILE *fp, const char *name)
     * }
     */
    public static FunctionDescriptor PyRun_AnyFile$descriptor() {
        return PyRun_AnyFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_AnyFile(FILE *fp, const char *name)
     * }
     */
    public static MethodHandle PyRun_AnyFile$handle() {
        return PyRun_AnyFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_AnyFile(FILE *fp, const char *name)
     * }
     */
    public static MemorySegment PyRun_AnyFile$address() {
        return PyRun_AnyFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_AnyFile(FILE *fp, const char *name)
     * }
     */
    public static int PyRun_AnyFile(MemorySegment fp, MemorySegment name) {
        var mh$ = PyRun_AnyFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_AnyFile", fp, name);
            }
            return (int)mh$.invokeExact(fp, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_AnyFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_AnyFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_AnyFileEx(FILE *fp, const char *name, int closeit)
     * }
     */
    public static FunctionDescriptor PyRun_AnyFileEx$descriptor() {
        return PyRun_AnyFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_AnyFileEx(FILE *fp, const char *name, int closeit)
     * }
     */
    public static MethodHandle PyRun_AnyFileEx$handle() {
        return PyRun_AnyFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_AnyFileEx(FILE *fp, const char *name, int closeit)
     * }
     */
    public static MemorySegment PyRun_AnyFileEx$address() {
        return PyRun_AnyFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_AnyFileEx(FILE *fp, const char *name, int closeit)
     * }
     */
    public static int PyRun_AnyFileEx(MemorySegment fp, MemorySegment name, int closeit) {
        var mh$ = PyRun_AnyFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_AnyFileEx", fp, name, closeit);
            }
            return (int)mh$.invokeExact(fp, name, closeit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_AnyFileFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_AnyFileFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *)
     * }
     */
    public static FunctionDescriptor PyRun_AnyFileFlags$descriptor() {
        return PyRun_AnyFileFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *)
     * }
     */
    public static MethodHandle PyRun_AnyFileFlags$handle() {
        return PyRun_AnyFileFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *)
     * }
     */
    public static MemorySegment PyRun_AnyFileFlags$address() {
        return PyRun_AnyFileFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *)
     * }
     */
    public static int PyRun_AnyFileFlags(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyRun_AnyFileFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_AnyFileFlags", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_SimpleString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleString(const char *s)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleString$descriptor() {
        return PyRun_SimpleString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleString(const char *s)
     * }
     */
    public static MethodHandle PyRun_SimpleString$handle() {
        return PyRun_SimpleString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleString(const char *s)
     * }
     */
    public static MemorySegment PyRun_SimpleString$address() {
        return PyRun_SimpleString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleString(const char *s)
     * }
     */
    public static int PyRun_SimpleString(MemorySegment s) {
        var mh$ = PyRun_SimpleString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleString", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_SimpleFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleFile(FILE *f, const char *p)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleFile$descriptor() {
        return PyRun_SimpleFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleFile(FILE *f, const char *p)
     * }
     */
    public static MethodHandle PyRun_SimpleFile$handle() {
        return PyRun_SimpleFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleFile(FILE *f, const char *p)
     * }
     */
    public static MemorySegment PyRun_SimpleFile$address() {
        return PyRun_SimpleFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleFile(FILE *f, const char *p)
     * }
     */
    public static int PyRun_SimpleFile(MemorySegment f, MemorySegment p) {
        var mh$ = PyRun_SimpleFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleFile", f, p);
            }
            return (int)mh$.invokeExact(f, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_SimpleFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileEx(FILE *f, const char *p, int c)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleFileEx$descriptor() {
        return PyRun_SimpleFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileEx(FILE *f, const char *p, int c)
     * }
     */
    public static MethodHandle PyRun_SimpleFileEx$handle() {
        return PyRun_SimpleFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileEx(FILE *f, const char *p, int c)
     * }
     */
    public static MemorySegment PyRun_SimpleFileEx$address() {
        return PyRun_SimpleFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleFileEx(FILE *f, const char *p, int c)
     * }
     */
    public static int PyRun_SimpleFileEx(MemorySegment f, MemorySegment p, int c) {
        var mh$ = PyRun_SimpleFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleFileEx", f, p, c);
            }
            return (int)mh$.invokeExact(f, p, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveOne {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveOne");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOne(FILE *f, const char *p)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveOne$descriptor() {
        return PyRun_InteractiveOne.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOne(FILE *f, const char *p)
     * }
     */
    public static MethodHandle PyRun_InteractiveOne$handle() {
        return PyRun_InteractiveOne.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOne(FILE *f, const char *p)
     * }
     */
    public static MemorySegment PyRun_InteractiveOne$address() {
        return PyRun_InteractiveOne.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveOne(FILE *f, const char *p)
     * }
     */
    public static int PyRun_InteractiveOne(MemorySegment f, MemorySegment p) {
        var mh$ = PyRun_InteractiveOne.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveOne", f, p);
            }
            return (int)mh$.invokeExact(f, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveLoop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveLoop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoop(FILE *f, const char *p)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveLoop$descriptor() {
        return PyRun_InteractiveLoop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoop(FILE *f, const char *p)
     * }
     */
    public static MethodHandle PyRun_InteractiveLoop$handle() {
        return PyRun_InteractiveLoop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoop(FILE *f, const char *p)
     * }
     */
    public static MemorySegment PyRun_InteractiveLoop$address() {
        return PyRun_InteractiveLoop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveLoop(FILE *f, const char *p)
     * }
     */
    public static int PyRun_InteractiveLoop(MemorySegment f, MemorySegment p) {
        var mh$ = PyRun_InteractiveLoop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveLoop", f, p);
            }
            return (int)mh$.invokeExact(f, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_File {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_File");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l)
     * }
     */
    public static FunctionDescriptor PyRun_File$descriptor() {
        return PyRun_File.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MethodHandle PyRun_File$handle() {
        return PyRun_File.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MemorySegment PyRun_File$address() {
        return PyRun_File.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MemorySegment PyRun_File(MemorySegment fp, MemorySegment p, int s, MemorySegment g, MemorySegment l) {
        var mh$ = PyRun_File.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_File", fp, p, s, g, l);
            }
            return (MemorySegment)mh$.invokeExact(fp, p, s, g, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_FileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_FileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c)
     * }
     */
    public static FunctionDescriptor PyRun_FileEx$descriptor() {
        return PyRun_FileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c)
     * }
     */
    public static MethodHandle PyRun_FileEx$handle() {
        return PyRun_FileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c)
     * }
     */
    public static MemorySegment PyRun_FileEx$address() {
        return PyRun_FileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c)
     * }
     */
    public static MemorySegment PyRun_FileEx(MemorySegment fp, MemorySegment p, int s, MemorySegment g, MemorySegment l, int c) {
        var mh$ = PyRun_FileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_FileEx", fp, p, s, g, l, c);
            }
            return (MemorySegment)mh$.invokeExact(fp, p, s, g, l, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_FileFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_FileFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_FileFlags$descriptor() {
        return PyRun_FileFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_FileFlags$handle() {
        return PyRun_FileFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_FileFlags$address() {
        return PyRun_FileFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_FileFlags(MemorySegment fp, MemorySegment p, int s, MemorySegment g, MemorySegment l, MemorySegment flags) {
        var mh$ = PyRun_FileFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_FileFlags", fp, p, s, g, l, flags);
            }
            return (MemorySegment)mh$.invokeExact(fp, p, s, g, l, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_Readline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_Readline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyOS_Readline(FILE *, FILE *, const char *)
     * }
     */
    public static FunctionDescriptor PyOS_Readline$descriptor() {
        return PyOS_Readline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyOS_Readline(FILE *, FILE *, const char *)
     * }
     */
    public static MethodHandle PyOS_Readline$handle() {
        return PyOS_Readline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyOS_Readline(FILE *, FILE *, const char *)
     * }
     */
    public static MemorySegment PyOS_Readline$address() {
        return PyOS_Readline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyOS_Readline(FILE *, FILE *, const char *)
     * }
     */
    public static MemorySegment PyOS_Readline(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyOS_Readline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_Readline", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_ReadlineFunctionPointer$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyOS_ReadlineFunctionPointer").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *)
     * }
     */
    public static AddressLayout PyOS_ReadlineFunctionPointer$layout() {
        return PyOS_ReadlineFunctionPointer$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *)
     * }
     */
    public static MemorySegment PyOS_ReadlineFunctionPointer$segment() {
        return PyOS_ReadlineFunctionPointer$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *)
     * }
     */
    public static MemorySegment PyOS_ReadlineFunctionPointer() {
        return PyOS_ReadlineFunctionPointer$constants.SEGMENT.get(PyOS_ReadlineFunctionPointer$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *)
     * }
     */
    public static void PyOS_ReadlineFunctionPointer(MemorySegment varValue) {
        PyOS_ReadlineFunctionPointer$constants.SEGMENT.set(PyOS_ReadlineFunctionPointer$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_Initialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Initialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static FunctionDescriptor Py_Initialize$descriptor() {
        return Py_Initialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static MethodHandle Py_Initialize$handle() {
        return Py_Initialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static MemorySegment Py_Initialize$address() {
        return Py_Initialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static void Py_Initialize() {
        var mh$ = Py_Initialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Initialize");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_InitializeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_InitializeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static FunctionDescriptor Py_InitializeEx$descriptor() {
        return Py_InitializeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static MethodHandle Py_InitializeEx$handle() {
        return Py_InitializeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static MemorySegment Py_InitializeEx$address() {
        return Py_InitializeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static void Py_InitializeEx(int x0) {
        var mh$ = Py_InitializeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_InitializeEx", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Finalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Finalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static FunctionDescriptor Py_Finalize$descriptor() {
        return Py_Finalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static MethodHandle Py_Finalize$handle() {
        return Py_Finalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static MemorySegment Py_Finalize$address() {
        return Py_Finalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static void Py_Finalize() {
        var mh$ = Py_Finalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Finalize");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FinalizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FinalizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static FunctionDescriptor Py_FinalizeEx$descriptor() {
        return Py_FinalizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static MethodHandle Py_FinalizeEx$handle() {
        return Py_FinalizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static MemorySegment Py_FinalizeEx$address() {
        return Py_FinalizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static int Py_FinalizeEx() {
        var mh$ = Py_FinalizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FinalizeEx");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static FunctionDescriptor Py_IsInitialized$descriptor() {
        return Py_IsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static MethodHandle Py_IsInitialized$handle() {
        return Py_IsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static MemorySegment Py_IsInitialized$address() {
        return Py_IsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static int Py_IsInitialized() {
        var mh$ = Py_IsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsInitialized");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_NewInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_NewInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static FunctionDescriptor Py_NewInterpreter$descriptor() {
        return Py_NewInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static MethodHandle Py_NewInterpreter$handle() {
        return Py_NewInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static MemorySegment Py_NewInterpreter$address() {
        return Py_NewInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static MemorySegment Py_NewInterpreter() {
        var mh$ = Py_NewInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_NewInterpreter");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_EndInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_EndInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static FunctionDescriptor Py_EndInterpreter$descriptor() {
        return Py_EndInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static MethodHandle Py_EndInterpreter$handle() {
        return Py_EndInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static MemorySegment Py_EndInterpreter$address() {
        return Py_EndInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static void Py_EndInterpreter(MemorySegment x0) {
        var mh$ = Py_EndInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_EndInterpreter", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_AtExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_AtExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static FunctionDescriptor Py_AtExit$descriptor() {
        return Py_AtExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static MethodHandle Py_AtExit$handle() {
        return Py_AtExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static MemorySegment Py_AtExit$address() {
        return Py_AtExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static int Py_AtExit(MemorySegment func) {
        var mh$ = Py_AtExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_AtExit", func);
            }
            return (int)mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static FunctionDescriptor Py_Exit$descriptor() {
        return Py_Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static MethodHandle Py_Exit$handle() {
        return Py_Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static MemorySegment Py_Exit$address() {
        return Py_Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static void Py_Exit(int x0) {
        var mh$ = Py_Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Main {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Main");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static FunctionDescriptor Py_Main$descriptor() {
        return Py_Main.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static MethodHandle Py_Main$handle() {
        return Py_Main.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static MemorySegment Py_Main$address() {
        return Py_Main.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static int Py_Main(int argc, MemorySegment argv) {
        var mh$ = Py_Main.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Main", argc, argv);
            }
            return (int)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_BytesMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_BytesMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static FunctionDescriptor Py_BytesMain$descriptor() {
        return Py_BytesMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static MethodHandle Py_BytesMain$handle() {
        return Py_BytesMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static MemorySegment Py_BytesMain$address() {
        return Py_BytesMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static int Py_BytesMain(int argc, MemorySegment argv) {
        var mh$ = Py_BytesMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_BytesMain", argc, argv);
            }
            return (int)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetProgramName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetProgramName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static FunctionDescriptor Py_SetProgramName$descriptor() {
        return Py_SetProgramName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static MethodHandle Py_SetProgramName$handle() {
        return Py_SetProgramName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static MemorySegment Py_SetProgramName$address() {
        return Py_SetProgramName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static void Py_SetProgramName(MemorySegment x0) {
        var mh$ = Py_SetProgramName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetProgramName", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetProgramName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetProgramName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static FunctionDescriptor Py_GetProgramName$descriptor() {
        return Py_GetProgramName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static MethodHandle Py_GetProgramName$handle() {
        return Py_GetProgramName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static MemorySegment Py_GetProgramName$address() {
        return Py_GetProgramName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static MemorySegment Py_GetProgramName() {
        var mh$ = Py_GetProgramName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetProgramName");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetPythonHome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetPythonHome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static FunctionDescriptor Py_SetPythonHome$descriptor() {
        return Py_SetPythonHome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static MethodHandle Py_SetPythonHome$handle() {
        return Py_SetPythonHome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static MemorySegment Py_SetPythonHome$address() {
        return Py_SetPythonHome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static void Py_SetPythonHome(MemorySegment x0) {
        var mh$ = Py_SetPythonHome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetPythonHome", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPythonHome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPythonHome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static FunctionDescriptor Py_GetPythonHome$descriptor() {
        return Py_GetPythonHome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static MethodHandle Py_GetPythonHome$handle() {
        return Py_GetPythonHome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static MemorySegment Py_GetPythonHome$address() {
        return Py_GetPythonHome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static MemorySegment Py_GetPythonHome() {
        var mh$ = Py_GetPythonHome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPythonHome");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetProgramFullPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetProgramFullPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static FunctionDescriptor Py_GetProgramFullPath$descriptor() {
        return Py_GetProgramFullPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static MethodHandle Py_GetProgramFullPath$handle() {
        return Py_GetProgramFullPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static MemorySegment Py_GetProgramFullPath$address() {
        return Py_GetProgramFullPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static MemorySegment Py_GetProgramFullPath() {
        var mh$ = Py_GetProgramFullPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetProgramFullPath");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPrefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPrefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static FunctionDescriptor Py_GetPrefix$descriptor() {
        return Py_GetPrefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static MethodHandle Py_GetPrefix$handle() {
        return Py_GetPrefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static MemorySegment Py_GetPrefix$address() {
        return Py_GetPrefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static MemorySegment Py_GetPrefix() {
        var mh$ = Py_GetPrefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPrefix");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetExecPrefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetExecPrefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static FunctionDescriptor Py_GetExecPrefix$descriptor() {
        return Py_GetExecPrefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static MethodHandle Py_GetExecPrefix$handle() {
        return Py_GetExecPrefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static MemorySegment Py_GetExecPrefix$address() {
        return Py_GetExecPrefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static MemorySegment Py_GetExecPrefix() {
        var mh$ = Py_GetExecPrefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetExecPrefix");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static FunctionDescriptor Py_GetPath$descriptor() {
        return Py_GetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static MethodHandle Py_GetPath$handle() {
        return Py_GetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static MemorySegment Py_GetPath$address() {
        return Py_GetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static MemorySegment Py_GetPath() {
        var mh$ = Py_GetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPath");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static FunctionDescriptor Py_GetVersion$descriptor() {
        return Py_GetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static MethodHandle Py_GetVersion$handle() {
        return Py_GetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static MemorySegment Py_GetVersion$address() {
        return Py_GetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static MemorySegment Py_GetVersion() {
        var mh$ = Py_GetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetVersion");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPlatform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPlatform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static FunctionDescriptor Py_GetPlatform$descriptor() {
        return Py_GetPlatform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static MethodHandle Py_GetPlatform$handle() {
        return Py_GetPlatform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static MemorySegment Py_GetPlatform$address() {
        return Py_GetPlatform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static MemorySegment Py_GetPlatform() {
        var mh$ = Py_GetPlatform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPlatform");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetCopyright {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetCopyright");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static FunctionDescriptor Py_GetCopyright$descriptor() {
        return Py_GetCopyright.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static MethodHandle Py_GetCopyright$handle() {
        return Py_GetCopyright.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static MemorySegment Py_GetCopyright$address() {
        return Py_GetCopyright.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static MemorySegment Py_GetCopyright() {
        var mh$ = Py_GetCopyright.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetCopyright");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetCompiler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetCompiler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static FunctionDescriptor Py_GetCompiler$descriptor() {
        return Py_GetCompiler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static MethodHandle Py_GetCompiler$handle() {
        return Py_GetCompiler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static MemorySegment Py_GetCompiler$address() {
        return Py_GetCompiler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static MemorySegment Py_GetCompiler() {
        var mh$ = Py_GetCompiler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetCompiler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetBuildInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetBuildInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static FunctionDescriptor Py_GetBuildInfo$descriptor() {
        return Py_GetBuildInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static MethodHandle Py_GetBuildInfo$handle() {
        return Py_GetBuildInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static MemorySegment Py_GetBuildInfo$address() {
        return Py_GetBuildInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static MemorySegment Py_GetBuildInfo() {
        var mh$ = Py_GetBuildInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetBuildInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_getsig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_getsig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static FunctionDescriptor PyOS_getsig$descriptor() {
        return PyOS_getsig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static MethodHandle PyOS_getsig$handle() {
        return PyOS_getsig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static MemorySegment PyOS_getsig$address() {
        return PyOS_getsig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static MemorySegment PyOS_getsig(int x0) {
        var mh$ = PyOS_getsig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_getsig", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_setsig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_setsig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static FunctionDescriptor PyOS_setsig$descriptor() {
        return PyOS_setsig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static MethodHandle PyOS_setsig$handle() {
        return PyOS_setsig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static MemorySegment PyOS_setsig$address() {
        return PyOS_setsig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static MemorySegment PyOS_setsig(int x0, MemorySegment x1) {
        var mh$ = PyOS_setsig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_setsig", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Version$constants {
        public static final OfLong LAYOUT = Python_h.C_LONG;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_Version").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static OfLong Py_Version$layout() {
        return Py_Version$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static MemorySegment Py_Version$segment() {
        return Py_Version$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static long Py_Version() {
        return Py_Version$constants.SEGMENT.get(Py_Version$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static void Py_Version(long varValue) {
        Py_Version$constants.SEGMENT.set(Py_Version$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_IsFinalizing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsFinalizing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsFinalizing()
     * }
     */
    public static FunctionDescriptor Py_IsFinalizing$descriptor() {
        return Py_IsFinalizing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsFinalizing()
     * }
     */
    public static MethodHandle Py_IsFinalizing$handle() {
        return Py_IsFinalizing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsFinalizing()
     * }
     */
    public static MemorySegment Py_IsFinalizing$address() {
        return Py_IsFinalizing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsFinalizing()
     * }
     */
    public static int Py_IsFinalizing() {
        var mh$ = Py_IsFinalizing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsFinalizing");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FrozenMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FrozenMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_FrozenMain(int argc, char **argv)
     * }
     */
    public static FunctionDescriptor Py_FrozenMain$descriptor() {
        return Py_FrozenMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_FrozenMain(int argc, char **argv)
     * }
     */
    public static MethodHandle Py_FrozenMain$handle() {
        return Py_FrozenMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_FrozenMain(int argc, char **argv)
     * }
     */
    public static MemorySegment Py_FrozenMain$address() {
        return Py_FrozenMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_FrozenMain(int argc, char **argv)
     * }
     */
    public static int Py_FrozenMain(int argc, MemorySegment argv) {
        var mh$ = Py_FrozenMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FrozenMain", argc, argv);
            }
            return (int)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_PreInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_PreInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitialize(const PyPreConfig *src_config)
     * }
     */
    public static FunctionDescriptor Py_PreInitialize$descriptor() {
        return Py_PreInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitialize(const PyPreConfig *src_config)
     * }
     */
    public static MethodHandle Py_PreInitialize$handle() {
        return Py_PreInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitialize(const PyPreConfig *src_config)
     * }
     */
    public static MemorySegment Py_PreInitialize$address() {
        return Py_PreInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus Py_PreInitialize(const PyPreConfig *src_config)
     * }
     */
    public static MemorySegment Py_PreInitialize(SegmentAllocator allocator, MemorySegment src_config) {
        var mh$ = Py_PreInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_PreInitialize", allocator, src_config);
            }
            return (MemorySegment)mh$.invokeExact(allocator, src_config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_PreInitializeFromBytesArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_PreInitializeFromBytesArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *src_config, Py_ssize_t argc, char **argv)
     * }
     */
    public static FunctionDescriptor Py_PreInitializeFromBytesArgs$descriptor() {
        return Py_PreInitializeFromBytesArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *src_config, Py_ssize_t argc, char **argv)
     * }
     */
    public static MethodHandle Py_PreInitializeFromBytesArgs$handle() {
        return Py_PreInitializeFromBytesArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *src_config, Py_ssize_t argc, char **argv)
     * }
     */
    public static MemorySegment Py_PreInitializeFromBytesArgs$address() {
        return Py_PreInitializeFromBytesArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *src_config, Py_ssize_t argc, char **argv)
     * }
     */
    public static MemorySegment Py_PreInitializeFromBytesArgs(SegmentAllocator allocator, MemorySegment src_config, long argc, MemorySegment argv) {
        var mh$ = Py_PreInitializeFromBytesArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_PreInitializeFromBytesArgs", allocator, src_config, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(allocator, src_config, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_PreInitializeFromArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_PreInitializeFromArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromArgs(const PyPreConfig *src_config, Py_ssize_t argc, wchar_t **argv)
     * }
     */
    public static FunctionDescriptor Py_PreInitializeFromArgs$descriptor() {
        return Py_PreInitializeFromArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromArgs(const PyPreConfig *src_config, Py_ssize_t argc, wchar_t **argv)
     * }
     */
    public static MethodHandle Py_PreInitializeFromArgs$handle() {
        return Py_PreInitializeFromArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromArgs(const PyPreConfig *src_config, Py_ssize_t argc, wchar_t **argv)
     * }
     */
    public static MemorySegment Py_PreInitializeFromArgs$address() {
        return Py_PreInitializeFromArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromArgs(const PyPreConfig *src_config, Py_ssize_t argc, wchar_t **argv)
     * }
     */
    public static MemorySegment Py_PreInitializeFromArgs(SegmentAllocator allocator, MemorySegment src_config, long argc, MemorySegment argv) {
        var mh$ = Py_PreInitializeFromArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_PreInitializeFromArgs", allocator, src_config, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(allocator, src_config, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_InitializeFromConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_InitializeFromConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus Py_InitializeFromConfig(const PyConfig *config)
     * }
     */
    public static FunctionDescriptor Py_InitializeFromConfig$descriptor() {
        return Py_InitializeFromConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus Py_InitializeFromConfig(const PyConfig *config)
     * }
     */
    public static MethodHandle Py_InitializeFromConfig$handle() {
        return Py_InitializeFromConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus Py_InitializeFromConfig(const PyConfig *config)
     * }
     */
    public static MemorySegment Py_InitializeFromConfig$address() {
        return Py_InitializeFromConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus Py_InitializeFromConfig(const PyConfig *config)
     * }
     */
    public static MemorySegment Py_InitializeFromConfig(SegmentAllocator allocator, MemorySegment config) {
        var mh$ = Py_InitializeFromConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_InitializeFromConfig", allocator, config);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_InitializeMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout()    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_InitializeMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus _Py_InitializeMain()
     * }
     */
    public static FunctionDescriptor _Py_InitializeMain$descriptor() {
        return _Py_InitializeMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus _Py_InitializeMain()
     * }
     */
    public static MethodHandle _Py_InitializeMain$handle() {
        return _Py_InitializeMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus _Py_InitializeMain()
     * }
     */
    public static MemorySegment _Py_InitializeMain$address() {
        return _Py_InitializeMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus _Py_InitializeMain()
     * }
     */
    public static MemorySegment _Py_InitializeMain(SegmentAllocator allocator) {
        var mh$ = _Py_InitializeMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_InitializeMain", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_RunMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_RunMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_RunMain()
     * }
     */
    public static FunctionDescriptor Py_RunMain$descriptor() {
        return Py_RunMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_RunMain()
     * }
     */
    public static MethodHandle Py_RunMain$handle() {
        return Py_RunMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_RunMain()
     * }
     */
    public static MemorySegment Py_RunMain$address() {
        return Py_RunMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_RunMain()
     * }
     */
    public static int Py_RunMain() {
        var mh$ = Py_RunMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_RunMain");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ExitStatusException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            PyStatus.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ExitStatusException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_ExitStatusException(PyStatus err)
     * }
     */
    public static FunctionDescriptor Py_ExitStatusException$descriptor() {
        return Py_ExitStatusException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_ExitStatusException(PyStatus err)
     * }
     */
    public static MethodHandle Py_ExitStatusException$handle() {
        return Py_ExitStatusException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_ExitStatusException(PyStatus err)
     * }
     */
    public static MemorySegment Py_ExitStatusException$address() {
        return Py_ExitStatusException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_ExitStatusException(PyStatus err)
     * }
     */
    public static void Py_ExitStatusException(MemorySegment err) {
        var mh$ = Py_ExitStatusException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ExitStatusException", err);
            }
            mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FdIsInteractive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FdIsInteractive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_FdIsInteractive(FILE *, const char *)
     * }
     */
    public static FunctionDescriptor Py_FdIsInteractive$descriptor() {
        return Py_FdIsInteractive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_FdIsInteractive(FILE *, const char *)
     * }
     */
    public static MethodHandle Py_FdIsInteractive$handle() {
        return Py_FdIsInteractive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_FdIsInteractive(FILE *, const char *)
     * }
     */
    public static MemorySegment Py_FdIsInteractive$address() {
        return Py_FdIsInteractive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_FdIsInteractive(FILE *, const char *)
     * }
     */
    public static int Py_FdIsInteractive(MemorySegment x0, MemorySegment x1) {
        var mh$ = Py_FdIsInteractive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FdIsInteractive", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_NewInterpreterFromConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_NewInterpreterFromConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus Py_NewInterpreterFromConfig(PyThreadState **tstate_p, const PyInterpreterConfig *config)
     * }
     */
    public static FunctionDescriptor Py_NewInterpreterFromConfig$descriptor() {
        return Py_NewInterpreterFromConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus Py_NewInterpreterFromConfig(PyThreadState **tstate_p, const PyInterpreterConfig *config)
     * }
     */
    public static MethodHandle Py_NewInterpreterFromConfig$handle() {
        return Py_NewInterpreterFromConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus Py_NewInterpreterFromConfig(PyThreadState **tstate_p, const PyInterpreterConfig *config)
     * }
     */
    public static MemorySegment Py_NewInterpreterFromConfig$address() {
        return Py_NewInterpreterFromConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus Py_NewInterpreterFromConfig(PyThreadState **tstate_p, const PyInterpreterConfig *config)
     * }
     */
    public static MemorySegment Py_NewInterpreterFromConfig(SegmentAllocator allocator, MemorySegment tstate_p, MemorySegment config) {
        var mh$ = Py_NewInterpreterFromConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_NewInterpreterFromConfig", allocator, tstate_p, config);
            }
            return (MemorySegment)mh$.invokeExact(allocator, tstate_p, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_AtExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_AtExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_AtExit(PyInterpreterState *, atexit_datacallbackfunc, void *)
     * }
     */
    public static FunctionDescriptor PyUnstable_AtExit$descriptor() {
        return PyUnstable_AtExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_AtExit(PyInterpreterState *, atexit_datacallbackfunc, void *)
     * }
     */
    public static MethodHandle PyUnstable_AtExit$handle() {
        return PyUnstable_AtExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_AtExit(PyInterpreterState *, atexit_datacallbackfunc, void *)
     * }
     */
    public static MemorySegment PyUnstable_AtExit$address() {
        return PyUnstable_AtExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_AtExit(PyInterpreterState *, atexit_datacallbackfunc, void *)
     * }
     */
    public static int PyUnstable_AtExit(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyUnstable_AtExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_AtExit", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_EvalCode$descriptor() {
        return PyEval_EvalCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyEval_EvalCode$handle() {
        return PyEval_EvalCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyEval_EvalCode$address() {
        return PyEval_EvalCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyEval_EvalCode(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyEval_EvalCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalCode", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalCodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalCodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static FunctionDescriptor PyEval_EvalCodeEx$descriptor() {
        return PyEval_EvalCodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static MethodHandle PyEval_EvalCodeEx$handle() {
        return PyEval_EvalCodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static MemorySegment PyEval_EvalCodeEx$address() {
        return PyEval_EvalCodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static MemorySegment PyEval_EvalCodeEx(MemorySegment co, MemorySegment globals, MemorySegment locals, MemorySegment args, int argc, MemorySegment kwds, int kwdc, MemorySegment defs, int defc, MemorySegment kwdefs, MemorySegment closure) {
        var mh$ = PyEval_EvalCodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalCodeEx", co, globals, locals, args, argc, kwds, kwdc, defs, defc, kwdefs, closure);
            }
            return (MemorySegment)mh$.invokeExact(co, globals, locals, args, argc, kwds, kwdc, defs, defc, kwdefs, closure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetBuiltins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetBuiltins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static FunctionDescriptor PyEval_GetBuiltins$descriptor() {
        return PyEval_GetBuiltins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static MethodHandle PyEval_GetBuiltins$handle() {
        return PyEval_GetBuiltins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static MemorySegment PyEval_GetBuiltins$address() {
        return PyEval_GetBuiltins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static MemorySegment PyEval_GetBuiltins() {
        var mh$ = PyEval_GetBuiltins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetBuiltins");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetGlobals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetGlobals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static FunctionDescriptor PyEval_GetGlobals$descriptor() {
        return PyEval_GetGlobals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static MethodHandle PyEval_GetGlobals$handle() {
        return PyEval_GetGlobals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static MemorySegment PyEval_GetGlobals$address() {
        return PyEval_GetGlobals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static MemorySegment PyEval_GetGlobals() {
        var mh$ = PyEval_GetGlobals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetGlobals");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetLocals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetLocals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static FunctionDescriptor PyEval_GetLocals$descriptor() {
        return PyEval_GetLocals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static MethodHandle PyEval_GetLocals$handle() {
        return PyEval_GetLocals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static MemorySegment PyEval_GetLocals$address() {
        return PyEval_GetLocals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static MemorySegment PyEval_GetLocals() {
        var mh$ = PyEval_GetLocals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetLocals");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static FunctionDescriptor PyEval_GetFrame$descriptor() {
        return PyEval_GetFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static MethodHandle PyEval_GetFrame$handle() {
        return PyEval_GetFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static MemorySegment PyEval_GetFrame$address() {
        return PyEval_GetFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static MemorySegment PyEval_GetFrame() {
        var mh$ = PyEval_GetFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFrame");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFrameBuiltins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFrameBuiltins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameBuiltins()
     * }
     */
    public static FunctionDescriptor PyEval_GetFrameBuiltins$descriptor() {
        return PyEval_GetFrameBuiltins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameBuiltins()
     * }
     */
    public static MethodHandle PyEval_GetFrameBuiltins$handle() {
        return PyEval_GetFrameBuiltins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameBuiltins()
     * }
     */
    public static MemorySegment PyEval_GetFrameBuiltins$address() {
        return PyEval_GetFrameBuiltins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameBuiltins()
     * }
     */
    public static MemorySegment PyEval_GetFrameBuiltins() {
        var mh$ = PyEval_GetFrameBuiltins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFrameBuiltins");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFrameGlobals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFrameGlobals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameGlobals()
     * }
     */
    public static FunctionDescriptor PyEval_GetFrameGlobals$descriptor() {
        return PyEval_GetFrameGlobals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameGlobals()
     * }
     */
    public static MethodHandle PyEval_GetFrameGlobals$handle() {
        return PyEval_GetFrameGlobals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameGlobals()
     * }
     */
    public static MemorySegment PyEval_GetFrameGlobals$address() {
        return PyEval_GetFrameGlobals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameGlobals()
     * }
     */
    public static MemorySegment PyEval_GetFrameGlobals() {
        var mh$ = PyEval_GetFrameGlobals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFrameGlobals");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFrameLocals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFrameLocals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameLocals()
     * }
     */
    public static FunctionDescriptor PyEval_GetFrameLocals$descriptor() {
        return PyEval_GetFrameLocals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameLocals()
     * }
     */
    public static MethodHandle PyEval_GetFrameLocals$handle() {
        return PyEval_GetFrameLocals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameLocals()
     * }
     */
    public static MemorySegment PyEval_GetFrameLocals$address() {
        return PyEval_GetFrameLocals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetFrameLocals()
     * }
     */
    public static MemorySegment PyEval_GetFrameLocals() {
        var mh$ = PyEval_GetFrameLocals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFrameLocals");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_AddPendingCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_AddPendingCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static FunctionDescriptor Py_AddPendingCall$descriptor() {
        return Py_AddPendingCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static MethodHandle Py_AddPendingCall$handle() {
        return Py_AddPendingCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static MemorySegment Py_AddPendingCall$address() {
        return Py_AddPendingCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static int Py_AddPendingCall(MemorySegment func, MemorySegment arg) {
        var mh$ = Py_AddPendingCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_AddPendingCall", func, arg);
            }
            return (int)mh$.invokeExact(func, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_MakePendingCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_MakePendingCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static FunctionDescriptor Py_MakePendingCalls$descriptor() {
        return Py_MakePendingCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static MethodHandle Py_MakePendingCalls$handle() {
        return Py_MakePendingCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static MemorySegment Py_MakePendingCalls$address() {
        return Py_MakePendingCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static int Py_MakePendingCalls() {
        var mh$ = Py_MakePendingCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_MakePendingCalls");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetRecursionLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetRecursionLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static FunctionDescriptor Py_SetRecursionLimit$descriptor() {
        return Py_SetRecursionLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static MethodHandle Py_SetRecursionLimit$handle() {
        return Py_SetRecursionLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static MemorySegment Py_SetRecursionLimit$address() {
        return Py_SetRecursionLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static void Py_SetRecursionLimit(int x0) {
        var mh$ = Py_SetRecursionLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetRecursionLimit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetRecursionLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetRecursionLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static FunctionDescriptor Py_GetRecursionLimit$descriptor() {
        return Py_GetRecursionLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static MethodHandle Py_GetRecursionLimit$handle() {
        return Py_GetRecursionLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static MemorySegment Py_GetRecursionLimit$address() {
        return Py_GetRecursionLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static int Py_GetRecursionLimit() {
        var mh$ = Py_GetRecursionLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetRecursionLimit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_EnterRecursiveCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_EnterRecursiveCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static FunctionDescriptor Py_EnterRecursiveCall$descriptor() {
        return Py_EnterRecursiveCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static MethodHandle Py_EnterRecursiveCall$handle() {
        return Py_EnterRecursiveCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static MemorySegment Py_EnterRecursiveCall$address() {
        return Py_EnterRecursiveCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static int Py_EnterRecursiveCall(MemorySegment where) {
        var mh$ = Py_EnterRecursiveCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_EnterRecursiveCall", where);
            }
            return (int)mh$.invokeExact(where);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_LeaveRecursiveCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_LeaveRecursiveCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static FunctionDescriptor Py_LeaveRecursiveCall$descriptor() {
        return Py_LeaveRecursiveCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static MethodHandle Py_LeaveRecursiveCall$handle() {
        return Py_LeaveRecursiveCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static MemorySegment Py_LeaveRecursiveCall$address() {
        return Py_LeaveRecursiveCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static void Py_LeaveRecursiveCall() {
        var mh$ = Py_LeaveRecursiveCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_LeaveRecursiveCall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFuncName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFuncName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_GetFuncName$descriptor() {
        return PyEval_GetFuncName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static MethodHandle PyEval_GetFuncName$handle() {
        return PyEval_GetFuncName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncName$address() {
        return PyEval_GetFuncName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncName(MemorySegment x0) {
        var mh$ = PyEval_GetFuncName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFuncName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFuncDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFuncDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_GetFuncDesc$descriptor() {
        return PyEval_GetFuncDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static MethodHandle PyEval_GetFuncDesc$handle() {
        return PyEval_GetFuncDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncDesc$address() {
        return PyEval_GetFuncDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncDesc(MemorySegment x0) {
        var mh$ = PyEval_GetFuncDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFuncDesc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyEval_EvalFrame$descriptor() {
        return PyEval_EvalFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static MethodHandle PyEval_EvalFrame$handle() {
        return PyEval_EvalFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static MemorySegment PyEval_EvalFrame$address() {
        return PyEval_EvalFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static MemorySegment PyEval_EvalFrame(MemorySegment x0) {
        var mh$ = PyEval_EvalFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalFrame", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalFrameEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalFrameEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static FunctionDescriptor PyEval_EvalFrameEx$descriptor() {
        return PyEval_EvalFrameEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static MethodHandle PyEval_EvalFrameEx$handle() {
        return PyEval_EvalFrameEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static MemorySegment PyEval_EvalFrameEx$address() {
        return PyEval_EvalFrameEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static MemorySegment PyEval_EvalFrameEx(MemorySegment f, int exc) {
        var mh$ = PyEval_EvalFrameEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalFrameEx", f, exc);
            }
            return (MemorySegment)mh$.invokeExact(f, exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SaveThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SaveThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static FunctionDescriptor PyEval_SaveThread$descriptor() {
        return PyEval_SaveThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static MethodHandle PyEval_SaveThread$handle() {
        return PyEval_SaveThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static MemorySegment PyEval_SaveThread$address() {
        return PyEval_SaveThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static MemorySegment PyEval_SaveThread() {
        var mh$ = PyEval_SaveThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SaveThread");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_RestoreThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_RestoreThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyEval_RestoreThread$descriptor() {
        return PyEval_RestoreThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static MethodHandle PyEval_RestoreThread$handle() {
        return PyEval_RestoreThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static MemorySegment PyEval_RestoreThread$address() {
        return PyEval_RestoreThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static void PyEval_RestoreThread(MemorySegment x0) {
        var mh$ = PyEval_RestoreThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_RestoreThread", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_InitThreads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_InitThreads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static FunctionDescriptor PyEval_InitThreads$descriptor() {
        return PyEval_InitThreads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static MethodHandle PyEval_InitThreads$handle() {
        return PyEval_InitThreads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static MemorySegment PyEval_InitThreads$address() {
        return PyEval_InitThreads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static void PyEval_InitThreads() {
        var mh$ = PyEval_InitThreads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_InitThreads");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_AcquireThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_AcquireThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyEval_AcquireThread$descriptor() {
        return PyEval_AcquireThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyEval_AcquireThread$handle() {
        return PyEval_AcquireThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyEval_AcquireThread$address() {
        return PyEval_AcquireThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static void PyEval_AcquireThread(MemorySegment tstate) {
        var mh$ = PyEval_AcquireThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_AcquireThread", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_ReleaseThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_ReleaseThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyEval_ReleaseThread$descriptor() {
        return PyEval_ReleaseThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyEval_ReleaseThread$handle() {
        return PyEval_ReleaseThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyEval_ReleaseThread$address() {
        return PyEval_ReleaseThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static void PyEval_ReleaseThread(MemorySegment tstate) {
        var mh$ = PyEval_ReleaseThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_ReleaseThread", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetProfile$descriptor() {
        return PyEval_SetProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetProfile$handle() {
        return PyEval_SetProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetProfile$address() {
        return PyEval_SetProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetProfile(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetProfile", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetProfileAllThreads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetProfileAllThreads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetProfileAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetProfileAllThreads$descriptor() {
        return PyEval_SetProfileAllThreads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetProfileAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetProfileAllThreads$handle() {
        return PyEval_SetProfileAllThreads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetProfileAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetProfileAllThreads$address() {
        return PyEval_SetProfileAllThreads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetProfileAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetProfileAllThreads(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetProfileAllThreads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetProfileAllThreads", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetTrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetTrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetTrace$descriptor() {
        return PyEval_SetTrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetTrace$handle() {
        return PyEval_SetTrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetTrace$address() {
        return PyEval_SetTrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetTrace(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetTrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetTrace", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetTraceAllThreads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetTraceAllThreads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetTraceAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetTraceAllThreads$descriptor() {
        return PyEval_SetTraceAllThreads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetTraceAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetTraceAllThreads$handle() {
        return PyEval_SetTraceAllThreads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetTraceAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetTraceAllThreads$address() {
        return PyEval_SetTraceAllThreads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetTraceAllThreads(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetTraceAllThreads(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetTraceAllThreads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetTraceAllThreads", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_MergeCompilerFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_MergeCompilerFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static FunctionDescriptor PyEval_MergeCompilerFlags$descriptor() {
        return PyEval_MergeCompilerFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static MethodHandle PyEval_MergeCompilerFlags$handle() {
        return PyEval_MergeCompilerFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static MemorySegment PyEval_MergeCompilerFlags$address() {
        return PyEval_MergeCompilerFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static int PyEval_MergeCompilerFlags(MemorySegment cf) {
        var mh$ = PyEval_MergeCompilerFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_MergeCompilerFlags", cf);
            }
            return (int)mh$.invokeExact(cf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_EvalFrameDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_EvalFrameDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static FunctionDescriptor _PyEval_EvalFrameDefault$descriptor() {
        return _PyEval_EvalFrameDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static MethodHandle _PyEval_EvalFrameDefault$handle() {
        return _PyEval_EvalFrameDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static MemorySegment _PyEval_EvalFrameDefault$address() {
        return _PyEval_EvalFrameDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static MemorySegment _PyEval_EvalFrameDefault(MemorySegment tstate, MemorySegment f, int exc) {
        var mh$ = _PyEval_EvalFrameDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_EvalFrameDefault", tstate, f, exc);
            }
            return (MemorySegment)mh$.invokeExact(tstate, f, exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_Eval_RequestCodeExtraIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_Eval_RequestCodeExtraIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Eval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static FunctionDescriptor PyUnstable_Eval_RequestCodeExtraIndex$descriptor() {
        return PyUnstable_Eval_RequestCodeExtraIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Eval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static MethodHandle PyUnstable_Eval_RequestCodeExtraIndex$handle() {
        return PyUnstable_Eval_RequestCodeExtraIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Eval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static MemorySegment PyUnstable_Eval_RequestCodeExtraIndex$address() {
        return PyUnstable_Eval_RequestCodeExtraIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnstable_Eval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static long PyUnstable_Eval_RequestCodeExtraIndex(MemorySegment x0) {
        var mh$ = PyUnstable_Eval_RequestCodeExtraIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_Eval_RequestCodeExtraIndex", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SliceIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SliceIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor _PyEval_SliceIndex$descriptor() {
        return _PyEval_SliceIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle _PyEval_SliceIndex$handle() {
        return _PyEval_SliceIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment _PyEval_SliceIndex$address() {
        return _PyEval_SliceIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static int _PyEval_SliceIndex(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyEval_SliceIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SliceIndex", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SliceIndexNotNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SliceIndexNotNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor _PyEval_SliceIndexNotNone$descriptor() {
        return _PyEval_SliceIndexNotNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle _PyEval_SliceIndexNotNone$handle() {
        return _PyEval_SliceIndexNotNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment _PyEval_SliceIndexNotNone$address() {
        return _PyEval_SliceIndexNotNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static int _PyEval_SliceIndexNotNone(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyEval_SliceIndexNotNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SliceIndexNotNone", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static FunctionDescriptor PySys_GetObject$descriptor() {
        return PySys_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MethodHandle PySys_GetObject$handle() {
        return PySys_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MemorySegment PySys_GetObject$address() {
        return PySys_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MemorySegment PySys_GetObject(MemorySegment x0) {
        var mh$ = PySys_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PySys_SetObject$descriptor() {
        return PySys_SetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static MethodHandle PySys_SetObject$handle() {
        return PySys_SetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static MemorySegment PySys_SetObject$address() {
        return PySys_SetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static int PySys_SetObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PySys_SetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetObject", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static FunctionDescriptor PySys_SetArgv$descriptor() {
        return PySys_SetArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static MethodHandle PySys_SetArgv$handle() {
        return PySys_SetArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static MemorySegment PySys_SetArgv$address() {
        return PySys_SetArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static void PySys_SetArgv(int x0, MemorySegment x1) {
        var mh$ = PySys_SetArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetArgv", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetArgvEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetArgvEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static FunctionDescriptor PySys_SetArgvEx$descriptor() {
        return PySys_SetArgvEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static MethodHandle PySys_SetArgvEx$handle() {
        return PySys_SetArgvEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static MemorySegment PySys_SetArgvEx$address() {
        return PySys_SetArgvEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static void PySys_SetArgvEx(int x0, MemorySegment x1, int x2) {
        var mh$ = PySys_SetArgvEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetArgvEx", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_WriteStdout(const char *format, ...)
     * }
     */
    public static class PySys_WriteStdout {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_WriteStdout");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_WriteStdout(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_WriteStdout(const char *format, ...)
         * }
         */
        public static PySys_WriteStdout makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_WriteStdout(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_WriteStdout", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_WriteStderr(const char *format, ...)
     * }
     */
    public static class PySys_WriteStderr {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_WriteStderr");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_WriteStderr(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_WriteStderr(const char *format, ...)
         * }
         */
        public static PySys_WriteStderr makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_WriteStderr(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_WriteStderr", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_FormatStdout(const char *format, ...)
     * }
     */
    public static class PySys_FormatStdout {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_FormatStdout");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_FormatStdout(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_FormatStdout(const char *format, ...)
         * }
         */
        public static PySys_FormatStdout makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_FormatStdout(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_FormatStdout", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_FormatStderr(const char *format, ...)
     * }
     */
    public static class PySys_FormatStderr {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_FormatStderr");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_FormatStderr(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_FormatStderr(const char *format, ...)
         * }
         */
        public static PySys_FormatStderr makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_FormatStderr(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_FormatStderr", format, x1);
                }
                 spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PySys_ResetWarnOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_ResetWarnOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static FunctionDescriptor PySys_ResetWarnOptions$descriptor() {
        return PySys_ResetWarnOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static MethodHandle PySys_ResetWarnOptions$handle() {
        return PySys_ResetWarnOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static MemorySegment PySys_ResetWarnOptions$address() {
        return PySys_ResetWarnOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static void PySys_ResetWarnOptions() {
        var mh$ = PySys_ResetWarnOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_ResetWarnOptions");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_GetXOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_GetXOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static FunctionDescriptor PySys_GetXOptions$descriptor() {
        return PySys_GetXOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MethodHandle PySys_GetXOptions$handle() {
        return PySys_GetXOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MemorySegment PySys_GetXOptions$address() {
        return PySys_GetXOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MemorySegment PySys_GetXOptions() {
        var mh$ = PySys_GetXOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_GetXOptions");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PySys_Audit(const char *event, const char *argFormat, ...)
     * }
     */
    public static class PySys_Audit {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_Audit");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_Audit(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PySys_Audit(const char *event, const char *argFormat, ...)
         * }
         */
        public static PySys_Audit makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_Audit(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment event, MemorySegment argFormat, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_Audit", event, argFormat, x2);
                }
                return (int) spreader.invokeExact(event, argFormat, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PySys_AuditTuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AuditTuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_AuditTuple(const char *event, PyObject *args)
     * }
     */
    public static FunctionDescriptor PySys_AuditTuple$descriptor() {
        return PySys_AuditTuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_AuditTuple(const char *event, PyObject *args)
     * }
     */
    public static MethodHandle PySys_AuditTuple$handle() {
        return PySys_AuditTuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_AuditTuple(const char *event, PyObject *args)
     * }
     */
    public static MemorySegment PySys_AuditTuple$address() {
        return PySys_AuditTuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_AuditTuple(const char *event, PyObject *args)
     * }
     */
    public static int PySys_AuditTuple(MemorySegment event, MemorySegment args) {
        var mh$ = PySys_AuditTuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AuditTuple", event, args);
            }
            return (int)mh$.invokeExact(event, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddAuditHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddAuditHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static FunctionDescriptor PySys_AddAuditHook$descriptor() {
        return PySys_AddAuditHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static MethodHandle PySys_AddAuditHook$handle() {
        return PySys_AddAuditHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static MemorySegment PySys_AddAuditHook$address() {
        return PySys_AddAuditHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static int PySys_AddAuditHook(MemorySegment x0, MemorySegment x1) {
        var mh$ = PySys_AddAuditHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddAuditHook", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_PerfMapState_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_PerfMapState_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_PerfMapState_Init()
     * }
     */
    public static FunctionDescriptor PyUnstable_PerfMapState_Init$descriptor() {
        return PyUnstable_PerfMapState_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_PerfMapState_Init()
     * }
     */
    public static MethodHandle PyUnstable_PerfMapState_Init$handle() {
        return PyUnstable_PerfMapState_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_PerfMapState_Init()
     * }
     */
    public static MemorySegment PyUnstable_PerfMapState_Init$address() {
        return PyUnstable_PerfMapState_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_PerfMapState_Init()
     * }
     */
    public static int PyUnstable_PerfMapState_Init() {
        var mh$ = PyUnstable_PerfMapState_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_PerfMapState_Init");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_WritePerfMapEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_WritePerfMapEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_WritePerfMapEntry(const void *code_addr, unsigned int code_size, const char *entry_name)
     * }
     */
    public static FunctionDescriptor PyUnstable_WritePerfMapEntry$descriptor() {
        return PyUnstable_WritePerfMapEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_WritePerfMapEntry(const void *code_addr, unsigned int code_size, const char *entry_name)
     * }
     */
    public static MethodHandle PyUnstable_WritePerfMapEntry$handle() {
        return PyUnstable_WritePerfMapEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_WritePerfMapEntry(const void *code_addr, unsigned int code_size, const char *entry_name)
     * }
     */
    public static MemorySegment PyUnstable_WritePerfMapEntry$address() {
        return PyUnstable_WritePerfMapEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_WritePerfMapEntry(const void *code_addr, unsigned int code_size, const char *entry_name)
     * }
     */
    public static int PyUnstable_WritePerfMapEntry(MemorySegment code_addr, int code_size, MemorySegment entry_name) {
        var mh$ = PyUnstable_WritePerfMapEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_WritePerfMapEntry", code_addr, code_size, entry_name);
            }
            return (int)mh$.invokeExact(code_addr, code_size, entry_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_PerfMapState_Fini {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_PerfMapState_Fini");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnstable_PerfMapState_Fini()
     * }
     */
    public static FunctionDescriptor PyUnstable_PerfMapState_Fini$descriptor() {
        return PyUnstable_PerfMapState_Fini.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnstable_PerfMapState_Fini()
     * }
     */
    public static MethodHandle PyUnstable_PerfMapState_Fini$handle() {
        return PyUnstable_PerfMapState_Fini.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnstable_PerfMapState_Fini()
     * }
     */
    public static MemorySegment PyUnstable_PerfMapState_Fini$address() {
        return PyUnstable_PerfMapState_Fini.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnstable_PerfMapState_Fini()
     * }
     */
    public static void PyUnstable_PerfMapState_Fini() {
        var mh$ = PyUnstable_PerfMapState_Fini.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_PerfMapState_Fini");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_CopyPerfMapFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_CopyPerfMapFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_CopyPerfMapFile(const char *parent_filename)
     * }
     */
    public static FunctionDescriptor PyUnstable_CopyPerfMapFile$descriptor() {
        return PyUnstable_CopyPerfMapFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_CopyPerfMapFile(const char *parent_filename)
     * }
     */
    public static MethodHandle PyUnstable_CopyPerfMapFile$handle() {
        return PyUnstable_CopyPerfMapFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_CopyPerfMapFile(const char *parent_filename)
     * }
     */
    public static MemorySegment PyUnstable_CopyPerfMapFile$address() {
        return PyUnstable_CopyPerfMapFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_CopyPerfMapFile(const char *parent_filename)
     * }
     */
    public static int PyUnstable_CopyPerfMapFile(MemorySegment parent_filename) {
        var mh$ = PyUnstable_CopyPerfMapFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_CopyPerfMapFile", parent_filename);
            }
            return (int)mh$.invokeExact(parent_filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_PerfTrampoline_CompileCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_PerfTrampoline_CompileCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_PerfTrampoline_CompileCode(PyCodeObject *)
     * }
     */
    public static FunctionDescriptor PyUnstable_PerfTrampoline_CompileCode$descriptor() {
        return PyUnstable_PerfTrampoline_CompileCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_PerfTrampoline_CompileCode(PyCodeObject *)
     * }
     */
    public static MethodHandle PyUnstable_PerfTrampoline_CompileCode$handle() {
        return PyUnstable_PerfTrampoline_CompileCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_PerfTrampoline_CompileCode(PyCodeObject *)
     * }
     */
    public static MemorySegment PyUnstable_PerfTrampoline_CompileCode$address() {
        return PyUnstable_PerfTrampoline_CompileCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_PerfTrampoline_CompileCode(PyCodeObject *)
     * }
     */
    public static int PyUnstable_PerfTrampoline_CompileCode(MemorySegment x0) {
        var mh$ = PyUnstable_PerfTrampoline_CompileCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_PerfTrampoline_CompileCode", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnstable_PerfTrampoline_SetPersistAfterFork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnstable_PerfTrampoline_SetPersistAfterFork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnstable_PerfTrampoline_SetPersistAfterFork(int enable)
     * }
     */
    public static FunctionDescriptor PyUnstable_PerfTrampoline_SetPersistAfterFork$descriptor() {
        return PyUnstable_PerfTrampoline_SetPersistAfterFork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnstable_PerfTrampoline_SetPersistAfterFork(int enable)
     * }
     */
    public static MethodHandle PyUnstable_PerfTrampoline_SetPersistAfterFork$handle() {
        return PyUnstable_PerfTrampoline_SetPersistAfterFork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnstable_PerfTrampoline_SetPersistAfterFork(int enable)
     * }
     */
    public static MemorySegment PyUnstable_PerfTrampoline_SetPersistAfterFork$address() {
        return PyUnstable_PerfTrampoline_SetPersistAfterFork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnstable_PerfTrampoline_SetPersistAfterFork(int enable)
     * }
     */
    public static int PyUnstable_PerfTrampoline_SetPersistAfterFork(int enable) {
        var mh$ = PyUnstable_PerfTrampoline_SetPersistAfterFork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnstable_PerfTrampoline_SetPersistAfterFork", enable);
            }
            return (int)mh$.invokeExact(enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_FSPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_FSPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyOS_FSPath$descriptor() {
        return PyOS_FSPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MethodHandle PyOS_FSPath$handle() {
        return PyOS_FSPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MemorySegment PyOS_FSPath$address() {
        return PyOS_FSPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MemorySegment PyOS_FSPath(MemorySegment path) {
        var mh$ = PyOS_FSPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_FSPath", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_InterruptOccurred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_InterruptOccurred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static FunctionDescriptor PyOS_InterruptOccurred$descriptor() {
        return PyOS_InterruptOccurred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static MethodHandle PyOS_InterruptOccurred$handle() {
        return PyOS_InterruptOccurred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static MemorySegment PyOS_InterruptOccurred$address() {
        return PyOS_InterruptOccurred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static int PyOS_InterruptOccurred() {
        var mh$ = PyOS_InterruptOccurred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_InterruptOccurred");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_BeforeFork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_BeforeFork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_BeforeFork()
     * }
     */
    public static FunctionDescriptor PyOS_BeforeFork$descriptor() {
        return PyOS_BeforeFork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_BeforeFork()
     * }
     */
    public static MethodHandle PyOS_BeforeFork$handle() {
        return PyOS_BeforeFork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_BeforeFork()
     * }
     */
    public static MemorySegment PyOS_BeforeFork$address() {
        return PyOS_BeforeFork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_BeforeFork()
     * }
     */
    public static void PyOS_BeforeFork() {
        var mh$ = PyOS_BeforeFork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_BeforeFork");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_AfterFork_Parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_AfterFork_Parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Parent()
     * }
     */
    public static FunctionDescriptor PyOS_AfterFork_Parent$descriptor() {
        return PyOS_AfterFork_Parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Parent()
     * }
     */
    public static MethodHandle PyOS_AfterFork_Parent$handle() {
        return PyOS_AfterFork_Parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Parent()
     * }
     */
    public static MemorySegment PyOS_AfterFork_Parent$address() {
        return PyOS_AfterFork_Parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_AfterFork_Parent()
     * }
     */
    public static void PyOS_AfterFork_Parent() {
        var mh$ = PyOS_AfterFork_Parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_AfterFork_Parent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_AfterFork_Child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_AfterFork_Child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Child()
     * }
     */
    public static FunctionDescriptor PyOS_AfterFork_Child$descriptor() {
        return PyOS_AfterFork_Child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Child()
     * }
     */
    public static MethodHandle PyOS_AfterFork_Child$handle() {
        return PyOS_AfterFork_Child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Child()
     * }
     */
    public static MemorySegment PyOS_AfterFork_Child$address() {
        return PyOS_AfterFork_Child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_AfterFork_Child()
     * }
     */
    public static void PyOS_AfterFork_Child() {
        var mh$ = PyOS_AfterFork_Child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_AfterFork_Child");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_AfterFork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_AfterFork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static FunctionDescriptor PyOS_AfterFork$descriptor() {
        return PyOS_AfterFork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static MethodHandle PyOS_AfterFork$handle() {
        return PyOS_AfterFork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static MemorySegment PyOS_AfterFork$address() {
        return PyOS_AfterFork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static void PyOS_AfterFork() {
        var mh$ = PyOS_AfterFork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_AfterFork");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetMagicNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetMagicNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static FunctionDescriptor PyImport_GetMagicNumber$descriptor() {
        return PyImport_GetMagicNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static MethodHandle PyImport_GetMagicNumber$handle() {
        return PyImport_GetMagicNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static MemorySegment PyImport_GetMagicNumber$address() {
        return PyImport_GetMagicNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static long PyImport_GetMagicNumber() {
        var mh$ = PyImport_GetMagicNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetMagicNumber");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetMagicTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetMagicTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static FunctionDescriptor PyImport_GetMagicTag$descriptor() {
        return PyImport_GetMagicTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MethodHandle PyImport_GetMagicTag$handle() {
        return PyImport_GetMagicTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MemorySegment PyImport_GetMagicTag$address() {
        return PyImport_GetMagicTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MemorySegment PyImport_GetMagicTag() {
        var mh$ = PyImport_GetMagicTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetMagicTag");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModule$descriptor() {
        return PyImport_ExecCodeModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModule$handle() {
        return PyImport_ExecCodeModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModule$address() {
        return PyImport_ExecCodeModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModule(MemorySegment name, MemorySegment co) {
        var mh$ = PyImport_ExecCodeModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModule", name, co);
            }
            return (MemorySegment)mh$.invokeExact(name, co);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleEx$descriptor() {
        return PyImport_ExecCodeModuleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleEx$handle() {
        return PyImport_ExecCodeModuleEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleEx$address() {
        return PyImport_ExecCodeModuleEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleEx(MemorySegment name, MemorySegment co, MemorySegment pathname) {
        var mh$ = PyImport_ExecCodeModuleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleEx", name, co, pathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleWithPathnames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleWithPathnames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleWithPathnames$descriptor() {
        return PyImport_ExecCodeModuleWithPathnames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleWithPathnames$handle() {
        return PyImport_ExecCodeModuleWithPathnames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleWithPathnames$address() {
        return PyImport_ExecCodeModuleWithPathnames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleWithPathnames(MemorySegment name, MemorySegment co, MemorySegment pathname, MemorySegment cpathname) {
        var mh$ = PyImport_ExecCodeModuleWithPathnames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleWithPathnames", name, co, pathname, cpathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname, cpathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleObject$descriptor() {
        return PyImport_ExecCodeModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleObject$handle() {
        return PyImport_ExecCodeModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleObject$address() {
        return PyImport_ExecCodeModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleObject(MemorySegment name, MemorySegment co, MemorySegment pathname, MemorySegment cpathname) {
        var mh$ = PyImport_ExecCodeModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleObject", name, co, pathname, cpathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname, cpathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetModuleDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetModuleDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static FunctionDescriptor PyImport_GetModuleDict$descriptor() {
        return PyImport_GetModuleDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MethodHandle PyImport_GetModuleDict$handle() {
        return PyImport_GetModuleDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MemorySegment PyImport_GetModuleDict$address() {
        return PyImport_GetModuleDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MemorySegment PyImport_GetModuleDict() {
        var mh$ = PyImport_GetModuleDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetModuleDict");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_GetModule$descriptor() {
        return PyImport_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_GetModule$handle() {
        return PyImport_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_GetModule$address() {
        return PyImport_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_GetModule(MemorySegment name) {
        var mh$ = PyImport_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AddModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AddModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_AddModuleObject$descriptor() {
        return PyImport_AddModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_AddModuleObject$handle() {
        return PyImport_AddModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleObject$address() {
        return PyImport_AddModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleObject(MemorySegment name) {
        var mh$ = PyImport_AddModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AddModuleObject", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AddModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AddModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_AddModule$descriptor() {
        return PyImport_AddModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_AddModule$handle() {
        return PyImport_AddModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModule$address() {
        return PyImport_AddModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModule(MemorySegment name) {
        var mh$ = PyImport_AddModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AddModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AddModuleRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AddModuleRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleRef(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_AddModuleRef$descriptor() {
        return PyImport_AddModuleRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleRef(const char *name)
     * }
     */
    public static MethodHandle PyImport_AddModuleRef$handle() {
        return PyImport_AddModuleRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleRef(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleRef$address() {
        return PyImport_AddModuleRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleRef(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleRef(MemorySegment name) {
        var mh$ = PyImport_AddModuleRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AddModuleRef", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModule$descriptor() {
        return PyImport_ImportModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportModule$handle() {
        return PyImport_ImportModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModule$address() {
        return PyImport_ImportModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModule(MemorySegment name) {
        var mh$ = PyImport_ImportModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleNoBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleNoBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleNoBlock$descriptor() {
        return PyImport_ImportModuleNoBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportModuleNoBlock$handle() {
        return PyImport_ImportModuleNoBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModuleNoBlock$address() {
        return PyImport_ImportModuleNoBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModuleNoBlock(MemorySegment name) {
        var mh$ = PyImport_ImportModuleNoBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleNoBlock", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleLevel$descriptor() {
        return PyImport_ImportModuleLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MethodHandle PyImport_ImportModuleLevel$handle() {
        return PyImport_ImportModuleLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevel$address() {
        return PyImport_ImportModuleLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevel(MemorySegment name, MemorySegment globals, MemorySegment locals, MemorySegment fromlist, int level) {
        var mh$ = PyImport_ImportModuleLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleLevel", name, globals, locals, fromlist, level);
            }
            return (MemorySegment)mh$.invokeExact(name, globals, locals, fromlist, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleLevelObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleLevelObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleLevelObject$descriptor() {
        return PyImport_ImportModuleLevelObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MethodHandle PyImport_ImportModuleLevelObject$handle() {
        return PyImport_ImportModuleLevelObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevelObject$address() {
        return PyImport_ImportModuleLevelObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevelObject(MemorySegment name, MemorySegment globals, MemorySegment locals, MemorySegment fromlist, int level) {
        var mh$ = PyImport_ImportModuleLevelObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleLevelObject", name, globals, locals, fromlist, level);
            }
            return (MemorySegment)mh$.invokeExact(name, globals, locals, fromlist, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetImporter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetImporter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyImport_GetImporter$descriptor() {
        return PyImport_GetImporter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MethodHandle PyImport_GetImporter$handle() {
        return PyImport_GetImporter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MemorySegment PyImport_GetImporter$address() {
        return PyImport_GetImporter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MemorySegment PyImport_GetImporter(MemorySegment path) {
        var mh$ = PyImport_GetImporter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetImporter", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_Import {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_Import");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_Import$descriptor() {
        return PyImport_Import.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_Import$handle() {
        return PyImport_Import.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_Import$address() {
        return PyImport_Import.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_Import(MemorySegment name) {
        var mh$ = PyImport_Import.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_Import", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ReloadModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ReloadModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static FunctionDescriptor PyImport_ReloadModule$descriptor() {
        return PyImport_ReloadModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MethodHandle PyImport_ReloadModule$handle() {
        return PyImport_ReloadModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MemorySegment PyImport_ReloadModule$address() {
        return PyImport_ReloadModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MemorySegment PyImport_ReloadModule(MemorySegment m) {
        var mh$ = PyImport_ReloadModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ReloadModule", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportFrozenModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportFrozenModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportFrozenModuleObject$descriptor() {
        return PyImport_ImportFrozenModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_ImportFrozenModuleObject$handle() {
        return PyImport_ImportFrozenModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_ImportFrozenModuleObject$address() {
        return PyImport_ImportFrozenModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static int PyImport_ImportFrozenModuleObject(MemorySegment name) {
        var mh$ = PyImport_ImportFrozenModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportFrozenModuleObject", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportFrozenModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportFrozenModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportFrozenModule$descriptor() {
        return PyImport_ImportFrozenModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportFrozenModule$handle() {
        return PyImport_ImportFrozenModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportFrozenModule$address() {
        return PyImport_ImportFrozenModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static int PyImport_ImportFrozenModule(MemorySegment name) {
        var mh$ = PyImport_ImportFrozenModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportFrozenModule", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AppendInittab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AppendInittab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static FunctionDescriptor PyImport_AppendInittab$descriptor() {
        return PyImport_AppendInittab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static MethodHandle PyImport_AppendInittab$handle() {
        return PyImport_AppendInittab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static MemorySegment PyImport_AppendInittab$address() {
        return PyImport_AppendInittab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static int PyImport_AppendInittab(MemorySegment name, MemorySegment initfunc) {
        var mh$ = PyImport_AppendInittab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AppendInittab", name, initfunc);
            }
            return (int)mh$.invokeExact(name, initfunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInit__imp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInit__imp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static FunctionDescriptor PyInit__imp$descriptor() {
        return PyInit__imp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static MethodHandle PyInit__imp$handle() {
        return PyInit__imp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static MemorySegment PyInit__imp$address() {
        return PyInit__imp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static MemorySegment PyInit__imp() {
        var mh$ = PyInit__imp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInit__imp");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_Inittab$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyImport_Inittab").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static AddressLayout PyImport_Inittab$layout() {
        return PyImport_Inittab$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static MemorySegment PyImport_Inittab$segment() {
        return PyImport_Inittab$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static MemorySegment PyImport_Inittab() {
        return PyImport_Inittab$constants.SEGMENT.get(PyImport_Inittab$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static void PyImport_Inittab(MemorySegment varValue) {
        PyImport_Inittab$constants.SEGMENT.set(PyImport_Inittab$constants.LAYOUT, 0L, varValue);
    }

    private static class PyImport_ExtendInittab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExtendInittab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static FunctionDescriptor PyImport_ExtendInittab$descriptor() {
        return PyImport_ExtendInittab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static MethodHandle PyImport_ExtendInittab$handle() {
        return PyImport_ExtendInittab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static MemorySegment PyImport_ExtendInittab$address() {
        return PyImport_ExtendInittab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static int PyImport_ExtendInittab(MemorySegment newtab) {
        var mh$ = PyImport_ExtendInittab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExtendInittab", newtab);
            }
            return (int)mh$.invokeExact(newtab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_FrozenModules$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyImport_FrozenModules").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static AddressLayout PyImport_FrozenModules$layout() {
        return PyImport_FrozenModules$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static MemorySegment PyImport_FrozenModules$segment() {
        return PyImport_FrozenModules$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static MemorySegment PyImport_FrozenModules() {
        return PyImport_FrozenModules$constants.SEGMENT.get(PyImport_FrozenModules$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static void PyImport_FrozenModules(MemorySegment varValue) {
        PyImport_FrozenModules$constants.SEGMENT.set(PyImport_FrozenModules$constants.LAYOUT, 0L, varValue);
    }

    private static class PyObject_CallNoArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallNoArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static FunctionDescriptor PyObject_CallNoArgs$descriptor() {
        return PyObject_CallNoArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MethodHandle PyObject_CallNoArgs$handle() {
        return PyObject_CallNoArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MemorySegment PyObject_CallNoArgs$address() {
        return PyObject_CallNoArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MemorySegment PyObject_CallNoArgs(MemorySegment func) {
        var mh$ = PyObject_CallNoArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallNoArgs", func);
            }
            return (MemorySegment)mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static FunctionDescriptor PyObject_Call$descriptor() {
        return PyObject_Call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MethodHandle PyObject_Call$handle() {
        return PyObject_Call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_Call$address() {
        return PyObject_Call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_Call(MemorySegment callable, MemorySegment args, MemorySegment kwargs) {
        var mh$ = PyObject_Call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Call", callable, args, kwargs);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, kwargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static FunctionDescriptor PyObject_CallObject$descriptor() {
        return PyObject_CallObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MethodHandle PyObject_CallObject$handle() {
        return PyObject_CallObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MemorySegment PyObject_CallObject$address() {
        return PyObject_CallObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MemorySegment PyObject_CallObject(MemorySegment callable, MemorySegment args) {
        var mh$ = PyObject_CallObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallObject", callable, args);
            }
            return (MemorySegment)mh$.invokeExact(callable, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallFunction(PyObject *callable, const char *format, ...)
     * }
     */
    public static class PyObject_CallFunction {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFunction");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallFunction(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallFunction(PyObject *callable, const char *format, ...)
         * }
         */
        public static PyObject_CallFunction makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallFunction(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallFunction", callable, format, x2);
                }
                return (MemorySegment) spreader.invokeExact(callable, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)
     * }
     */
    public static class PyObject_CallMethod {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallMethod");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallMethod(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)
         * }
         */
        public static PyObject_CallMethod makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallMethod(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallMethod", obj, name, format, x3);
                }
                return (MemorySegment) spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallFunctionObjArgs(PyObject *callable, ...)
     * }
     */
    public static class PyObject_CallFunctionObjArgs {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFunctionObjArgs");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallFunctionObjArgs(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallFunctionObjArgs(PyObject *callable, ...)
         * }
         */
        public static PyObject_CallFunctionObjArgs makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallFunctionObjArgs(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallFunctionObjArgs", callable, x1);
                }
                return (MemorySegment) spreader.invokeExact(callable, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)
     * }
     */
    public static class PyObject_CallMethodObjArgs {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallMethodObjArgs");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallMethodObjArgs(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)
         * }
         */
        public static PyObject_CallMethodObjArgs makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallMethodObjArgs(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallMethodObjArgs", obj, name, x2);
                }
                return (MemorySegment) spreader.invokeExact(obj, name, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyVectorcall_NARGS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyVectorcall_NARGS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static FunctionDescriptor PyVectorcall_NARGS$descriptor() {
        return PyVectorcall_NARGS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static MethodHandle PyVectorcall_NARGS$handle() {
        return PyVectorcall_NARGS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static MemorySegment PyVectorcall_NARGS$address() {
        return PyVectorcall_NARGS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyVectorcall_NARGS(size_t nargsf)
     * }
     */
    public static long PyVectorcall_NARGS(long nargsf) {
        var mh$ = PyVectorcall_NARGS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyVectorcall_NARGS", nargsf);
            }
            return (long)mh$.invokeExact(nargsf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyVectorcall_Call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyVectorcall_Call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyVectorcall_Call$descriptor() {
        return PyVectorcall_Call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static MethodHandle PyVectorcall_Call$handle() {
        return PyVectorcall_Call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static MemorySegment PyVectorcall_Call$address() {
        return PyVectorcall_Call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
     * }
     */
    public static MemorySegment PyVectorcall_Call(MemorySegment callable, MemorySegment tuple, MemorySegment dict) {
        var mh$ = PyVectorcall_Call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyVectorcall_Call", callable, tuple, dict);
            }
            return (MemorySegment)mh$.invokeExact(callable, tuple, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Vectorcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Vectorcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static FunctionDescriptor PyObject_Vectorcall$descriptor() {
        return PyObject_Vectorcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MethodHandle PyObject_Vectorcall$handle() {
        return PyObject_Vectorcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_Vectorcall$address() {
        return PyObject_Vectorcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_Vectorcall(MemorySegment callable, MemorySegment args, long nargsf, MemorySegment kwnames) {
        var mh$ = PyObject_Vectorcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Vectorcall", callable, args, nargsf, kwnames);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, nargsf, kwnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_VectorcallMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_VectorcallMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static FunctionDescriptor PyObject_VectorcallMethod$descriptor() {
        return PyObject_VectorcallMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MethodHandle PyObject_VectorcallMethod$handle() {
        return PyObject_VectorcallMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_VectorcallMethod$address() {
        return PyObject_VectorcallMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_VectorcallMethod(PyObject *name, PyObject *const *args, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment PyObject_VectorcallMethod(MemorySegment name, MemorySegment args, long nargsf, MemorySegment kwnames) {
        var mh$ = PyObject_VectorcallMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_VectorcallMethod", name, args, nargsf, kwnames);
            }
            return (MemorySegment)mh$.invokeExact(name, args, nargsf, kwnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Type$descriptor() {
        return PyObject_Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Type$handle() {
        return PyObject_Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Type$address() {
        return PyObject_Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Type(MemorySegment o) {
        var mh$ = PyObject_Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Type", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Size$descriptor() {
        return PyObject_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Size$handle() {
        return PyObject_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Size$address() {
        return PyObject_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static long PyObject_Size(MemorySegment o) {
        var mh$ = PyObject_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Size", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Length$descriptor() {
        return PyObject_Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Length$handle() {
        return PyObject_Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Length$address() {
        return PyObject_Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static long PyObject_Length(MemorySegment o) {
        var mh$ = PyObject_Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Length", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyObject_GetItem$descriptor() {
        return PyObject_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MethodHandle PyObject_GetItem$handle() {
        return PyObject_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_GetItem$address() {
        return PyObject_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_GetItem(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetItem", o, key);
            }
            return (MemorySegment)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static FunctionDescriptor PyObject_SetItem$descriptor() {
        return PyObject_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static MethodHandle PyObject_SetItem$handle() {
        return PyObject_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static MemorySegment PyObject_SetItem$address() {
        return PyObject_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
     * }
     */
    public static int PyObject_SetItem(MemorySegment o, MemorySegment key, MemorySegment v) {
        var mh$ = PyObject_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetItem", o, key, v);
            }
            return (int)mh$.invokeExact(o, key, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_DelItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_DelItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static FunctionDescriptor PyObject_DelItemString$descriptor() {
        return PyObject_DelItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static MethodHandle PyObject_DelItemString$handle() {
        return PyObject_DelItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static MemorySegment PyObject_DelItemString$address() {
        return PyObject_DelItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_DelItemString(PyObject *o, const char *key)
     * }
     */
    public static int PyObject_DelItemString(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_DelItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_DelItemString", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyObject_DelItem$descriptor() {
        return PyObject_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static MethodHandle PyObject_DelItem$handle() {
        return PyObject_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_DelItem$address() {
        return PyObject_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_DelItem(PyObject *o, PyObject *key)
     * }
     */
    public static int PyObject_DelItem(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_DelItem", o, key);
            }
            return (int)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static FunctionDescriptor PyObject_Format$descriptor() {
        return PyObject_Format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static MethodHandle PyObject_Format$handle() {
        return PyObject_Format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static MemorySegment PyObject_Format$address() {
        return PyObject_Format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
     * }
     */
    public static MemorySegment PyObject_Format(MemorySegment obj, MemorySegment format_spec) {
        var mh$ = PyObject_Format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Format", obj, format_spec);
            }
            return (MemorySegment)mh$.invokeExact(obj, format_spec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetIter$descriptor() {
        return PyObject_GetIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetIter$handle() {
        return PyObject_GetIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetIter$address() {
        return PyObject_GetIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetIter(MemorySegment x0) {
        var mh$ = PyObject_GetIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAIter$descriptor() {
        return PyObject_GetAIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetAIter$handle() {
        return PyObject_GetAIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAIter$address() {
        return PyObject_GetAIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAIter(MemorySegment x0) {
        var mh$ = PyObject_GetAIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIter_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIter_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyIter_Check$descriptor() {
        return PyIter_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static MethodHandle PyIter_Check$handle() {
        return PyIter_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static MemorySegment PyIter_Check$address() {
        return PyIter_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyIter_Check(PyObject *)
     * }
     */
    public static int PyIter_Check(MemorySegment x0) {
        var mh$ = PyIter_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIter_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyAIter_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyAIter_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyAIter_Check$descriptor() {
        return PyAIter_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static MethodHandle PyAIter_Check$handle() {
        return PyAIter_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static MemorySegment PyAIter_Check$address() {
        return PyAIter_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyAIter_Check(PyObject *)
     * }
     */
    public static int PyAIter_Check(MemorySegment x0) {
        var mh$ = PyAIter_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyAIter_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIter_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIter_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static FunctionDescriptor PyIter_Next$descriptor() {
        return PyIter_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static MethodHandle PyIter_Next$handle() {
        return PyIter_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static MemorySegment PyIter_Next$address() {
        return PyIter_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyIter_Next(PyObject *)
     * }
     */
    public static MemorySegment PyIter_Next(MemorySegment x0) {
        var mh$ = PyIter_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIter_Next", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyIter_Send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyIter_Send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static FunctionDescriptor PyIter_Send$descriptor() {
        return PyIter_Send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MethodHandle PyIter_Send$handle() {
        return PyIter_Send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MemorySegment PyIter_Send$address() {
        return PyIter_Send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PySendResult PyIter_Send(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static int PyIter_Send(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyIter_Send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyIter_Send", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Check$descriptor() {
        return PyNumber_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Check$handle() {
        return PyNumber_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Check$address() {
        return PyNumber_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyNumber_Check(PyObject *o)
     * }
     */
    public static int PyNumber_Check(MemorySegment o) {
        var mh$ = PyNumber_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Check", o);
            }
            return (int)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Add$descriptor() {
        return PyNumber_Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Add$handle() {
        return PyNumber_Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Add$address() {
        return PyNumber_Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Add(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Add", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Subtract$descriptor() {
        return PyNumber_Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Subtract$handle() {
        return PyNumber_Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Subtract$address() {
        return PyNumber_Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Subtract(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Subtract", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Multiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Multiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Multiply$descriptor() {
        return PyNumber_Multiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Multiply$handle() {
        return PyNumber_Multiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Multiply$address() {
        return PyNumber_Multiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Multiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Multiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Multiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_MatrixMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_MatrixMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_MatrixMultiply$descriptor() {
        return PyNumber_MatrixMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_MatrixMultiply$handle() {
        return PyNumber_MatrixMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_MatrixMultiply$address() {
        return PyNumber_MatrixMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_MatrixMultiply(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_MatrixMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_MatrixMultiply", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_FloorDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_FloorDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_FloorDivide$descriptor() {
        return PyNumber_FloorDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_FloorDivide$handle() {
        return PyNumber_FloorDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_FloorDivide$address() {
        return PyNumber_FloorDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_FloorDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_FloorDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_FloorDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_TrueDivide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_TrueDivide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_TrueDivide$descriptor() {
        return PyNumber_TrueDivide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_TrueDivide$handle() {
        return PyNumber_TrueDivide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_TrueDivide$address() {
        return PyNumber_TrueDivide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_TrueDivide(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_TrueDivide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_TrueDivide", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Remainder$descriptor() {
        return PyNumber_Remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Remainder$handle() {
        return PyNumber_Remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Remainder$address() {
        return PyNumber_Remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Remainder(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Remainder", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Divmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Divmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Divmod$descriptor() {
        return PyNumber_Divmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Divmod$handle() {
        return PyNumber_Divmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Divmod$address() {
        return PyNumber_Divmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Divmod(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Divmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Divmod", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Power {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Power");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static FunctionDescriptor PyNumber_Power$descriptor() {
        return PyNumber_Power.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MethodHandle PyNumber_Power$handle() {
        return PyNumber_Power.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_Power$address() {
        return PyNumber_Power.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
     * }
     */
    public static MemorySegment PyNumber_Power(MemorySegment o1, MemorySegment o2, MemorySegment o3) {
        var mh$ = PyNumber_Power.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Power", o1, o2, o3);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2, o3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Negative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Negative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Negative$descriptor() {
        return PyNumber_Negative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Negative$handle() {
        return PyNumber_Negative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Negative$address() {
        return PyNumber_Negative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Negative(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Negative(MemorySegment o) {
        var mh$ = PyNumber_Negative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Negative", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Positive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Positive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Positive$descriptor() {
        return PyNumber_Positive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Positive$handle() {
        return PyNumber_Positive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Positive$address() {
        return PyNumber_Positive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Positive(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Positive(MemorySegment o) {
        var mh$ = PyNumber_Positive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Positive", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Absolute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Absolute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Absolute$descriptor() {
        return PyNumber_Absolute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Absolute$handle() {
        return PyNumber_Absolute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Absolute$address() {
        return PyNumber_Absolute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Absolute(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Absolute(MemorySegment o) {
        var mh$ = PyNumber_Absolute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Absolute", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyNumber_Invert$descriptor() {
        return PyNumber_Invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static MethodHandle PyNumber_Invert$handle() {
        return PyNumber_Invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Invert$address() {
        return PyNumber_Invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Invert(PyObject *o)
     * }
     */
    public static MemorySegment PyNumber_Invert(MemorySegment o) {
        var mh$ = PyNumber_Invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Invert", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Lshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Lshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Lshift$descriptor() {
        return PyNumber_Lshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Lshift$handle() {
        return PyNumber_Lshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Lshift$address() {
        return PyNumber_Lshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Lshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Lshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Lshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Rshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Rshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Rshift$descriptor() {
        return PyNumber_Rshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Rshift$handle() {
        return PyNumber_Rshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Rshift$address() {
        return PyNumber_Rshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Rshift(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Rshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Rshift", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_And {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_And");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_And$descriptor() {
        return PyNumber_And.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_And$handle() {
        return PyNumber_And.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_And$address() {
        return PyNumber_And.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_And(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_And.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_And", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Xor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Xor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Xor$descriptor() {
        return PyNumber_Xor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Xor$handle() {
        return PyNumber_Xor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Xor$address() {
        return PyNumber_Xor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Xor(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Xor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Xor", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyNumber_Or {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyNumber_Or");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static FunctionDescriptor PyNumber_Or$descriptor() {
        return PyNumber_Or.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static MethodHandle PyNumber_Or$handle() {
        return PyNumber_Or.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Or$address() {
        return PyNumber_Or.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
     * }
     */
    public static MemorySegment PyNumber_Or(MemorySegment o1, MemorySegment o2) {
        var mh$ = PyNumber_Or.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyNumber_Or", o1, o2);
            }
            return (MemorySegment)mh$.invokeExact(o1, o2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

