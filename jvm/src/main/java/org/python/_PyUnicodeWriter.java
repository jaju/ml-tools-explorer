// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct {
 *     PyObject *buffer;
 *     void *data;
 *     int kind;
 *     Py_UCS4 maxchar;
 *     Py_ssize_t size;
 *     Py_ssize_t pos;
 *     Py_ssize_t min_length;
 *     Py_UCS4 min_char;
 *     unsigned char overallocate;
 *     unsigned char readonly;
 * }
 * }
 */
public class _PyUnicodeWriter {

    _PyUnicodeWriter() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        Python_h.C_POINTER.withName("buffer"),
        Python_h.C_POINTER.withName("data"),
        Python_h.C_INT.withName("kind"),
        Python_h.C_INT.withName("maxchar"),
        Python_h.C_LONG.withName("size"),
        Python_h.C_LONG.withName("pos"),
        Python_h.C_LONG.withName("min_length"),
        Python_h.C_INT.withName("min_char"),
        Python_h.C_CHAR.withName("overallocate"),
        Python_h.C_CHAR.withName("readonly"),
        MemoryLayout.paddingLayout(2)
    ).withName("$anon$449:9");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout buffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("buffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PyObject *buffer
     * }
     */
    public static final AddressLayout buffer$layout() {
        return buffer$LAYOUT;
    }

    private static final long buffer$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PyObject *buffer
     * }
     */
    public static final long buffer$offset() {
        return buffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PyObject *buffer
     * }
     */
    public static MemorySegment buffer(MemorySegment struct) {
        return struct.get(buffer$LAYOUT, buffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PyObject *buffer
     * }
     */
    public static void buffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(buffer$LAYOUT, buffer$OFFSET, fieldValue);
    }

    private static final AddressLayout data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static final AddressLayout data$layout() {
        return data$LAYOUT;
    }

    private static final long data$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static final long data$offset() {
        return data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static MemorySegment data(MemorySegment struct) {
        return struct.get(data$LAYOUT, data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *data
     * }
     */
    public static void data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(data$LAYOUT, data$OFFSET, fieldValue);
    }

    private static final OfInt kind$LAYOUT = (OfInt)$LAYOUT.select(groupElement("kind"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int kind
     * }
     */
    public static final OfInt kind$layout() {
        return kind$LAYOUT;
    }

    private static final long kind$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int kind
     * }
     */
    public static final long kind$offset() {
        return kind$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int kind
     * }
     */
    public static int kind(MemorySegment struct) {
        return struct.get(kind$LAYOUT, kind$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int kind
     * }
     */
    public static void kind(MemorySegment struct, int fieldValue) {
        struct.set(kind$LAYOUT, kind$OFFSET, fieldValue);
    }

    private static final OfInt maxchar$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxchar"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * Py_UCS4 maxchar
     * }
     */
    public static final OfInt maxchar$layout() {
        return maxchar$LAYOUT;
    }

    private static final long maxchar$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * Py_UCS4 maxchar
     * }
     */
    public static final long maxchar$offset() {
        return maxchar$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * Py_UCS4 maxchar
     * }
     */
    public static int maxchar(MemorySegment struct) {
        return struct.get(maxchar$LAYOUT, maxchar$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * Py_UCS4 maxchar
     * }
     */
    public static void maxchar(MemorySegment struct, int fieldValue) {
        struct.set(maxchar$LAYOUT, maxchar$OFFSET, fieldValue);
    }

    private static final OfLong size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * Py_ssize_t size
     * }
     */
    public static final OfLong size$layout() {
        return size$LAYOUT;
    }

    private static final long size$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * Py_ssize_t size
     * }
     */
    public static final long size$offset() {
        return size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * Py_ssize_t size
     * }
     */
    public static long size(MemorySegment struct) {
        return struct.get(size$LAYOUT, size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * Py_ssize_t size
     * }
     */
    public static void size(MemorySegment struct, long fieldValue) {
        struct.set(size$LAYOUT, size$OFFSET, fieldValue);
    }

    private static final OfLong pos$LAYOUT = (OfLong)$LAYOUT.select(groupElement("pos"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * Py_ssize_t pos
     * }
     */
    public static final OfLong pos$layout() {
        return pos$LAYOUT;
    }

    private static final long pos$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * Py_ssize_t pos
     * }
     */
    public static final long pos$offset() {
        return pos$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * Py_ssize_t pos
     * }
     */
    public static long pos(MemorySegment struct) {
        return struct.get(pos$LAYOUT, pos$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * Py_ssize_t pos
     * }
     */
    public static void pos(MemorySegment struct, long fieldValue) {
        struct.set(pos$LAYOUT, pos$OFFSET, fieldValue);
    }

    private static final OfLong min_length$LAYOUT = (OfLong)$LAYOUT.select(groupElement("min_length"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * Py_ssize_t min_length
     * }
     */
    public static final OfLong min_length$layout() {
        return min_length$LAYOUT;
    }

    private static final long min_length$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * Py_ssize_t min_length
     * }
     */
    public static final long min_length$offset() {
        return min_length$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * Py_ssize_t min_length
     * }
     */
    public static long min_length(MemorySegment struct) {
        return struct.get(min_length$LAYOUT, min_length$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * Py_ssize_t min_length
     * }
     */
    public static void min_length(MemorySegment struct, long fieldValue) {
        struct.set(min_length$LAYOUT, min_length$OFFSET, fieldValue);
    }

    private static final OfInt min_char$LAYOUT = (OfInt)$LAYOUT.select(groupElement("min_char"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * Py_UCS4 min_char
     * }
     */
    public static final OfInt min_char$layout() {
        return min_char$LAYOUT;
    }

    private static final long min_char$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * Py_UCS4 min_char
     * }
     */
    public static final long min_char$offset() {
        return min_char$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * Py_UCS4 min_char
     * }
     */
    public static int min_char(MemorySegment struct) {
        return struct.get(min_char$LAYOUT, min_char$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * Py_UCS4 min_char
     * }
     */
    public static void min_char(MemorySegment struct, int fieldValue) {
        struct.set(min_char$LAYOUT, min_char$OFFSET, fieldValue);
    }

    private static final OfByte overallocate$LAYOUT = (OfByte)$LAYOUT.select(groupElement("overallocate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned char overallocate
     * }
     */
    public static final OfByte overallocate$layout() {
        return overallocate$LAYOUT;
    }

    private static final long overallocate$OFFSET = 52;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned char overallocate
     * }
     */
    public static final long overallocate$offset() {
        return overallocate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned char overallocate
     * }
     */
    public static byte overallocate(MemorySegment struct) {
        return struct.get(overallocate$LAYOUT, overallocate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned char overallocate
     * }
     */
    public static void overallocate(MemorySegment struct, byte fieldValue) {
        struct.set(overallocate$LAYOUT, overallocate$OFFSET, fieldValue);
    }

    private static final OfByte readonly$LAYOUT = (OfByte)$LAYOUT.select(groupElement("readonly"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned char readonly
     * }
     */
    public static final OfByte readonly$layout() {
        return readonly$LAYOUT;
    }

    private static final long readonly$OFFSET = 53;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned char readonly
     * }
     */
    public static final long readonly$offset() {
        return readonly$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned char readonly
     * }
     */
    public static byte readonly(MemorySegment struct) {
        return struct.get(readonly$LAYOUT, readonly$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned char readonly
     * }
     */
    public static void readonly(MemorySegment struct, byte fieldValue) {
        struct.set(readonly$LAYOUT, readonly$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

